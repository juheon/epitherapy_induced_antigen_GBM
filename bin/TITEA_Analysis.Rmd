
---
title: "Glioblastoma nanoCAGE, mRNA, longRead, and Mass Spec Analysis"
output: html_notebook
---

#Load in the RNA-seq data for processing and trnaslating before confirming with the CAGE data and prioritizing candidates

```{r}
load("/scratch/nakul/TE_Antigen_glioblastoma_project/mRNA_analysisFinal/assembled/Step11_FINAL.RData")
```

```{r}
annotatedcufftranscripts$ratio <- annotatedcufftranscripts$tumor_count/annotatedcufftranscripts$normal_count

annotatedcufftranscripts.fil <- annotatedcufftranscripts

```

```{r}

getRefBed <- function(uniqid, structurestring, gene_name, transcript_name){
  longvector <- c()
  chrexample <- strsplit(structurestring, ",")[[1]][2]
  strandexample <- strsplit(structurestring, ",")[[1]][1]
  elementsvec <- as.numeric(tail(strsplit(structurestring, ",")[[1]],-2))
  elementsvec <- sort(elementsvec)
  startexons <- paste(elementsvec[c(TRUE, FALSE)], collapse=',')
  endexons <- paste(elementsvec[c(FALSE, TRUE)], collapse=',')
  longvector <- c(longvector, chrexample)
  longvector  <- c(longvector, min(elementsvec))
  longvector  <- c(longvector, max(elementsvec))
  longvector  <- c(longvector, min(elementsvec))
  longvector  <- c(longvector, max(elementsvec))
  longvector  <- c(longvector, strandexample)
  longvector  <- c(longvector, gene_name)
  longvector  <- c(longvector, transcript_name)
  longvector  <- c(longvector, "coding")
  longvector  <- c(longvector, startexons)
  longvector  <- c(longvector, endexons)
  longvector  <- c(longvector, uniqid)
  return(longvector)
}

refbedexamples <- apply(annotatedcufftranscripts.fil[,c("uniqid", "transcoord", "gene2", "transcriptname")], 1, function(x) getRefBed(x[1],x[2], x[3], x[4]))
refbedexamples <- unlist(refbedexamples)
refbedexamples.m <- matrix(refbedexamples, nrow=12)
refbedexamples.m <- as.data.frame(t(refbedexamples.m), stringsAsFactors = FALSE)
refbedexamples.m$V2 <- as.numeric(refbedexamples.m$V2)
refbedexamples.m <- refbedexamples.m[order(refbedexamples.m$V1, refbedexamples.m$V2),]
write.table(refbedexamples.m, "merged_transcripts_all.refBed", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
```

## Frame Calculation and FASTA Creation

```{r}
library('ggplot2')
library('parallel')
library('BSgenome.Hsapiens.UCSC.hg38')
library(reshape2)
library(biomaRt)
library('snow')

calORF <- function(newtranscript, oldtranscript, oldstartcodon){
  
  #Testing Purposes
  #annotatedcufftranscripts.lin28b <- annotatedcufftranscripts[annotatedcufftranscripts$gene2 == 'NLRC4', ]
  #newtranscript <- as.character(annotatedcufftranscripts.lin28b$transcoord[1])
  #oldtranscript <- as.character(annotatedcufftranscripts.lin28b$elements2[1])
  #oldstartcodon <- as.character(annotatedcufftranscripts.lin28b$startcodon2[1])
  
  library('BSgenome.Hsapiens.UCSC.hg38')
  
  print(oldtranscript)
  print(oldstartcodon)
  newtlist = strsplit(newtranscript, ",")[[1]]
  strand = newtlist[1]
  chromosome = newtlist[2]
  for (i in 3:length(newtlist)) {
    if (!i %% 2){
    } else{
      if (strand == "+"){
        if (i==3){
          exons = c(strtoi(newtlist[i]),strtoi(newtlist[i + 1]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i]),strtoi(newtlist[i + 1])))
        }
      }else {
        if (i==3){
          exons = c(strtoi(newtlist[i+1]),strtoi(newtlist[i]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i+1]),strtoi(newtlist[i])))
        }
      }
    }
  }
  if (is.null(dim(exons))){
    exons = t(as.matrix(exons))
  }
  numexons = dim(exons)[1]
  if (numexons > 1){
    exons <- exons[order(exons[,1]),]
  }
  locationexons = c()
  sequenceexons = ""
  for (i in 1:numexons){
    locationexons = append(locationexons,seq.int(exons[i,1], exons[i,2]))
    sequenceexons = paste0(sequenceexons, toString(getSeq(Hsapiens, chromosome, exons[i,1], exons[i,2])))
  }
  
  if (strand == "-"){
    sequenceexons = toString(reverseComplement(DNAString(sequenceexons)))
    locationexons = rev(locationexons)
  }
  startcodons <- gregexpr(pattern ='ATG',sequenceexons)[[1]]
  strongstart = "None"
  strongproteintrans = "None"
  strongstartloc = "None"
  strongendloc = "None"
  
  # Find the start codon
  for (startcodon in startcodons){
    
    substringcodon = substr(sequenceexons,startcodon-6,startcodon+3)
    substringcodonvec = c()
    for (i in 1:nchar(substringcodon)){
      substringcodonvec = append(substringcodonvec, substr(substringcodon,i,i))
    }
    kosak1 = c("G","C","C","G","C","C","A","T","G","G")
    kosak2 = c("G","C","C","A","C","C","A","T","G","G")
    trusum1 = sum(kosak1 == substringcodonvec)
    trusum2 = sum(kosak2 == substringcodonvec)
    score = max(trusum1, trusum2)
    
    # Consensus to the main importnat positions is needed
    if (score >= 4){
      if (substr(substringcodon,4,4) == "A" || substr(substringcodon,4,4) == "G" || substr(substringcodon,10,10) == "G"){
        proteintrans = toString(translate(DNAString(substring(sequenceexons,startcodon,nchar(sequenceexons)))))
        endloc = gregexpr(pattern ='\\*',proteintrans)[[1]][1]
        if (endloc > 50 || (endloc == -1 && nchar(proteintrans) > 50)){
          strongstart = startcodon
          strongproteintrans = proteintrans
          fullproteintrans = proteintrans
          strongendlocfactor = endloc*3
          strongstartloc = locationexons[strongstart]
          break
        }
      }
    }
  }
  
  if (strongstart != "None"){
    
    # This will generate a tuple list of all the dimensions of the exons of the old transcript (exons2) this also includes the introns
    oldtlist = strsplit(oldtranscript, ",")[[1]]
    
    if(oldstartcodon != "None"){
      oldstartbeg <- strtoi(strsplit(oldstartcodon, ";")[[1]][2])
      oldstartend <- strtoi(strsplit(oldstartcodon, ";")[[1]][3])
      
      indexcorrection <- 0
      if (strand == "-"){
        
        if ((oldstartend - oldstartbeg) < 2){
          indexcorrection <- (2-(oldstartend - oldstartbeg))
        }
        
        oldstart = oldstartend
      } else {
        
        if ((oldstartend - oldstartbeg) < 2){
          indexcorrection <- (2-(oldstartend - oldstartbeg))
        }
        
        oldstart = oldstartbeg
        
      }
    } else{
      oldstart = "None"
      indexcorrection <- 0
    }
    if (length(oldtlist) == 2){
      exons2 = t(as.matrix(c(strtoi(oldtlist[1]),strtoi(oldtlist[2]))))
    } else {
      for (i in 1:length(oldtlist)) {
        if (!i %% 2){
          next
        } else {
          if (i==1){
            exons2 = c(strtoi(oldtlist[i]),strtoi(oldtlist[i + 1]))
          } else {
            exons2 = rbind(exons2, c(strtoi(oldtlist[i]),strtoi(oldtlist[i + 1])))
          }
        }
      }
    }
    
    
    # Find the last intron/exon junction for NMD analysis
    if (length(oldtlist) > 2){
      if (strand == "-"){
        exonsmd = exons2[order(-exons2[,1]),]
      } else {
        exonsmd = exons2[order(exons2[,1]),]
      }
    } else {
      exonsmd = exons2
    }
    
    # Find the junction that is last
    lastjunc = "None"
    if (dim(exonsmd)[1] > 1){
      lastjunc = as.integer(exonsmd[dim(exonsmd)[1] - 2,2])
    }
    
    # This generates the sequence
    numexons = dim(exons2)[1]
    if (dim(exonsmd)[1] > 1){
      exons2 <- exons2[order(exons2[,1]),]
    }
    locationexonsorig = c()
    sequenceexonsorig = ""
    for (i in 1:numexons){
      if (!i %% 2){
        next
      } else{
        locationexonsorig = append(locationexonsorig,seq.int(exons2[i,1], exons2[i,2]))
        #print(exons2)
        sequenceexonsorig = paste0(sequenceexonsorig, toString(getSeq(Hsapiens, chromosome, strtoi(exons2[i,1]), strtoi(exons2[i,2]))))
      }
    }
    
    if (strand == "-"){
      sequenceexonsorig = toString(reverseComplement(DNAString(sequenceexonsorig)))
      locationexonsorig = rev(locationexonsorig)
    }
    
    lastjuncloc = "None"
    if (dim(exonsmd)[1] > 1){
      lastjuncloc = match(lastjunc, locationexonsorig)
    }
    
    # Create a vector with frame informtion (1 being start of codon) to determine the frame of the new transcript
    indexoldstart = match(oldstart, locationexonsorig) - indexcorrection
    if (is.na(indexoldstart)){
      returnstrongstart = "None"
      returnmatchloc = "None"
      returnproteintrans = "None"
      returnfullproteintrans = "None"
      returnframe = "None"
      returnlabeltype = "None"
      returnnmddistance = "None"
      returnnmdcall = "None"
      returnproteinleft = "None"
      returnframecall = "None"
    } else {
      
      # Find the 'frame' of the transcript using the modulus of the index of the start within the vector.
      modoldstart = indexoldstart %% 3
      numcodon = ceiling(nchar(sequenceexonsorig)/3)
      if (modoldstart == 0){
        codonvec = rep(c(2,3,1), numcodon)
      } else if (modoldstart == 1){
        codonvec = rep(c(1,2,3), numcodon)
      } else if (modoldstart == 2){
        codonvec = rep(c(3,1,2), numcodon)
      }
      
      firstmatch = "None"
      frameinfo = "None"
      i = 0
      for (loc in locationexonsorig){
        i = i + 1
        if (is.na(match(loc, locationexons))){
          next
        } else {
          frameinfo = codonvec[i]
          firstmatch = match(loc, locationexons)
          origlocmatch = match(loc, locationexonsorig)
          break
        }
      }
      
      if (firstmatch != "None"){
        # Calculate the frame
        if (frameinfo == 1){
          inframe = firstmatch
          # the codons are the same in this case so there will not be a difference
          oldcodon = "None"
          newcodon = "None"
        } else if (frameinfo == 2){
          inframe = firstmatch + 2
          # in case it is in-frame chimeric, this will be used to determine if this codon is new
          oldcodon = substring(sequenceexonsorig, origlocmatch-1, origlocmatch+1)
          newcodon = substring(sequenceexons, firstmatch-1, firstmatch+1)
        } else if (frameinfo == 3) {
          inframe = firstmatch + 1
          # in case it is in-frame chimeric, this will be used to determine if this codon is new
          oldcodon = substring(sequenceexonsorig, origlocmatch-2, origlocmatch)
          newcodon = substring(sequenceexons, firstmatch-2, firstmatch)
        }
        
        modnewstart = inframe %% 3
        numcodon2 = ceiling(nchar(sequenceexons)/3)
        
        if (modnewstart == 0){
          codonvec2 = rep(c(2,3,1), numcodon2)
        } else if (modnewstart == 1){
          codonvec2 = rep(c(1,2,3), numcodon2)
        } else if (modnewstart == 2){
          codonvec2 = rep(c(3,1,2), numcodon2)
        }
        
        if (codonvec2[strongstart] == 1){
          framenew = "in-frame"
        } else {
          framenew = "out-of-frame"
        }
        
        # This is going to note for if the 
        
        aamatch = "no"
        
        # Figure out if the protein is the same, the same truncated, chimeric same, chimeric truncated.
        
        labeltype = "None"
        nmdcall = "None"
        
        
        disnew = firstmatch - startcodon
        disold = origlocmatch - indexoldstart
        
        chimericcheck = FALSE
        
        if (framenew == "in-frame"){
          if (disnew > 0){
            if (disold > 0){
              labeltype = "chimeric truncated"
              chimericcheck = TRUE
            } else {
              labeltype = "chimeric normal"
              chimericcheck = TRUE
            }
          }else {
            if (disold > 0){
              labeltype = "truncated"
            } else {
              # The original startcodon should be chosen if both were present in the original transcript
              framenew = "in-frame"
              strongstart2 = match(oldstart, locationexons) 
              if (is.na(strongstart2)){
                strongstart = "None"
                strongproteintrans = "None"
                fullproteintrans = "None"
              } else {
                strongstart = strongstart2
                strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                fullproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
              }
              labeltype = "normal"
            }
          }
        } else {
          if (disnew <= 0 & disold <= 0){
            locationstartmatch <- match(oldstart, locationexons)
            if (is.na(locationstartmatch)){
              labeltype = "out-of-frame"
            } else {
              diffstarts <- strongstart - locationstartmatch 
              if ((diffstarts %% 3) == 0){
                if (strongstart >= locationstartmatch){
                  strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                  labeltype = "normal"
                  framenew = "in-frame"
                } else {
                  strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                  labeltype = "chimeric normal"
                  framenew = "in-frame"
                  chimericcheck = TRUE
                }
              } else {
                labeltype = "out-of-frame"
              }
            }
          } else {
            labeltype = "out-of-frame"
          }
        }
        
        aaCorrection = 0
        if (strongstart != "None"){
          # Truncating protein sequences for the chimeric ones. Adding 1
          numexons2 = ceiling((inframe + 30 - strongstart)/3)
          
          # In the case that the TE- transcript includes exon 1 and it starts before the previous start codon, the following adjustment needs to be made
          if (labeltype == "chimeric normal"){
            numexons2 = ceiling((firstmatch - disold + 30 - strongstart)/3)
            oldcodon = "None"
          }
          if (framenew == "in-frame" && chimericcheck){
            if (oldcodon != "None"){
              aaold = toString(translate(DNAString(oldcodon)))
              aanew = toString(translate(DNAString(newcodon)))
              if (aaold == aanew){
                strongproteintrans = substring(strongproteintrans,1,(numexons2-1))
                aaCorrection = -3
              } else {
                strongproteintrans = substring(strongproteintrans,1,(numexons2))
              }
            } else{
              strongproteintrans = substring(strongproteintrans,1,(numexons2-1))
            }
            endloc = gregexpr(pattern ='\\*',strongproteintrans)[[1]][1]
            # This isn't perfect if it is only chimeric with 9-10 aa of the original but that would be unusual
            if (endloc != -1 && (nchar(strongproteintrans)-endloc > 9)){
              labeltype = "novel non-chimeric"
            }
          }
        }
        
        endloc = gregexpr(pattern ='\\*',strongproteintrans)[[1]][1]
        if (endloc != -1){
          strongproteintrans2 = substring(strongproteintrans, 1, endloc - 1)
          strongproteintrans = strongproteintrans2
        }
        # See if this peptide will likely go through nonsense mediated decay
        nmdthresh = 55
        distancelastjun = "None"
        if (dim(exons2)[1] > 1){
          if (strongendlocfactor == -3){
            nmdcall = "Inconclusive"
          } else {
            #print(c(lastjuncloc, origlocmatch, disnew, strongendlocfactor))
            distancelastjun = lastjuncloc - origlocmatch + disnew - strongendlocfactor
            if (distancelastjun > nmdthresh){
              nmdcall = "Yes"
            } else {
              nmdcall = "No"
            }
          }
        } else {
          nmdcall = "No"
        }
        
        framecorrection <- codonvec[origlocmatch]
        if(framecorrection == 1){
          correctionFactor = 0
        } else if(framecorrection == 2){
          correctionFactor = 2
        } else if(framecorrection == 3){
          correctionFactor = 1
        }
        
        origProteinTranslate <- toString(translate(DNAString(substring(sequenceexonsorig,origlocmatch + correctionFactor + aaCorrection ,nchar(sequenceexonsorig)))))
        
        returnstrongstart = strongstart
        returnmatchloc = firstmatch
        returnproteintrans = strongproteintrans
        returnfullproteintrans = fullproteintrans
        returnframe = framenew
        returnlabeltype = labeltype
        returnnmddistance = distancelastjun
        returnnmdcall = nmdcall
        returnproteinleft = nchar(strsplit(origProteinTranslate, '\\*')[[1]][1])
        returnframecall = codonvec[1]
      } else{
        returnstrongstart = strongstart
        returnmatchloc = firstmatch
        returnproteintrans = strongproteintrans
        returnfullproteintrans = fullproteintrans
        returnframe = "None"
        returnlabeltype = "None"
        returnnmddistance = "None"
        returnnmdcall = "None"
        returnproteinleft = "None"
        returnframecall = "None"
      }
    }
  } else {
    returnstrongstart = "None"
    returnmatchloc = "None"
    returnproteintrans = "None"
    returnfullproteintrans = "None"
    returnframe = "None"
    returnlabeltype = "None"
    returnnmddistance = "None"
    returnnmdcall = "None"
    returnproteinleft = "None"
    returnframecall = "None"
  }
  
  return(c(returnstrongstart, returnmatchloc, returnproteintrans, returnfullproteintrans, returnframe, returnlabeltype, returnnmddistance, returnnmdcall, returnproteinleft, returnframecall))
}

# Do analysis on if the sequence is in frame or out of frame relative to the main transcript
clus <- makeCluster(1)

clusterEvalQ(clus, .libPaths( "/bar/nshah/R/x86_64-pc-linux-gnu-library/3.5"))
clusterExport(clus, "calORF")
results <- parApply(clus,annotatedcufftranscripts.fil[,c('transcoord','elements2','startcodon2')], 1, function(x) calORF(x[1], x[2], x[3]))
stopCluster(clus)
results = data.frame(t(results))
columnnames <- colnames(annotatedcufftranscripts.fil)
annotatedcufftranscripts.fil = cbind.data.frame(annotatedcufftranscripts.fil, results)
columnlabels <- append(columnnames, c("strongstartindex", "matchbetweenindex", "proteinseq", "proteinseqfull", "frame", "type", "nmddistance", "nmdcall", "origprotleft","frameNum"))
colnames(annotatedcufftranscripts.fil) <- columnlabels

annotatedcufftranscripts.fil$proteinseqfull2 <- apply(annotatedcufftranscripts.fil[,c('proteinseqfull','uniqid')],1, function(x) strsplit(x[1],"\\*")[[1]][1])
```
```{r}
getSequenceFromCoords <- function(newtranscript){
  
  library('BSgenome.Hsapiens.UCSC.hg38')
  
  newtlist = strsplit(newtranscript, ",")[[1]]
  strand = newtlist[1]
  chromosome = newtlist[2]
  for (i in 3:length(newtlist)) {
    if (!i %% 2){
      next
    } else{
      if (strand == "+"){
        if (i==3){
          exons = c(strtoi(newtlist[i]),strtoi(newtlist[i + 1]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i]),strtoi(newtlist[i + 1])))
        }
      }else {
        if (i==3){
          exons = c(strtoi(newtlist[i+1]),strtoi(newtlist[i]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i+1]),strtoi(newtlist[i])))
        }
      }
    }
  }
  if (is.null(dim(exons))){
    exons = t(as.matrix(exons))
  }
  numexons = dim(exons)[1]
  if (numexons > 1){
    exons <- exons[order(exons[,1]),]
  }
  locationexons = c()
  sequenceexons = ""
  for (i in 1:numexons){
    locationexons = append(locationexons,seq.int(exons[i,1], exons[i,2]))
    sequenceexons = paste0(sequenceexons, toString(getSeq(Hsapiens, chromosome, exons[i,1], exons[i,2])))
  }
  
  if (strand == "-"){
    sequenceexons = toString(reverseComplement(DNAString(sequenceexons)))
    locationexons = rev(locationexons)
  }
  return(sequenceexons)
}

clus <- makeCluster(8)

clusterEvalQ(clus, .libPaths( "/bar/nshah/R/x86_64-pc-linux-gnu-library/3.5"))
clusterExport(clus, "getSequenceFromCoords")
annotatedcufftranscripts.fil$rnasequence <- parApply(clus, annotatedcufftranscripts.fil[,c('uniqid','transcoord')], 1, function(x) getSequenceFromCoords(x[2]))
stopCluster(clus)
```

```{r}
fastaoutputvector <- c()

for (i in 1:nrow(annotatedcufftranscripts.fil)){
  fastaoutputvector <- c(fastaoutputvector, paste0(">",annotatedcufftranscripts.fil$uniqid[i]))
  fastaoutputvector <- c(fastaoutputvector,annotatedcufftranscripts.fil$rnasequence[i])
}

fileConn<-file("candidates.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash eval=F, echo=T}
CPC2.py -i candidates.fa -o candidates_cpcout.fa
```

```{r}
codingpotential_results <- read.delim('candidates_cpcout.fa', sep = "\t", stringsAsFactors = FALSE, header = TRUE)

coding_label <- c()
start_location <- c()
for (candidateid in annotatedcufftranscripts.fil$uniqid){
  coding_label <- c(coding_label, codingpotential_results[codingpotential_results$X.ID == candidateid, c('label')])
  start_location <- c(start_location, codingpotential_results[codingpotential_results$X.ID == candidateid, c('start_codon_position')])
}
annotatedcufftranscripts.fil$coding_label <- coding_label
annotatedcufftranscripts.fil$start_location <- start_location
```

```{r}
calORFCPC2 <- function(newtranscript, oldtranscript, oldstartcodon, strongstart, codingpotential){
  
  library('BSgenome.Hsapiens.UCSC.hg38')
  strongstart <- as.numeric(strongstart) + 1
  newtlist = strsplit(newtranscript, ",")[[1]]
  strand = newtlist[1]
  chromosome = newtlist[2]
  for (i in 3:length(newtlist)) {
    if (!i %% 2){
      next
    } else{
      if (strand == "+"){
        if (i==3){
          exons = c(strtoi(newtlist[i]),strtoi(newtlist[i + 1]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i]),strtoi(newtlist[i + 1])))
        }
      }else {
        if (i==3){
          exons = c(strtoi(newtlist[i+1]),strtoi(newtlist[i]))
        } else {
          exons = rbind(exons, c(strtoi(newtlist[i+1]),strtoi(newtlist[i])))
        }
      }
    }
  }
  if (is.null(dim(exons))){
    exons = t(as.matrix(exons))
  }
  numexons = dim(exons)[1]
  if (numexons > 1){
    exons <- exons[order(exons[,1]),]
  }
  locationexons = c()
  sequenceexons = ""
  for (i in 1:numexons){
    locationexons = append(locationexons,seq.int(exons[i,1], exons[i,2]))
    sequenceexons = paste0(sequenceexons, toString(getSeq(Hsapiens, chromosome, exons[i,1], exons[i,2])))
  }
  
  if (strand == "-"){
    sequenceexons = toString(reverseComplement(DNAString(sequenceexons)))
    locationexons = rev(locationexons)
  }
  strongproteintrans = "None"
  strongstartloc = "None"
  strongendloc = "None"
  
  # Find the start codon
  
  if (codingpotential == "coding") {
    proteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
    endloc = gregexpr(pattern ='\\*',proteintrans)[[1]][1]
    strongproteintrans = proteintrans
    fullproteintrans = proteintrans
    strongendlocfactor = endloc*3
    strongstartloc = locationexons[strongstart]
  } else {
    strongstart = "None"
  }
          
  
  if (strongstart != "None"){
    
    # This will generate a tuple list of all the dimensions of the exons of the old transcript (exons2) this also includes the introns
    oldtlist = strsplit(oldtranscript, ",")[[1]]
    if(oldstartcodon != "None"){
      oldstartbeg <- strtoi(strsplit(oldstartcodon, ";")[[1]][2])
      oldstartend <- strtoi(strsplit(oldstartcodon, ";")[[1]][3])
      
      indexcorrection <- 0
      if (strand == "-"){
        
        if ((oldstartend - oldstartbeg) < 2){
          indexcorrection <- (2-(oldstartend - oldstartbeg))
        }
        
        oldstart = oldstartend
      } else {
        
        if ((oldstartend - oldstartbeg) < 2){
          indexcorrection <- (2-(oldstartend - oldstartbeg))
        }
        
        oldstart = oldstartbeg
        
      }
    } else{
      oldstart = "None"
      indexcorrection <- 0
    }
    if (length(oldtlist) == 2){
      exons2 = t(as.matrix(c(strtoi(oldtlist[1]),strtoi(oldtlist[2]))))
    } else {
      for (i in 1:length(oldtlist)) {
        if (!i %% 2){
          next
        } else {
          if (i==1){
            exons2 = c(strtoi(oldtlist[i]),strtoi(oldtlist[i + 1]))
          } else {
            exons2 = rbind(exons2, c(strtoi(oldtlist[i]),strtoi(oldtlist[i + 1])))
          }
        }
      }
    }
    
    
    # Find the last intron/exon junction for NMD analysis
    if (length(oldtlist) > 2){
      if (strand == "-"){
        exonsmd = exons2[order(-exons2[,1]),]
      } else {
        exonsmd = exons2[order(exons2[,1]),]
      }
    } else {
      exonsmd = exons2
    }
    
    # Find the junction that is last
    lastjunc = "None"
    if (dim(exonsmd)[1] > 1){
      lastjunc = as.integer(exonsmd[dim(exonsmd)[1] - 2,2])
    }
    
    # This generates the sequence
    numexons = dim(exons2)[1]
    if (dim(exonsmd)[1] > 1){
      exons2 <- exons2[order(exons2[,1]),]
    }
    locationexonsorig = c()
    sequenceexonsorig = ""
    for (i in 1:numexons){
      if (!i %% 2){
        next
      } else{
        locationexonsorig = append(locationexonsorig,seq.int(exons2[i,1], exons2[i,2]))
        #print(exons2)
        sequenceexonsorig = paste0(sequenceexonsorig, toString(getSeq(Hsapiens, chromosome, strtoi(exons2[i,1]), strtoi(exons2[i,2]))))
      }
    }
    
    if (strand == "-"){
      sequenceexonsorig = toString(reverseComplement(DNAString(sequenceexonsorig)))
      locationexonsorig = rev(locationexonsorig)
    }
    
    lastjuncloc = "None"
    if (dim(exonsmd)[1] > 1){
      lastjuncloc = match(lastjunc, locationexonsorig)
    }
    
    # Create a vector with frame informtion (1 being start of codon) to determine the frame of the new transcript
    
    indexoldstart = match(oldstart, locationexonsorig) - indexcorrection
    if (is.na(indexoldstart)){
      returnstrongstart = "None"
      returnmatchloc = "None"
      returnproteintrans = "None"
      returnfullproteintrans = "None"
      returnframe = "None"
      returnlabeltype = "None"
      returnnmddistance = "None"
      returnnmdcall = "None"
      returnproteinleft = "None"
      returnframecall = "None"
    } else {
      
      # Find the 'frame' of the transcript using the modulus of the index of the start within the vector.
      modoldstart = indexoldstart %% 3
      numcodon = ceiling(nchar(sequenceexonsorig)/3)
      if (modoldstart == 0){
        codonvec = rep(c(2,3,1), numcodon)
      } else if (modoldstart == 1){
        codonvec = rep(c(1,2,3), numcodon)
      } else if (modoldstart == 2){
        codonvec = rep(c(3,1,2), numcodon)
      }
      
      firstmatch = "None"
      frameinfo = "None"
      i = 0
      for (loc in locationexonsorig){
        i = i + 1
        if (is.na(match(loc, locationexons))){
          next
        } else {
          frameinfo = codonvec[i]
          firstmatch = match(loc, locationexons)
          origlocmatch = match(loc, locationexonsorig)
          break
        }
      }
      
      if (firstmatch != "None"){
        # Calculate the frame
        if (frameinfo == 1){
          inframe = firstmatch
          # the codons are the same in this case so there will not be a difference
          oldcodon = "None"
          newcodon = "None"
        } else if (frameinfo == 2){
          inframe = firstmatch + 2
          # in case it is in-frame chimeric, this will be used to determine if this codon is new
          oldcodon = substring(sequenceexonsorig, origlocmatch-1, origlocmatch+1)
          newcodon = substring(sequenceexons, firstmatch-1, firstmatch+1)
        } else if (frameinfo == 3) {
          inframe = firstmatch + 1
          # in case it is in-frame chimeric, this will be used to determine if this codon is new
          oldcodon = substring(sequenceexonsorig, origlocmatch-2, origlocmatch)
          newcodon = substring(sequenceexons, firstmatch-2, firstmatch)
        }
        
        modnewstart = inframe %% 3
        numcodon2 = ceiling(nchar(sequenceexons)/3)
        
        if (modnewstart == 0){
          codonvec2 = rep(c(2,3,1), numcodon2)
        } else if (modnewstart == 1){
          codonvec2 = rep(c(1,2,3), numcodon2)
        } else if (modnewstart == 2){
          codonvec2 = rep(c(3,1,2), numcodon2)
        }
        
        if (codonvec2[strongstart] == 1){
          framenew = "in-frame"
        } else {
          framenew = "out-of-frame"
        }
        
        
        # Figure out if the protein is the same, the same truncated, chimeric same, chimeric truncated.
        
        labeltype = "None"
        nmdcall = "None"
        
        
        disnew = firstmatch - strongstart
        disold = origlocmatch - indexoldstart
        
        chimericcheck = FALSE
        
        if (framenew == "in-frame"){
          if (disnew > 0){
            if (disold > 0){
              labeltype = "chimeric truncated"
              chimericcheck = TRUE
            } else {
              labeltype = "chimeric normal"
              chimericcheck = TRUE
            }
          }else {
            if (disold > 0){
              labeltype = "truncated"
            } else {
              # The original startcodon should be chosen if both were present in the original transcript
              framenew = "in-frame"
              strongstart2 = match(oldstart, locationexons) 
              if (is.na(strongstart2)){
                strongstart = "None"
                strongproteintrans = "None"
                fullproteintrans = "None"
              } else {
                strongstart = strongstart2
                strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                fullproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
              }
              labeltype = "normal"
            }
          }
        } else {
          if (disnew <= 0 & disold <= 0){
            locationstartmatch <- match(oldstart, locationexons)
            if (is.na(locationstartmatch)){
              labeltype = "out-of-frame"
            } else {
              diffstarts <- strongstart - locationstartmatch 
              if ((diffstarts %% 3) == 0){
                if (strongstart >= locationstartmatch){
                  strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                  labeltype = "normal"
                  framenew = "in-frame"
                } else {
                  strongproteintrans = toString(translate(DNAString(substring(sequenceexons,strongstart,nchar(sequenceexons)))))
                  labeltype = "chimeric normal"
                  chimericcheck = TRUE
                  framenew = "in-frame"
                }
              } else {
                labeltype = "out-of-frame"
              }
            }
          } else {
            labeltype = "out-of-frame"
          }
        }
        
        
        aaCorrection = 0
        if (strongstart != "None"){
          # Truncating protein sequences for the chimeric ones. Adding 1
          numexons2 = ceiling((inframe + 30 - strongstart)/3)
          
          # In the case that the TE- transcript includes exon 1 and it starts before the previous start codon, the following adjustment needs to be made
          if (labeltype == "chimeric normal"){
            numexons2 = ceiling((firstmatch - disold + 30 - strongstart)/3)
            oldcodon = "None"
          }
          if (framenew == "in-frame" && chimericcheck){
            if (oldcodon != "None"){
              aaold = toString(translate(DNAString(oldcodon)))
              aanew = toString(translate(DNAString(newcodon)))
              if (aaold == aanew){
                strongproteintrans = substring(strongproteintrans,1,(numexons2-1))
                aaCorrection = -3
              } else {
                strongproteintrans = substring(strongproteintrans,1,(numexons2))
              }
            } else{
              strongproteintrans = substring(strongproteintrans,1,(numexons2-1))
            }
            endloc = gregexpr(pattern ='\\*',strongproteintrans)[[1]][1]
            # This isn't perfect if it is only chimeric with like 9-10 aa of the original but that would be unusual
            if (endloc != -1 && (nchar(strongproteintrans)-endloc > 9)){
              labeltype = "novel non-chimeric"
            }
          }
        }
        
        endloc = gregexpr(pattern ='\\*',strongproteintrans)[[1]][1]
        if (endloc != -1){
          strongproteintrans2 = substring(strongproteintrans, 1, endloc - 1)
          strongproteintrans = strongproteintrans2
        }
        # See if this peptide will likely go through nonsense mediated decay
        nmdthresh = 55
        distancelastjun = "None"
        if (dim(exons2)[1] > 1){
          if (strongendlocfactor == -3){
            nmdcall = "Inconclusive"
          } else {
            #print(c(lastjuncloc, origlocmatch, disnew, strongendlocfactor))
            distancelastjun = lastjuncloc - origlocmatch + disnew - strongendlocfactor
            if (distancelastjun > nmdthresh){
              nmdcall = "Yes"
            } else {
              nmdcall = "No"
            }
          }
        } else {
          nmdcall = "No"
        }
        
        framecorrection <- codonvec[origlocmatch]
        if(framecorrection == 1){
          correctionFactor = 0
        } else if(framecorrection == 2){
          correctionFactor = 2
        } else if(framecorrection == 3){
          correctionFactor = 1
        }
        
        origProteinTranslate <- toString(translate(DNAString(substring(sequenceexonsorig,origlocmatch + correctionFactor + aaCorrection ,nchar(sequenceexonsorig)))))
        
        returnstrongstart = strongstart
        returnmatchloc = firstmatch
        returnproteintrans = strongproteintrans
        returnfullproteintrans = fullproteintrans
        returnframe = framenew
        returnlabeltype = labeltype
        returnnmddistance = distancelastjun
        returnnmdcall = nmdcall
        returnproteinleft = nchar(strsplit(origProteinTranslate, '\\*')[[1]][1])
        returnframecall = codonvec[1]
      } else{
        returnstrongstart = strongstart
        returnmatchloc = firstmatch
        returnproteintrans = strongproteintrans
        returnfullproteintrans = fullproteintrans
        returnframe = "None"
        returnlabeltype = "None"
        returnnmddistance = "None"
        returnnmdcall = "None"
        returnproteinleft = "None"
        returnframecall = "None"
      }
    }
  } else {
    returnstrongstart = "None"
    returnmatchloc = "None"
    returnproteintrans = "None"
    returnfullproteintrans = "None"
    returnframe = "None"
    returnlabeltype = "None"
    returnnmddistance = "None"
    returnnmdcall = "None"
    returnproteinleft = "None"
    returnframecall = "None"
  }
  
  return(c(returnstrongstart, returnmatchloc, returnproteintrans, returnfullproteintrans, returnframe, returnlabeltype, returnnmddistance, returnnmdcall, returnproteinleft, returnframecall))
}

# Do analysis on if the sequence is in frame or out of frame relative to the main transcript

clus <- makeCluster(8)

clusterEvalQ(clus, .libPaths( "/bar/nshah/R/x86_64-pc-linux-gnu-library/3.5"))
clusterExport(clus, "calORFCPC2")
results <- parApply(clus,annotatedcufftranscripts.fil[,c('transcoord','elements2','startcodon2', 'start_location','coding_label')], 1, function(x) calORFCPC2(x[1], x[2], x[3], x[4], x[5]))
stopCluster(clus)
results = data.frame(t(results))
columnnames <- colnames(annotatedcufftranscripts.fil)
annotatedcufftranscripts.fil = cbind.data.frame(annotatedcufftranscripts.fil, results)
columnlabels <- append(columnnames, c("cpc2_strongstartindex", "cpc2_matchbetweenindex", "cpc2_proteinseq", "cpc2_proteinseqfull", "cpc2_frame", "cpc2_type", "cpc2_nmddistance", "cpc2_nmdcall", "cpc2_origprotleft", "cpc2_frameNum"))
colnames(annotatedcufftranscripts.fil) <- columnlabels

annotatedcufftranscripts.fil$cpc2_proteinseqfull2 <- apply(annotatedcufftranscripts.fil[,c('cpc2_proteinseqfull','uniqid')],1, function(x) strsplit(x[1],"\\*")[[1]][1])
```


```{r}
newLabelsKozak <- apply(testTable[,c("type", "proteinseqfull2")],1, function(x){
  if (x[1] == "chimeric normal" | x[1] == "chimeric truncated" | x[1] == "truncated" | x[1] == "normal" | x[1] == "None"){
    if (x[2] == "None"){
      return("None")
    } else {
      return(x[1])
    }
  } else if(x[1] == "novel non-chimeric" | x[1] == "out-of-frame"){
    return("out-of-frame")
  }
})

newLabelsCPC2 <- apply(testTable[,c("cpc2_type", "cpc2_proteinseqfull2")],1, function(x){
  if (x[1] == "chimeric normal" | x[1] == "chimeric truncated" | x[1] == "truncated" | x[1] == "normal" | x[1] == "None"){
    if (x[2] == "None"){
      return("None")
    } else {
      return(x[1])
    }
  } else if(x[1] == "novel non-chimeric" | x[1] == "out-of-frame"){
    return("out-of-frame")
  }
})

testTable$type_final_new <- newLabelsKozak 
testTable$cpc2_type_final_new <- newLabelsCPC2 
```




```{r}
library(biomaRt)


datasets <- listDatasets(useMart("ensembl"))
head(datasets,100)
```

```{r}
#I specified this version of ensemble. Make sure gencode and ensembl match or all the results will be messed up with improper references

mart.hs <- useMart(host='http://jul2016.archive.ensembl.org','ENSEMBL_MART_ENSEMBL','hsapiens_gene_ensembl')
```


```{r}
attributes <- listAttributes(mart.hs)

head(attributes,100)

filters <- listFilters(mart.hs)
```

```{r}
transcriptsearch <- as.character(annotatedcufftranscripts.fil$id2)
transcriptsearch2 <- unlist(lapply(transcriptsearch, function(x) strsplit(x,'[.]')[[1]][1]))
```

```{r}
proteinSequence <- getSequence(id = transcriptsearch2, 
            type="ensembl_transcript_id",
            seqType="peptide",
            mart=mart.hs) 
```

```{r}
annotatedcufftranscripts.fil$transcriptmapEns <- unlist(lapply(as.character(annotatedcufftranscripts.fil$id2), function(x) strsplit(x,'[.]')[[1]][1]))

indexMatch <- match(annotatedcufftranscripts.fil$transcriptmapEns, proteinSequence$ensembl_transcript_id)

annotatedcufftranscripts.fil$orig_proteinsequence <- proteinSequence$peptide[indexMatch]
```

```{r}
library(Biostrings)

annotatedcufftranscripts.fil$kozak_alignment <- apply(annotatedcufftranscripts.fil[,c("proteinseqfull2","orig_proteinsequence")], 1, function(x){
  if (x[1] == "None"){
    return("None")
  } else {
    return(as.character(aligned(pairwiseAlignment(pattern = c(x[1]), subject = x[2],type = "local"))))
  }
})

annotatedcufftranscripts.fil$cpc2_alignment <-   apply(annotatedcufftranscripts.fil[,c("cpc2_proteinseqfull2","orig_proteinsequence")], 1, function(x){
  if (x[1] == "None"){
    return("None")
  } else {
    return(as.character(aligned(pairwiseAlignment(pattern = c(x[1]), subject = x[2],type = "local"))))
  }
})
```

```{r}
annotatedcufftranscripts.fil$kozak_alignment_length <- apply(annotatedcufftranscripts.fil[,c("kozak_alignment","orig_proteinsequence")], 1, function(x){
  if (x[1] == "None"){
    return("None")
  } else {
    return(nchar(gsub('-','',x[1])))
  }
})

annotatedcufftranscripts.fil$cpc2_alignment_length <- apply(annotatedcufftranscripts.fil[,c("cpc2_alignment","orig_proteinsequence")], 1, function(x){
  if (x[1] == "None"){
    return("None")
  } else {
    return(nchar(gsub('-','',x[1])))
  }
})

```





###Pie Charts to Characterize Candiddates

```{r}
tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$cpc2_type))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="CPC2 Type Call")

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$type))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Kozak Type Call")

```

```{r}
annotatedcufftranscripts.fil.c <- annotatedcufftranscripts.fil
annotatedcufftranscripts.fil.c <- annotatedcufftranscripts.fil.c[!is.na(annotatedcufftranscripts.fil.c$gene2),]

fileConn<-file("localizationgenes.txt")
writeLines(unique(as.character(annotatedcufftranscripts.fil.c$gene2)), fileConn)
close(fileConn)
```

The file above was used as a search from genename to uniprot and then a table with the associated GO term was downloaded. https://www.uniprot.org/uploadlists/

```{r}
uniprotquery <-  read.delim("uniprot-result.tab", header = TRUE, sep = "\t")
```

```{r}
uniprotquery$refgene <- apply(uniprotquery[,c("Gene.names", "Gene.ontology..cellular.component.")], 1, 
                              function(x){
                                vecNames <- strsplit(x[1],' ')[[1]]
                                if(length(vecNames) == 1){
                                  return(vecNames[1])
                                } else {
                                  return(vecNames[vecNames %in% annotatedcufftranscripts.fil.c$gene2][1])
                                }
                              } ) 

indexMatch <- match(annotatedcufftranscripts.fil.c$gene2, uniprotquery$refgene)
annotatedcufftranscripts.fil.c$go <- uniprotquery$Gene.ontology..cellular.component.[indexMatch]
```




```{r}
annotatedcufftranscripts.fil.c$samecall <- apply(annotatedcufftranscripts.fil.c[,c("type", "cpc2_type")], 
                                                 1,
                                                 function(x){
                                                   if (x[1] == x[2]){
                                                     return("Yes")
                                                   } else {
                                                     return("No")
                                                   }
                                                 })

allowedtypes <- c("chimeric normal","chimeric truncated","out-of-frame","novel non-chimeric")

fastaoutputvector <- c()

for (i in 1:nrow(annotatedcufftranscripts.fil.c)){
  if (annotatedcufftranscripts.fil.c$samecall[i] == "Yes" & annotatedcufftranscripts.fil.c$type[i] %in% allowedtypes){
     fastaoutputvector <- c(fastaoutputvector, paste0(">tr|",annotatedcufftranscripts.fil.c$uniqid[i],"_both|",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_both ",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_both OS=Homo sapiens OX=9606 GN=",annotatedcufftranscripts.fil.c$gene2[i]))
        fastaoutputvector <- c(fastaoutputvector,annotatedcufftranscripts.fil.c$cpc2_proteinseqfull2[i])
  } else {
      if (annotatedcufftranscripts.fil.c$type[i] %in% allowedtypes){
        fastaoutputvector <- c(fastaoutputvector, paste0(">tr|",annotatedcufftranscripts.fil.c$uniqid[i],"_og|",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_og ",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_og OS=Homo sapiens OX=9606 GN=",annotatedcufftranscripts.fil.c$gene2[i]))
        fastaoutputvector <- c(fastaoutputvector,annotatedcufftranscripts.fil.c$proteinseqfull2[i])
      }
    
      if (annotatedcufftranscripts.fil.c$cpc2_type[i] %in% allowedtypes){
        fastaoutputvector <- c(fastaoutputvector, paste0(">tr|",annotatedcufftranscripts.fil.c$uniqid[i],"_cpc2|",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_cpc2 ",annotatedcufftranscripts.fil.c$uniqid[i],"_HUMAN_cpc2 OS=Homo sapiens OX=9606 GN=",annotatedcufftranscripts.fil.c$gene2[i]))
        fastaoutputvector <- c(fastaoutputvector,annotatedcufftranscripts.fil.c$cpc2_proteinseqfull2[i])
      }
  }
}

fileConn<-file("candidates_proteinseq_unfiltered.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{r}
annotatedcufftranscripts.fil.c$sameprotein <- apply(annotatedcufftranscripts.fil.c[,c('proteinseqfull2','cpc2_proteinseqfull2')],1,function(x) if(x[1]==x[2]){return("Yes")}else{return("No")})
```


## Protein Domain Characterization of Candidates

The current methods on calling novel-nonchimeric and out of frame genes needs to be adjusted. I want to have a final column as well as a corrected antigenic and membrane bound column based on this analysis. 

```{r}
library(biomaRt)


datasets <- listDatasets(useMart("ensembl"))
head(datasets,100)
```

```{r}
#I specified this version of ensemble. Make sure gencode and ensembl match or all the results will be messed up with improper references

mart.hs <- useMart(host='http://jul2016.archive.ensembl.org','ENSEMBL_MART_ENSEMBL','hsapiens_gene_ensembl')
```


```{r}
attributes <- listAttributes(mart.hs)

head(attributes,100)

filters <- listFilters(mart.hs)
```

```{r}
transcriptsearch <- as.character(annotatedcufftranscripts.fil.c$id2)
transcriptsearch2 <- unlist(lapply(transcriptsearch, function(x) strsplit(x,'[.]')[[1]][1]))
```

```{r}
proteinSequence <- getSequence(id = transcriptsearch2, 
            type="ensembl_transcript_id",
            seqType="peptide",
            mart=mart.hs) 
```

```{r}
annotatedcufftranscripts.fil.c$transcriptmapEns <- unlist(lapply(as.character(annotatedcufftranscripts.fil.c$id2), function(x) strsplit(x,'[.]')[[1]][1]))

indexMatch <- match(annotatedcufftranscripts.fil.c$transcriptmapEns, proteinSequence$ensembl_transcript_id)

annotatedcufftranscripts.fil.c$orig_proteinsequence <- proteinSequence$peptide[indexMatch]
```

### Getting protein domain and Transmembrane DOmain information Incorporated

```{r}

pfamDomains = getBM(attributes=c("ensembl_transcript_id","pfam","pfam_start","pfam_end"), 
             filters="ensembl_transcript_id",
             values=transcriptsearch2, 
             mart=mart.hs)

tmDomains = getBM(attributes=c("ensembl_transcript_id","transmembrane_domain","transmembrane_domain_start","transmembrane_domain_end"), 
             filters="ensembl_transcript_id",
             values=transcriptsearch2, 
             mart=mart.hs)
```
### Disruption by truncating isoforms

```{r}
annotatedcufftranscripts.fil.c.truncating <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$cpc2_type_final == "truncated" | annotatedcufftranscripts.fil.c$cpc2_type_final == "chimeric truncated" | annotatedcufftranscripts.fil.c$type_final == "truncated" | annotatedcufftranscripts.fil.c$type_final == "chimeric truncated",]


annotatedcufftranscripts.fil.c.truncating$pfamdisrupt <- apply(annotatedcufftranscripts.fil.c.truncating[,c("transcriptmapEns","type_final", "origprotleft", "cpc2_type_final", "cpc2_origprotleft", "orig_proteinsequence")], 1, function(x){
  pfamDomains.now <- pfamDomains[pfamDomains$ensembl_transcript_id == x[1],]
  if(sum(is.na(pfamDomains.now$pfam_start)) > 0){
    return("No")
  } else {
    #test kozak first
    locationchimeric <- nchar(x[6]) - as.numeric(x[3])
    if (grepl("truncated", x[2]) & sum(pfamDomains.now$pfam_start < locationchimeric) > 0){
      return("Yes")
    } else {
      locationchimeric <- nchar(x[6]) - as.numeric(x[5])
      if (grepl("truncated", x[4]) & sum(pfamDomains.now$pfam_start < locationchimeric) > 0){
        return("Yes")
      } else {
        return("No")
      }
    }
  }
})

annotatedcufftranscripts.fil.c.truncating$tmdisrupt <- apply(annotatedcufftranscripts.fil.c.truncating[,c("transcriptmapEns","type_final", "origprotleft", "cpc2_type_final", "cpc2_origprotleft", "orig_proteinsequence")], 1, function(x){
  tmDomains.now <- tmDomains[tmDomains$ensembl_transcript_id == x[1],]
  if(sum(is.na(tmDomains.now$transmembrane_domain_start)) > 0){
    return("No")
  } else {
    #test kozak first
    locationchimeric <- nchar(x[6]) - as.numeric(x[3])
    if (grepl("truncated", x[2]) & sum(tmDomains.now$transmembrane_domain_start < locationchimeric) > 0){
      return("Yes")
    } else {
      locationchimeric <- nchar(x[6]) - as.numeric(x[5])
      if (grepl("truncated", x[4]) & sum(tmDomains.now$transmembrane_domain_start < locationchimeric) > 0){
        return("Yes")
      } else {
        return("No")
      }
    }
  }
})

```


### Pfam Correction

```{r}
# Download wget ftp://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/pdbmap.gz
# cat pdbmap | awk '{print $3"\t"$4}' | sort | uniq | sed 's/;//g' > pfamMapping.txt

pfamMapping <- read.delim("~/reference/pfamMapping.txt", sep = "\t", header = FALSE)

colnames(pfamMapping) <- c("Description", "pfamID")

indexMatch <- match(pfamDomains$pfam, pfamMapping$pfamID)

pfamDomains$Description <- pfamMapping$Description[indexMatch]
```


###Candidate Protein Graphing

```{r}
library(RColorBrewer)
#Plain without any domains highlighted

currentFocusTable <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$type_final %in% c("chimeric normal", "chimeric truncated", "truncated"),]

for(j in 1:nrow(currentFocusTable)){

  currentRow <- currentFocusTable[j,]
  
  
  newProteinSequence <- currentRow$proteinseqfull2
  origProteinLeft <- as.numeric(as.character(currentRow$origprotleft))
  origProteinSequence <- currentRow$orig_proteinsequence
  proteinLength <- nchar(origProteinSequence)
  newProteinStart <- proteinLength - origProteinLeft
  
  
  xminVec <- c(0,newProteinStart)
  xmaxVec <- c(proteinLength, proteinLength)
  yminVec <- c(1,-1)
  ymaxVec <- c(2,0)
  colorVec <- c("background", "background")
  
  if (grepl("chimeric",currentRow$type_final)){
    xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
    xmaxVec <- c(xmaxVec, newProteinStart)
    yminVec <- c(yminVec, -1)
    ymaxVec <- c(ymaxVec, 0)
    colorVec <- c(colorVec, "novel AA")
  }
  
  df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  
  gg_splice <- ggplot() + 
    geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
    scale_y_continuous(limits=c(-2,3))+
    scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
    geom_vline(xintercept = 0, alpha = .1)+
    scale_fill_manual(values = c("lightblue", "mediumpurple1"))+
    theme_classic()
  
  ggsave(paste0("./structurePlots/",currentRow$uniqid,"_kozak_","plain.pdf"), gg_splice, width = 12, height = 6, device = cairo_pdf)
  
  #Pfam with domains highlighted to show what is happening ot the proteins
  
  xminVec <- c(0,newProteinStart)
  xmaxVec <- c(proteinLength, proteinLength)
  yminVec <- c(1,-1)
  ymaxVec <- c(2,0)
  colorVec <- c("Background", "Background")
  
  if (grepl("chimeric",currentRow$type_final)){
    xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
    xmaxVec <- c(xmaxVec, newProteinStart)
    yminVec <- c(yminVec, -1)
    ymaxVec <- c(ymaxVec, 0)
    colorVec <- c(colorVec, "Novel AA")
  }
  
  pfam.df <- pfamDomains[pfamDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
  
  if (!is.na(pfam.df$pfam_start)){
    for(i in 1:nrow(pfam.df)){
      xminVec <- c(xminVec, pfam.df$pfam_start[i])
      xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
      yminVec <- c(yminVec, 1)
      ymaxVec <- c(ymaxVec, 2)
      colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
    }
    for(i in 1:nrow(pfam.df)){
      if(pfam.df$pfam_start[i] > newProteinStart){
        xminVec <- c(xminVec, pfam.df$pfam_start[i])
        xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
        yminVec <- c(yminVec, -1)
        ymaxVec <- c(ymaxVec, 0)
        colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
      }
    }
  }
  
  df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  
  fam.add <- brewer.pal(n = 8, name = "Set1")
  
  if (grepl("chimeric",currentRow$type_final)){
    colorPallete <- c("lightblue", "mediumpurple1", fam.add[1:(length(unique(df.rect$colorVec)) - 2)])
  } else {
    colorPallete <- c("lightblue", fam.add[1:(length(unique(df.rect$colorVec)) - 1)])
  }
  
  tm.df <- tmDomains[tmDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
  
  if (!is.na(tm.df$transmembrane_domain_start)){
    for(i in 1:nrow(tm.df)){
      xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
      xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
      yminVec <- c(yminVec, 1)
      ymaxVec <- c(ymaxVec, 2)
      colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
    }
    for(i in 1:nrow(tm.df)){
      if(tm.df$transmembrane_domain_start[i] > newProteinStart){
        xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
        xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
        yminVec <- c(yminVec, -1)
        ymaxVec <- c(ymaxVec, 0)
        colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
      }
    }
    colorPallete <- c(colorPallete, "gold")
    df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  }
  
  gg_splice <- ggplot() + 
    geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
    scale_y_continuous(limits=c(-2,3))+
    scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
    annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = 2.3, label = currentRow$gene2, size = 9) +
    annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = .3, label = paste0(currentRow$subfamTE,"-",currentRow$gene2), size = 9) +
    geom_vline(xintercept = 0, alpha = .1)+
    labs(x = "Protein AA #", fill = "Key")+
    scale_fill_manual(values = colorPallete) +
    theme_classic() +
    theme(axis.line.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank())
  
  ggsave(paste0("./structurePlots/",currentRow$uniqid,"_kozak_","pfam.pdf"), gg_splice, width = 12, height = 6, device = cairo_pdf)
}
```


```{r}
library(RColorBrewer)
#Plain without any domains highlighted

currentFocusTable <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$cpc2_type_final %in% c("chimeric normal", "chimeric truncated", "truncated"),]

for(j in 1:nrow(currentFocusTable)){

  currentRow <- currentFocusTable[j,]
  
  
  newProteinSequence <- currentRow$cpc2_proteinseqfull2
  origProteinLeft <- as.numeric(as.character(currentRow$cpc2_origprotleft))
  origProteinSequence <- currentRow$orig_proteinsequence
  proteinLength <- nchar(origProteinSequence)
  newProteinStart <- proteinLength - origProteinLeft
  
  
  xminVec <- c(0,newProteinStart)
  xmaxVec <- c(proteinLength, proteinLength)
  yminVec <- c(1,-1)
  ymaxVec <- c(2,0)
  colorVec <- c("background", "background")
  
  if (grepl("chimeric",currentRow$cpc2_type_final)){
    xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
    xmaxVec <- c(xmaxVec, newProteinStart)
    yminVec <- c(yminVec, -1)
    ymaxVec <- c(ymaxVec, 0)
    colorVec <- c(colorVec, "novel AA")
  }
  
  df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  
  gg_splice <- ggplot() + 
    geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
    scale_y_continuous(limits=c(-2,3))+
    scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
    geom_vline(xintercept = 0, alpha = .1)+
    scale_fill_manual(values = c("lightblue", "mediumpurple1"))+
    theme_classic()
  
  ggsave(paste0("./structurePlots/",currentRow$uniqid,"_cpc2_","plain.pdf"), gg_splice, width = 12, height = 6, device = cairo_pdf)
  
  #Pfam with domains highlighted to show what is happening ot the proteins
  
  xminVec <- c(0,newProteinStart)
  xmaxVec <- c(proteinLength, proteinLength)
  yminVec <- c(1,-1)
  ymaxVec <- c(2,0)
  colorVec <- c("Background", "Background")
  
  if (grepl("chimeric",currentRow$cpc2_type_final)){
    xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
    xmaxVec <- c(xmaxVec, newProteinStart)
    yminVec <- c(yminVec, -1)
    ymaxVec <- c(ymaxVec, 0)
    colorVec <- c(colorVec, "Novel AA")
  }
  
  pfam.df <- pfamDomains[pfamDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
  
  if (!is.na(pfam.df$pfam_start)){
    for(i in 1:nrow(pfam.df)){
      xminVec <- c(xminVec, pfam.df$pfam_start[i])
      xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
      yminVec <- c(yminVec, 1)
      ymaxVec <- c(ymaxVec, 2)
      colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
    }
    for(i in 1:nrow(pfam.df)){
      if(pfam.df$pfam_start[i] > newProteinStart){
        xminVec <- c(xminVec, pfam.df$pfam_start[i])
        xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
        yminVec <- c(yminVec, -1)
        ymaxVec <- c(ymaxVec, 0)
        colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
      }
    }
  }
  
  df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  
  fam.add <- brewer.pal(n = 8, name = "Set1")
  
  if (grepl("chimeric",currentRow$cpc2_type_final)){
    colorPallete <- c("lightblue", "mediumpurple1", fam.add[1:(length(unique(df.rect$colorVec)) - 2)])
  } else {
    colorPallete <- c("lightblue", fam.add[1:(length(unique(df.rect$colorVec)) - 1)])
  }
  
  tm.df <- tmDomains[tmDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
  
  if (!is.na(tm.df$transmembrane_domain_start)){
    for(i in 1:nrow(tm.df)){
      xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
      xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
      yminVec <- c(yminVec, 1)
      ymaxVec <- c(ymaxVec, 2)
      colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
    }
    for(i in 1:nrow(tm.df)){
      if(tm.df$transmembrane_domain_start[i] > newProteinStart){
        xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
        xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
        yminVec <- c(yminVec, -1)
        ymaxVec <- c(ymaxVec, 0)
        colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
      }
    }
    colorPallete <- c(colorPallete, "gold")
    df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
  }
  
  gg_splice <- ggplot() + 
    geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
    scale_y_continuous(limits=c(-2,3))+
    scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
    annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = 2.3, label = currentRow$gene2, size = 9) +
    annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = .3, label = paste0(currentRow$subfamTE,"-",currentRow$gene2), size = 9) +
    geom_vline(xintercept = 0, alpha = .1)+
    labs(x = "Protein AA #", fill = "Key")+
    scale_fill_manual(values = colorPallete) +
    theme_classic() +
    theme(axis.line.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank())
  
  ggsave(paste0("./structurePlots/",currentRow$uniqid,"_cpc2_","pfam.pdf"), gg_splice, width = 12, height = 6, device = cairo_pdf)
}
```


### Final Distribution Determination Pie Graphs

This is the final set of comparisons that we will do. 

```{r}
tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$cpc2_type_final))
slices <- tetable$Freq
lbls <- factor(c("Chimeric Normal", "Chimeric Truncated", "None", "Normal", "Frameshift", "Truncated"), levels <- c("Chimeric Normal", "Chimeric Truncated", "None", "Normal", "Frameshift", "Truncated"))
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, '\n',pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, col= c("#F27F3D", "#F24405","#7E9ABF","#A69D8D","firebrick4", "#59554D"),main="Method 1 Type Call")

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$type_final))
slices <- tetable$Freq
lbls <- factor(c("Chimeric Normal", "Chimeric Truncated", "None", "Normal", "Frameshift", "Truncated"), levels <- c("Chimeric Normal", "Chimeric Truncated", "None", "Normal", "Frameshift", "Truncated"))
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, '\n',pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, col= c("#F27F3D", "#F24405","#7E9ABF","#A69D8D","firebrick4", "#59554D"),main="Method 2 Type Call")

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$sameprotein))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls,'\n' ,pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Kozak and CPC2 Sequence Agreement")

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$type_final == annotatedcufftranscripts.fil.c$cpc2_type_final))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Kozak and CPC2 Type Agreement")
```

```{r}
annotatedcufftranscripts.fil.c$antigenic <- grepl("chimeric normal|chimeric truncated|out-of-frame|novel non-chimeric", annotatedcufftranscripts.fil.c$type) | grepl("chimeric normal|chimeric truncated|out-of-frame|novel non-chimeric", annotatedcufftranscripts.fil.c$cpc2_type)

annotatedcufftranscripts.fil.c$membrane <- grepl('plasma membrane', annotatedcufftranscripts.fil.c$go)

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$membrane))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Membrane Bound")


annotatedcufftranscripts.fil.c$membraneantigen <- annotatedcufftranscripts.fil.c$membrane == TRUE & (grepl('chimeric', annotatedcufftranscripts.fil.c$type_final) | grepl('chimeric', annotatedcufftranscripts.fil.c$cpc2_type_final))

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$membraneantigen))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Membrane Bound and Chimeric Antigen")

annotatedcufftranscripts.fil.c$extracellular <- grepl('extracellular', annotatedcufftranscripts.fil.c$go)

annotatedcufftranscripts.fil.c$extracellularantigen <- annotatedcufftranscripts.fil.c$extracellular == TRUE & (grepl('chimeric', annotatedcufftranscripts.fil.c$type_final) | grepl('chimeric', annotatedcufftranscripts.fil.c$cpc2_type_final))

tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$extracellularantigen))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Extracellular and Chimeric Antigen")


tetable <- as.data.frame(table(annotatedcufftranscripts.fil.c$extracellularantigen | annotatedcufftranscripts.fil.c$membraneantigen))
slices <- tetable$Freq
lbls <- tetable$Var1
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to label
pie(slices, labels = lbls, main="Extracellular or MB and Chimeric Antigen")
```

##Truncating Candidates Evaluation



```{r}
library("xlsx")
annotatedcufftranscripts.fil.c.m <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$membraneantigen == TRUE,]

annotatedcufftranscripts.fil.c.m$tumorsamples <- NULL

write.xlsx(annotatedcufftranscripts.fil.c.m, "Membrane_Candidates_unfiltered.xlsx", row.names = FALSE)
```


#CAGER Incorporation

Note: Had to run the following in an R session separately and then load back in the data because the namespace was having problems 

```{r}
#Ran this on R3.4.1 and that was the only way to get the code to work to cluster. I then will reload the input to get the final result. 

library("ggplot2")
library('CAGEr')
library('BSgenome.Hsapiens.UCSC.hg38')

gencodeReference <- "~/reference/Gencode/gencode.v25.basic.annotation.gff3"

setwd('nsorted')

ifiles=list.files(pattern="m\\.CTSS$")

cs = new("CAGEset", genomeName = "BSgenome.Hsapiens.UCSC.hg38", inputFiles = ifiles, inputFilesType = "ctss", sampleLabels = ifiles)

getCTSS(cs)
normalizeTagCount(cs, method="simpleTpm")

clusterCTSS(object = cs, method = "distclu", threshold = 0.1, nrPassThreshold = 2, thresholdIsTpm = TRUE, removeSingletons = TRUE, keepSingletonsAbove = 0.2, minStability = 2, maxLength = 100, reduceToNonoverlapping = TRUE, useMulticore = TRUE, nrCores = 12)

aggregateTagClusters(cs, tpmThreshold = 0.3, qLow = NULL, qUp = NULL, maxDist = 100, excludeSignalBelowThreshold = FALSE)


cc.df <- consensusClusters(cs, sample = NULL, returnInterquantileWidth = FALSE, qLow = NULL, qUp = NULL)
cc.df.tpm <- consensusClustersTpm(cs)

ctss.tags <- CTSStagCount(cs)

library("snow")

clus <- makeCluster(12)

clusterExport(clus,"ctss.tags")

resultapply <- parApply(clus,cc.df[,c("chr", "start", "end", "strand")],1,function(x) colSums(ctss.tags[ctss.tags$chr == x[1] & ctss.tags$pos >= as.numeric(x[2]) & ctss.tags$pos <= as.numeric(x[3]) & ctss.tags$strand == x[4], 4:ncol(ctss.tags)]))
stopCluster(clus)

ifiles2=list.files(pattern="G\\.CTSS$")

cs2 = new("CAGEset", genomeName = "BSgenome.Hsapiens.UCSC.hg38", inputFiles = ifiles2, inputFilesType = "ctss", sampleLabels = ifiles2)

getCTSS(cs2)

ctss.tags.2 <- CTSStagCount(cs2)

library("snow")

clus <- makeCluster(12)

clusterExport(clus,"ctss.tags.2")

resultapply2 <- parApply(clus,cc.df[,c("chr", "start", "end", "strand")],1,function(x) colSums(ctss.tags.2[ctss.tags.2$chr == x[1] & ctss.tags.2$pos >= as.numeric(x[2]) & ctss.tags.2$pos <= as.numeric(x[3]) & ctss.tags.2$strand == x[4], 4:ncol(ctss.tags.2)]))
stopCluster(clus)

save.image("progress1.RData")
```

#Calculate the percentage unannotatedG reads for each peak. For now I use the max since if it is valid in one sample it should be valid in all


```{r}
load("./nsorted/progress1.RData")
```

```{r}
allCTSSpeakcount <- as.data.frame(t(resultapply))
uGCTSSpeakcount <- as.data.frame(t(resultapply2))

uGPercent <- uGCTSSpeakcount/allCTSSpeakcount

uGPercent[is.na(uGPercent)] <- 0

cc.df$maxUGPercentage <- apply(uGPercent, 1, function(x) max(x))

cc.df.tpm <- as.data.frame(cc.df.tpm)

cc.df <- cbind(cc.df, cc.df.tpm)
```

#Final filter 

```{r}

threshold <- .15

cc.df.fil <- cc.df[cc.df$maxUGPercentage >= threshold,]

```

# Getting activated peak numbers

```{r}
activeThresh <- .1

sum(rowMeans(cc.df.fil[,grepl("B36_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("B36_DACPano", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("B49_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("B49_DACPano", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("B66_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("B66_DACPano", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("_hFB_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("_hFB_DACSB", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("shFB_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("shFB_DACPano", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("_NHA_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("_hFB_DACSB", colnames(cc.df.fil))]) >= activeThresh)

sum(rowMeans(cc.df.fil[,grepl("qNHA_DMSO", colnames(cc.df.fil))]) <  activeThresh & rowMeans(cc.df.fil[,grepl("shFB_DACPano", colnames(cc.df.fil))]) >= activeThresh)
```


# Get the exon skipped correction

```{r}
calcExonSkip <- function(gene1, gene2, number1, number2){
  if (gene1 != gene2 | (gene1 == 'None' & gene2 == 'None')){
    exonskipped <- -1
  } else {
    exonskipped <- as.numeric(number2)-as.numeric(number1)
  }
  return(exonskipped)
}

annotatedcufftranscripts.fil.c$exonskipped <- apply(annotatedcufftranscripts.fil.c[,c('gene1','gene2', 'number1', 'number2')],1,function(x) calcExonSkip(x[1],x[2],x[3],x[4]))

annotatedcufftranscripts.fil.c <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$exonskipped != 2,]

unloadNamespace("Xmisc")
```

#INcorporation of CAGE Data

```{r}
cagePeaks.bed <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/consensusPeaks_cage.chr1_22X.bed", sep = "\t", header = F)

colnames(cagePeaks.bed) <- c("chromosome", "start", "end", "consensus.cluster", "num2", "strand")
```

Correlating cage peaks to transcripts TE. I need a consistent way to correlate a CAGE peak to a TE. There are times where multiple CAGE peaks will correlate to a TE

```{r}
annotatedcufftranscripts.fil.c.rna$numPeaks <- apply(annotatedcufftranscripts.fil.c.rna[,c("chr2","startTE", "endTE", "strand")], 1, function(x){
  subsetTable <- cagePeaks.bed[cagePeaks.bed$chromosome == x[1] & cagePeaks.bed$end >= as.numeric(x[2]) & cagePeaks.bed$start <= as.numeric(x[3]) & cagePeaks.bed$strand == x[4],]
  return(nrow(subsetTable))
})

```

All the statistics are done on a peak, by peak level and thus I need to choose one peak per sample. I am going to choose the one with the highest average TPM across the GSC cell lines as the peak of choice. 

```{r}
b66.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/B66.TPM.DEseq2.txt", sep = "\t", header = T)
b49.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/B49.TPM.DEseq2.txt", sep = "\t", header = T)
b36.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/B36.TPM.DEseq2.txt", sep = "\t", header = T)
hfb.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/hFB.TPM.DEseq2.txt", sep = "\t", header = T)
nha.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/NHA.TPM.DEseq2.txt", sep = "\t", header = T)
qhfb.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/QhFB.TPM.DEseq2.txt", sep = "\t", header = T)
qnha.cagadata <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/CAGE_withTPM/QNHA.TPM.DEseq2.txt", sep = "\t", header = T)
```
```{r}
cagePeaks.bed$gscdpaverage <- sapply(cagePeaks.bed$consensus.cluster, function(x){return(mean(c(b36.cagadata$B36_DP[b36.cagadata$consensus.cluster == x], b49.cagadata$B49_DP[b49.cagadata$consensus.cluster == x], b66.cagadata$B66_DP[b66.cagadata$consensus.cluster == x])))})

cagePeaks.bed$chromosome <- as.character(cagePeaks.bed$chromosome)
cagePeaks.bed$strand <-  as.character(cagePeaks.bed$strand)
```

```{r}
resultsPeaks <- apply(annotatedcufftranscripts.fil.c.rna[,c("chr2","startTE", "endTE", "strand")], 1, function(x){
  subsetTable <- cagePeaks.bed[cagePeaks.bed$chromosome == x[1] & cagePeaks.bed$end >= as.numeric(x[2]) & cagePeaks.bed$start <= as.numeric(x[3]) & cagePeaks.bed$strand == x[4],]
  if(nrow(subsetTable) > 0){
    subsetTable <- subsetTable[order(-subsetTable$gscdpaverage),] 
    return(as.character(subsetTable[1,c("consensus.cluster", "chromosome", "start", "end", "strand")]))
  } else {
    return(as.character(c(0, 0, 0, 0, 0)))
  }
})

resultsPeaks <- as.data.frame(t(resultsPeaks))
colnames(resultsPeaks) <- c("clusterPeak", "chromosomePeak","startPeak", "endPeak","strandPeak")

annotatedcufftranscripts.fil.c.rna <- cbind(annotatedcufftranscripts.fil.c.rna, resultsPeaks)

annotatedcufftranscripts.fil.c <- annotatedcufftranscripts.fil.c.rna[annotatedcufftranscripts.fil.c.rna$clusterPeak != 0,]
```

Activated clusters/transcripts in each dataset. 
```{r}
b66.cagadata.cand <- b66.cagadata[b66.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
b36.cagadata.cand <- b36.cagadata[b36.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
b49.cagadata.cand <- b49.cagadata[b49.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
hfb.cagadata.cand <- hfb.cagadata[hfb.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
nha.cagadata.cand <- nha.cagadata[nha.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
qhfb.cagadata.cand <- qhfb.cagadata[qhfb.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
qnha.cagadata.cand <- qnha.cagadata[qnha.cagadata$consensus.cluster %in% annotatedcufftranscripts.fil.c$clusterPeak,]
```

First figure out which transcripts are present in the treated samples

```{r}
b66.cagadata.cand$presentin <- b66.cagadata.cand$B66_DP >= 1.0 | b66.cagadata.cand$B66_DMSO >= 1.0
b66.cagadata.cand$presentin[is.na(b66.cagadata.cand$presentin)] <- FALSE

b49.cagadata.cand$presentin <- b49.cagadata.cand$B49_DP >= 1.0 | b49.cagadata.cand$B49_DMSO >= 1.0
b49.cagadata.cand$presentin[is.na(b49.cagadata.cand$presentin)] <- FALSE

b36.cagadata.cand$presentin <- b36.cagadata.cand$B36_DP >= 1.0 | b36.cagadata.cand$B36_DMSO >= 1.0
b36.cagadata.cand$presentin[is.na(b36.cagadata.cand$presentin)] <- FALSE
```

```{r}
b66.cagadata.cand$activated <- b66.cagadata.cand$B66_DMSO < 1.0 & b66.cagadata.cand$B66_DP >= 1.0 & b66.cagadata.cand$padj <= 0.05 & abs(b66.cagadata.cand$log2FoldChange) >= 2
b66.cagadata.cand$activated[is.na(b66.cagadata.cand$activated)] <- FALSE

b49.cagadata.cand$activated <- b49.cagadata.cand$B49_DMSO < 1.0 & b49.cagadata.cand$B49_DP >= 1.0 & b49.cagadata.cand$padj <= 0.05 & abs(b49.cagadata.cand$log2FoldChange) >= 2
b49.cagadata.cand$activated[is.na(b49.cagadata.cand$activated)] <- FALSE

b36.cagadata.cand$activated <- b36.cagadata.cand$B36_DMSO < 1.0 & b36.cagadata.cand$B36_DP >= 1.0 & b36.cagadata.cand$padj <= 0.05 & abs(b36.cagadata.cand$log2FoldChange) >= 2
b36.cagadata.cand$activated[is.na(b36.cagadata.cand$activated)] <- FALSE
```

```{r}
qhfb.cagadata.cand$presentin <- qhfb.cagadata.cand$QhFB_DP >= 1.0 | qhfb.cagadata.cand$QhFB_DMSO >= 1.0
qhfb.cagadata.cand$presentin[is.na(qhfb.cagadata.cand$presentin)] <- FALSE

qnha.cagadata.cand$presentin <- qnha.cagadata.cand$QNHA_DP >= 1.0 | qnha.cagadata.cand$QNHA_DMSO >= 1.0
qnha.cagadata.cand$presentin[is.na(qnha.cagadata.cand$presentin)] <- FALSE

hfb.cagadata.cand$presentin <- hfb.cagadata.cand$hFB_DP >= 1.0 | hfb.cagadata.cand$hFB_DMSO >= 1.0
hfb.cagadata.cand$presentin[is.na(hfb.cagadata.cand$presentin)] <- FALSE

nha.cagadata.cand$presentin <- nha.cagadata.cand$NHA_DP >= 1.0 | nha.cagadata.cand$NHA_DMSO >= 1.0
nha.cagadata.cand$presentin[is.na(nha.cagadata.cand$presentin)] <- FALSE
```

```{r}
hfb.cagadata.cand$activated <- hfb.cagadata.cand$hFB_DMSO < 1.0 & hfb.cagadata.cand$hFB_DP >= 1.0 & hfb.cagadata.cand$padj <= 0.05 & abs(hfb.cagadata.cand$log2FoldChange) >= 2
hfb.cagadata.cand$activated[is.na(hfb.cagadata.cand$activated)] <- FALSE

nha.cagadata.cand$activated <- nha.cagadata.cand$NHA_DMSO < 1.0 & nha.cagadata.cand$NHA_DP >= 1.0 & nha.cagadata.cand$padj <= 0.05 & abs(nha.cagadata.cand$log2FoldChange) >= 2
nha.cagadata.cand$activated[is.na(nha.cagadata.cand$activated)] <- FALSE
```


```{r}
b66.cagadata.cand$inquiescent <- sapply(b66.cagadata.cand$consensus.cluster, function(x) qnha.cagadata.cand[qnha.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE | qhfb.cagadata.cand[qhfb.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE)

b49.cagadata.cand$inquiescent <- sapply(b49.cagadata.cand$consensus.cluster, function(x) qnha.cagadata.cand[qnha.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE | qhfb.cagadata.cand[qhfb.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE)

b36.cagadata.cand$inquiescent <- sapply(b36.cagadata.cand$consensus.cluster, function(x) qnha.cagadata.cand[qnha.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE | qhfb.cagadata.cand[qhfb.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE)

hfb.cagadata.cand$inquiescent <- sapply(hfb.cagadata.cand$consensus.cluster, function(x) qnha.cagadata.cand[qnha.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE | qhfb.cagadata.cand[qhfb.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE)

nha.cagadata.cand$inquiescent <- sapply(nha.cagadata.cand$consensus.cluster, function(x) qnha.cagadata.cand[qnha.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE | qhfb.cagadata.cand[qhfb.cagadata.cand$consensus.cluster == x, c('presentin')] == TRUE)
```

```{r}
annotatedcufftranscripts.fil.c$antigenic <- grepl("chimeric normal|chimeric truncated|out-of-frame|novel non-chimeric", annotatedcufftranscripts.fil.c$type) | grepl("chimeric normal|chimeric truncated|out-of-frame|novel non-chimeric", annotatedcufftranscripts.fil.c$cpc2_type)

transcriptPeakTable <- annotatedcufftranscripts.fil.c[,c("transcriptname", "clusterPeak", "uniqid", "cpc2_type", "type")]

transcriptPeakTable$B66_present <- transcriptPeakTable$clusterPeak %in% b66.cagadata.cand$consensus.cluster[b66.cagadata.cand$presentin]
 
transcriptPeakTable$B66_activated <- transcriptPeakTable$clusterPeak %in% b66.cagadata.cand$consensus.cluster[b66.cagadata.cand$activated]

transcriptPeakTable$B66_notquescent <- (transcriptPeakTable$clusterPeak %in% b66.cagadata.cand$consensus.cluster[b66.cagadata.cand$activated]) & !(transcriptPeakTable$clusterPeak %in% b66.cagadata.cand$consensus.cluster[b66.cagadata.cand$inquiescent])

transcriptPeakTable$B66_antigenic <- transcriptPeakTable$B66_notquescent & (transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c$transcriptname[annotatedcufftranscripts.fil.c$antigenic == TRUE])

transcriptPeakTable$B49_present <- transcriptPeakTable$clusterPeak %in% b49.cagadata.cand$consensus.cluster[b49.cagadata.cand$presentin]
 
transcriptPeakTable$B49_activated <- transcriptPeakTable$clusterPeak %in% b49.cagadata.cand$consensus.cluster[b49.cagadata.cand$activated]

transcriptPeakTable$B49_notquescent <- (transcriptPeakTable$clusterPeak %in% b49.cagadata.cand$consensus.cluster[b49.cagadata.cand$activated]) & !(transcriptPeakTable$clusterPeak %in% b49.cagadata.cand$consensus.cluster[b49.cagadata.cand$inquiescent])

transcriptPeakTable$B49_antigenic <- transcriptPeakTable$B49_notquescent & (transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c$transcriptname[annotatedcufftranscripts.fil.c$antigenic == TRUE])

transcriptPeakTable$B36_present <- transcriptPeakTable$clusterPeak %in% b36.cagadata.cand$consensus.cluster[b36.cagadata.cand$presentin]
 
transcriptPeakTable$B36_activated <- transcriptPeakTable$clusterPeak %in% b36.cagadata.cand$consensus.cluster[b36.cagadata.cand$activated]

transcriptPeakTable$B36_notquescent <- (transcriptPeakTable$clusterPeak %in% b36.cagadata.cand$consensus.cluster[b36.cagadata.cand$activated]) & !(transcriptPeakTable$clusterPeak %in% b36.cagadata.cand$consensus.cluster[b36.cagadata.cand$inquiescent])

transcriptPeakTable$B36_antigenic <- transcriptPeakTable$B36_notquescent & (transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c$transcriptname[annotatedcufftranscripts.fil.c$antigenic == TRUE])

transcriptPeakTable$NHA_present <- transcriptPeakTable$clusterPeak %in% nha.cagadata.cand$consensus.cluster[nha.cagadata.cand$presentin]
 
transcriptPeakTable$NHA_activated <- transcriptPeakTable$clusterPeak %in% nha.cagadata.cand$consensus.cluster[nha.cagadata.cand$activated]

transcriptPeakTable$NHA_notquescent <- (transcriptPeakTable$clusterPeak %in% nha.cagadata.cand$consensus.cluster[nha.cagadata.cand$activated]) & !(transcriptPeakTable$clusterPeak %in% nha.cagadata.cand$consensus.cluster[nha.cagadata.cand$inquiescent])

transcriptPeakTable$NHA_antigenic <- transcriptPeakTable$NHA_notquescent & (transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c$transcriptname[annotatedcufftranscripts.fil.c$antigenic == TRUE])

transcriptPeakTable$hFB_present <- transcriptPeakTable$clusterPeak %in% hfb.cagadata.cand$consensus.cluster[hfb.cagadata.cand$presentin]
 
transcriptPeakTable$hFB_activated <- transcriptPeakTable$clusterPeak %in% hfb.cagadata.cand$consensus.cluster[hfb.cagadata.cand$activated]

transcriptPeakTable$hFB_notquescent <- (transcriptPeakTable$clusterPeak %in% hfb.cagadata.cand$consensus.cluster[hfb.cagadata.cand$activated]) & !(transcriptPeakTable$clusterPeak %in% hfb.cagadata.cand$consensus.cluster[hfb.cagadata.cand$inquiescent])

transcriptPeakTable$hFB_antigenic <- transcriptPeakTable$hFB_notquescent & (transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c$transcriptname[annotatedcufftranscripts.fil.c$antigenic == TRUE])
```

```{r}
library(dplyr)

focusColumns <- colnames(transcriptPeakTable)[grepl("B49|B66|B36", colnames(transcriptPeakTable))]

Freq <- c()

for (nowColumn in focusColumns){
  Freq <- c(Freq, sum(transcriptPeakTable[[nowColumn]]))
}

funnelStats <- data.frame(sumStat = focusColumns, value = Freq)

write.csv(funnelStats, "./finalFigures/funnelStats.csv", quote = F, row.names = F)
```

```{r}
transcriptPeakTable$cpc2_type <- gsub("novel non-chimeric", "out-of-frame", transcriptPeakTable$cpc2_type)
transcriptPeakTable$type <- gsub("novel non-chimeric", "out-of-frame", transcriptPeakTable$type)

write.csv(transcriptPeakTable, "./finalFigures/candidateTranscriptTranslationStats.csv", quote = F, row.names = F)
```

To create the pie charts of the various translation strategies will use the transcripts that are activated epigenetically only and then use those as an input into the pie charts. This is since the antigenic filter will make sense in termns of which ones were choosen to be antigenic. 

```{r}
library(dplyr)
library(cowplot)

textSize = 5

textLabel <- sort(unique(annotatedcufftranscripts.fil.c$type_final))
colorsLabel <- brewer.pal(n = 6, name = "Set3")
names(colorsLabel) <- textLabel
```

```{r}

currentCL <- "B49"

B49_notquescent <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname %in% transcriptPeakTable$transcriptname[transcriptPeakTable$B49_notquescent == TRUE],]

B49_notquescent.kozak.table <-as.data.frame(table(B49_notquescent$type_final))

B49_notquescent.kozak.table <- B49_notquescent.kozak.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B49_notquescent.kozak.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B49_notquescent.kozak.table$Freq)/100))

pB49_notquescent_kozak <- ggplot(B49_notquescent.kozak.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB49_notquescent_kozak 

B49_notquescent.cpc2.table <-as.data.frame(table(B49_notquescent$cpc2_type_final))

B49_notquescent.cpc2.table <- B49_notquescent.cpc2.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B49_notquescent.cpc2.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B49_notquescent.cpc2.table$Freq)/100))

pB49_notquescent_cpc2 <- ggplot(B49_notquescent.cpc2.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB49_notquescent_cpc2 

```

```{r}
currentCL <- "B66"

B66_notquescent <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname %in% transcriptPeakTable$transcriptname[transcriptPeakTable$B66_notquescent == TRUE],]

B66_notquescent.kozak.table <-as.data.frame(table(B66_notquescent$type_final))

B66_notquescent.kozak.table <- B66_notquescent.kozak.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B66_notquescent.kozak.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B66_notquescent.kozak.table$Freq)/100))

pB66_notquescent_kozak <- ggplot(B66_notquescent.kozak.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB66_notquescent_kozak 

B66_notquescent.cpc2.table <-as.data.frame(table(B66_notquescent$cpc2_type_final))

B66_notquescent.cpc2.table <- B66_notquescent.cpc2.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B66_notquescent.cpc2.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B66_notquescent.cpc2.table$Freq)/100))

pB66_notquescent_cpc2 <- ggplot(B66_notquescent.cpc2.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB66_notquescent_cpc2 

```

```{r}
currentCL <- "B36"

B36_notquescent <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname %in% transcriptPeakTable$transcriptname[transcriptPeakTable$B36_notquescent == TRUE],]

B36_notquescent.kozak.table <-as.data.frame(table(B36_notquescent$type_final))

B36_notquescent.kozak.table <- B36_notquescent.kozak.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B36_notquescent.kozak.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B36_notquescent.kozak.table$Freq)/100))

pB36_notquescent_kozak <- ggplot(B36_notquescent.kozak.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB36_notquescent_kozak 

B36_notquescent.cpc2.table <-as.data.frame(table(B36_notquescent$cpc2_type_final))

B36_notquescent.cpc2.table <- B36_notquescent.cpc2.table %>% 
  arrange(desc(Var1)) %>%
  mutate(prop = Freq / sum(B36_notquescent.cpc2.table$Freq) *100) %>%
  mutate(ypos = (cumsum(prop)- 0.5*prop)*(sum(B36_notquescent.cpc2.table$Freq)/100))

pB36_notquescent_cpc2 <- ggplot(B36_notquescent.cpc2.table, aes(x = "", y = Freq, fill = Var1)) + 
  geom_bar(stat = "identity", width = 1, color = "black") +
  geom_text(aes(y = ypos, label = Freq), color = "black", size = textSize) +
  coord_polar("y", start=0) +
  scale_fill_manual(values = colorsLabel) +
  theme_void() +
  theme(legend.position="None") 
pB36_notquescent_cpc2 

```

Arranging these into a cowplot

```{r}
legendKozak <- get_legend(pB36_notquescent_kozak + theme(legend.position="right") + labs(fill = "Kozak"))

legendCPC2 <- get_legend(pB36_notquescent_kozak + theme(legend.position="right") + labs(fill = "CPC2"))
```

```{r}
pieKozak <- plot_grid(legendKozak,
                      pB36_notquescent_kozak,
                      pB49_notquescent_kozak,
                      pB66_notquescent_kozak,
                      ncol = 4,
                      rel_widths = c(1/7,2/7,2/7,2/7))

pieCPC2 <- plot_grid(legendCPC2,
                      pB36_notquescent_cpc2,
                      pB49_notquescent_cpc2,
                      pB66_notquescent_cpc2,
                      ncol = 4,
                      rel_widths = c(1/7,2/7,2/7,2/7))

pieALL.translation <- plot_grid(pieKozak, pieCPC2, ncol = 1)
```

```{r}
ggsave("./plots/F2_PieAllTranslation.pdf", height = 4, width = 8, device = cairo_pdf())
```

#FIgure 2C

This will be the Venn diagrams for the Transcripts that are activated, and those not in quescent. 

```{r}
colorCellLine <- c("#BA2327", "#7F87AA", "#409066")
names(colorCellLine) <- c("B36", "B49", "B66")
```


```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/EpitherapyActivated_Venn.pdf", width = 4, height = 4)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- transcriptPeakTable$transcriptname[transcriptPeakTable$B36_activated == TRUE], 
                       B <- transcriptPeakTable$transcriptname[transcriptPeakTable$B49_activated == TRUE],
                       C <- transcriptPeakTable$transcriptname[transcriptPeakTable$B66_activated == TRUE]),
                  NULL,
                  fill=c(colorCellLine[names(colorCellLine) == "B36"],
                         colorCellLine[names(colorCellLine) == "B49"],
                         colorCellLine[names(colorCellLine) == "B66"]), 
                  alpha=c(0.25,0.25,0.25), 
             cex = 2, 
             category.names=c("B36","B49","B66"))

grid.draw(p)
dev.off()
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/QActivated_Venn.pdf", width = 4, height = 4)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- transcriptPeakTable$transcriptname[transcriptPeakTable$B36_notquescent == TRUE], 
                       B <- transcriptPeakTable$transcriptname[transcriptPeakTable$B49_notquescent == TRUE],
                       C <- transcriptPeakTable$transcriptname[transcriptPeakTable$B66_notquescent == TRUE]),
                  NULL,
                  fill=c(colorCellLine[names(colorCellLine) == "B36"],
                         colorCellLine[names(colorCellLine) == "B49"],
                         colorCellLine[names(colorCellLine) == "B66"]), 
                  alpha=c(0.25,0.25,0.25), 
             cex = 2, 
             category.names=c("B36","B49","B66"))

grid.draw(p)
dev.off()
```


#MHC/HLA information incorporation for the analysis
```{r}
library(reshape2)
HLAinformation <- read.delim('/scratch/nakul/TE_Antigen_glioblastoma_project/mRNA_analysisFinal/hlaType/HLAalleles_cellline.txt',sep = "\t", stringsAsFactors = FALSE, header = FALSE)

#There are many repeat cell lines, so I wanted to just take one entry per cell line
colnames(HLAinformation) <- c('file_label', 'HLA-A-1', 'HLA-A-2', 'HLA-B-1', 'HLA-B-2', 'HLA-C-1', 'HLA-C-2')
HLAinformation$file_label <- sapply(HLAinformation$file_label, function(x) {
  strsplit(x, '_Brep')[[1]][1]
})
HLAinformation <- HLAinformation[!duplicated(HLAinformation$file_label),]

#The column names are not exact matches to file names since this is an average across. Thus I need to create a key 
colNamesExp <- c("DACaverageB36",  "DACaverageB49", "DACaverageB66", "DACaverageAhFB", "DACaverageQhFB", "DACaverageNHA", "DACaverageQNHA")
fileNameConversion <- c("Trimed_mRNA_B36_DACPano", "Trimed_mRNA_B49_DACPano", "Trimed_mRNA_B66_DACPano", "Trimed_mRNA_hFB_DACPano", "Trimed_mRNA_shFB_DACPano", "Trimed_mRNA_NHA_DACPano", "Trimed_mRNA_qNHA_DACPano")

HLAinformation$file_label <- colNamesExp[match(HLAinformation$file_label, fileNameConversion)]
HLAinformation <- HLAinformation[!is.na(HLAinformation$file_label),]

HLA.melt <- melt(HLAinformation, id.vars = c('file_label'))
```


```{r}
annotatedcufftranscripts.fil.c.antigenic <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$antigenic,]

transcriptPeakTable.antigenic <- transcriptPeakTable[transcriptPeakTable$transcriptname %in% annotatedcufftranscripts.fil.c.antigenic$transcriptname,]

expressionColumns <- colnames(transcriptPeakTable.antigenic)[grepl("_DMSO|_DP", colnames(transcriptPeakTable.antigenic))]

transcriptPeakTable.antigenic$CL <- apply(transcriptPeakTable.antigenic[,expressionColumns], 1, function(x){
  return(unique(gsub("_DP|_DMSO","",expressionColumns[as.numeric(x) >= 1])))
})

transcriptPeakTable.antigenic$numCL <- sapply(transcriptPeakTable.antigenic$CL, function(x)return(length(x)))
transcriptPeakTable.antigenic.cand <- transcriptPeakTable.antigenic[transcriptPeakTable.antigenic$numCL > 0,]

indexMatch <- match(annotatedcufftranscripts.fil.c.antigenic$transcriptname, transcriptPeakTable.antigenic$transcriptname)

annotatedcufftranscripts.fil.c.antigenic$CL <- transcriptPeakTable.antigenic$CL[indexMatch]
annotatedcufftranscripts.fil.c.antigenic$numCL <- transcriptPeakTable.antigenic$numCL[indexMatch]
```


```{r}

annotatedcufftranscripts.fil.c.antigenic.cand <- annotatedcufftranscripts.fil.c.antigenic[annotatedcufftranscripts.fil.c.antigenic$numCL > 0,]

MHCtype <- function(peakName, proteinsequence, framelabel, frametype, nmdcall, HLAgenes){
  returnHLA = c()
  if (frametype == "out-of-frame" || grepl("chimeric", frametype)){
    endloc = gregexpr(pattern ='\\*',proteinsequence)[[1]][1]
    if (endloc == -1){
      peptide = proteinsequence 
    } else {
      peptide = substring(proteinsequence, 1, endloc - 1)
    }
    if (nchar(as.character(peptide)) >= 8){
      HLAgenes <- HLAgenes[HLAgenes != "HLA-no"]
      for (HLAgene in HLAgenes){
        # HLAgene = HLAgenes[1]
        commandstring = paste0("printf '> Sequence 1 \n",peptide,"' | /bar/nshah/programs/netMHCpan-4.0/netMHCpan -BA -s -a ",HLAgene," -- | grep '*",substring(HLAgene,6,10),"' | awk '{$15=$16=\"\"; print $0}' > ",peakName,HLAgene)
        print(commandstring)
        system2("/bin/bash", args = c("-c", shQuote(commandstring)))
        if(file.info(paste0(peakName,HLAgene)) != 0){
          tempdata <- read.table(textConnection(rev(rev(readLines(paste0(peakName,HLAgene)))[-(1:1)])), sep = "" , header = FALSE, stringsAsFactors = FALSE)
          # Only weak and strong binders are included in the final output
          temptempdata <- tempdata
          #tempdata <- tempdata[as.numeric(tempdata$V14) < 2.0,]
        } else {
          tempdata <- data.frame()
        }
        if (!(!nrow(tempdata))){
          k = 0
          keepvector = c()
          for (peptidetest in tempdata$V10){
            # This block checks if the peptide is only within the region that is from the original transcript and thus should not be a part of the analysis
            indexpep <- gregexpr(pattern = peptidetest, peptide)[[1]]
            lengthpep <- length(gregexpr(pattern = peptidetest, peptide)[[1]])
            if (lengthpep == 1){
              indexpep = indexpep
            } else {
              indexpep = indexpep[-1]
            }
            if (indexpep > nchar(as.character(peptide)) - 10){
              keepvector = c(keepvector, FALSE)
            } else {
              keepvector = c(keepvector, TRUE)
            }
          }
          
          # Only those that match the filters are included
          tempdata <- tempdata[keepvector,]
          if (!(!nrow(tempdata))){
            for (rownum in seq(1,nrow(tempdata))){
              returnHLA <- c(returnHLA, c(peakName, HLAgene, framelabel, frametype, nmdcall, tempdata[rownum,14], tempdata[rownum,13], tempdata[rownum,3]))
            }
          }
        }
        system(paste0("rm ",peakName,HLAgene))
      }
    }
  } 
  if (!(is.null(returnHLA))){return(returnHLA)}
}

clus <- makeCluster(4)
clusterExport(clus, "MHCtype", envir = .GlobalEnv)
clusterExport(clus, "HLA.melt", envir = .GlobalEnv)

resultsmhc <- parRapply(clus,annotatedcufftranscripts.fil.c.antigenic.cand[,c('uniqid','proteinseq','frame', 'type', 'nmdcall','CL')], function(x) MHCtype(x[1], x[2], x[3], x[4], x[5], unique(HLA.melt[HLA.melt$file_label %in% x[6][[1]],c('value')])))
unlisted <- unlist(resultsmhc, recursive = TRUE)
saveRDS(unlisted,'unlisted_111822_1.RDS')

dimcol = 8
dimrow = length(unlisted)/(dimcol)
resultsmhc = data.frame(matrix(unlisted, nrow = dimrow, ncol = dimcol, byrow = TRUE), stringsAsFactors = FALSE)

#Filter further to make results more stringent. The pipeline starts with 2 for weak binders, but you can make it stringent like .5 for strong ones
resultmhc.final <- resultsmhc[as.numeric(resultsmhc$X6) < 2, ]
colnames(resultmhc.final) <- c("peak","HLA","frame","type", "nmdcall","rank.percentage", "nM binding", "peptide")
resultmhc.final$`nM binding` <- as.numeric(resultmhc.final$`nM binding`)

stopCluster(clus)

clus <- makeCluster(4)
clusterExport(clus, "MHCtype", envir = .GlobalEnv)
clusterExport(clus, "HLA.melt", envir = .GlobalEnv)

resultsmhc <- parRapply(clus,annotatedcufftranscripts.fil.c.antigenic.cand[,c('uniqid','cpc2_proteinseq','cpc2_frame', 'cpc2_type', 'cpc2_nmdcall','CL')], function(x) MHCtype(x[1], x[2], x[3], x[4], x[5], unique(HLA.melt[HLA.melt$file_label %in% x[6][[1]],c('value')])))
unlisted <- unlist(resultsmhc, recursive = TRUE)
saveRDS(unlisted,'unlisted_111822_2.RDS')

dimcol = 8
dimrow = length(unlisted)/(dimcol)
resultsmhc = data.frame(matrix(unlisted, nrow = dimrow, ncol = dimcol, byrow = TRUE), stringsAsFactors = FALSE)

stopCluster(clus)

#resultsmhc <- resultsmhc[as.numeric(resultsmhc$X6) < 2, ]
colnames(resultsmhc) <- c("peak","HLA","frame","type", "nmdcall","rank.percentage", "nM binding", "peptide")
resultsmhc$`nM binding` <- as.numeric(resultsmhc$`nM binding`)

resultmhc.final <- rbind(resultmhc.final, resultsmhc)
resultmhc.final <- unique(resultmhc.final)
saveRDS(resultmhc.final,'resultmhc.final_111822.RDS')
```


```{r}
HLA.melt$file_label <- gsub("DACaverage", "",HLA.melt$file_label)
HLA.melt$file_label <- gsub("AhFB", "hFB",HLA.melt$file_label)
```

```{r}
getSummaryStats2 <- function(peptable){
    peptableoof <- peptable[peptable$type == "out-of-frame",]
    peptableinframe <- peptable[grepl("chimeric",peptable$type),]
    maxtotal <- min(peptable$`nM binding`)
    maxoof <- min(peptableoof$`nM binding`) 
    maxinframe <- min(peptableinframe$`nM binding`)
    return(c(maxtotal, maxinframe,maxoof))
}

library(tidyr)
library(ggplot2)
```

```{r}
resultmhc.final.2 <- readRDS("resultmhc.final.RDS")
```


```{r}
saveRDS(annotatedcufftranscripts.fil.c, "./finalFigures/annotatedcufftranscripts.fil.c.RDS")
saveRDS(HLA.melt, "./finalFigures/HLA.melt.RDS")
saveRDS(resultmhc.final, "./finalFigures/resultmhc.final.RDS")
saveRDS(transcriptPeakTable, "./finalFigures/transcriptPeakTable.RDS")
```

Then there needs to be a quantification of antigens across the cell lines before and after treatment without any additional filtering to get a sense of how many there are
```{r}
currentCellLines <- c("B36", "B49", "B66", "hFB", "NHA", "QhFB", "QNHA")
antigenStats.transcript.df <- data.frame()
antigenStats.antigens.df <- data.frame()
i = 1
resultmhc.final.500 <- resultmhc.final[resultmhc.final$`nM binding` <= 500,]

for (currentCellLine in currentCellLines){
  for (treatment in c("_DP", "_DMSO")){
    uniqueIDs.cl <- transcriptPeakTable$uniqid[transcriptPeakTable[,c(paste0(currentCellLine,treatment))] >= 1]
    HLA.melt.cl <- HLA.melt[HLA.melt$file_label == currentCellLine,]
    resultmhc.final.cl <- resultmhc.final[resultmhc.final$peak %in% uniqueIDs.cl & resultmhc.final$HLA %in% HLA.melt.cl$value, ]
    resultmhc.final.500.cl <- resultmhc.final.cl[resultmhc.final.cl$`nM binding` <= 500,]
    uniqueIDs.cl.antigenic <- unique(resultmhc.final.500.cl$peak)
    antigenStats.transcript.df <- rbind(antigenStats.transcript.df, data.frame(labels = paste0(currentCellLine,treatment), transcriptnum = length(uniqueIDs.cl.antigenic)))
    antigenStats.antigens.df <- rbind(antigenStats.antigens.df, data.frame(labels = paste0(currentCellLine,treatment), antigennum = length(unique(resultmhc.final.500.cl$peptide))))
  }
}

```

Adjust tables for graphing
```{r}
antigenStats.transcript.df$labelsclean <- gsub("_"," ", antigenStats.transcript.df$labels)
antigenStats.transcript.df$treatment <- sapply(as.character(antigenStats.transcript.df$labels), function(x){strsplit(x,"_")[[1]][2]})
antigenStats.transcript.df$CL <- sapply(as.character(antigenStats.transcript.df$labels), function(x){strsplit(x,"_")[[1]][1]})
antigenStats.transcript.df$treatment <- factor(antigenStats.transcript.df$treatment, levels = c("DMSO","DP"))

antigenStats.antigens.df$labelsclean <- gsub("_"," ", antigenStats.antigens.df$labels)
antigenStats.antigens.df$treatment <- sapply(as.character(antigenStats.antigens.df$labels), function(x){strsplit(x,"_")[[1]][2]})
antigenStats.antigens.df$CL <- sapply(as.character(antigenStats.antigens.df$labels), function(x){strsplit(x,"_")[[1]][1]})
antigenStats.antigens.df$treatment <- factor(antigenStats.antigens.df$treatment, levels = c("DMSO","DP"))
```

Make graphs for the main 3 cell lines 

```{r}
antigenStats.transcript.df.f1 <- antigenStats.transcript.df[antigenStats.transcript.df$CL %in% c("B36","B49","B66"),]

p1 <- ggplot(antigenStats.transcript.df.f1, aes(CL, transcriptnum)) +
  geom_bar(aes(fill = treatment), position="dodge", stat="identity", color= "black", alpha = 0.75) +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  scale_y_continuous(expand=c(0,0), limits= c(0,90)) +
  geom_text(aes(label = transcriptnum, group = treatment), vjust=-0.25, position = position_dodge(width = .9)) +
  labs(y= "No. Transcripts", fill = "Treatment") +
  theme_classic() +
  theme(axis.title.x = element_blank())

antigenStats.antigens.df.f1 <- antigenStats.antigens.df[antigenStats.antigens.df$CL %in% c("B36","B49","B66"),]
p2 <- ggplot(antigenStats.antigens.df.f1, aes(CL, antigennum)) +
  geom_bar(aes(fill = treatment), position="dodge", stat="identity", color= "black", alpha = 0.75) +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  scale_y_continuous(expand=c(0,0), limits= c(0,2300)) +
  geom_text(aes(label = antigennum, group = treatment), vjust=-0.25, position = position_dodge(width = .9)) +
  labs(y= "No. Antigens", fill = "Treatment") +
  theme_classic() +
  theme(axis.title.x = element_blank())

library(cowplot)
pg1 <- plot_grid(p1, p2, align = "v",ncol = 1)

ggsave2("./plots/F2_AntigenPredictedStats.pdf", pg1, width = 4, height = 3.3, device = cairo_pdf)

```

```{r}
antigenStats.transcript.df.f2 <- antigenStats.transcript.df[!(antigenStats.transcript.df$CL %in% c("B36","B49","B66")),]

p3 <- ggplot(antigenStats.transcript.df.f2, aes(CL, transcriptnum)) +
  geom_bar(aes(fill = treatment), position="dodge", stat="identity", color= "black", alpha = 0.75) +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  scale_y_continuous(expand=c(0,0), limits= c(0,75)) +
  geom_text(aes(label = transcriptnum, group = treatment), vjust=-0.25, position = position_dodge(width = .9)) +
  labs(y= "No. Transcripts", fill = "Treatment") +
  theme_classic() +
  theme(axis.title.x = element_blank())

antigenStats.antigens.df.f1 <- antigenStats.antigens.df[!(antigenStats.antigens.df$CL %in% c("B36","B49","B66")),]
p4 <- ggplot(antigenStats.antigens.df.f1, aes(CL, antigennum)) +
  geom_bar(aes(fill = treatment), position="dodge", stat="identity", color= "black", alpha = 0.75) +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  scale_y_continuous(expand=c(0,0), limits= c(0,1600)) +
  geom_text(aes(label = antigennum, group = treatment), vjust=-0.25, position = position_dodge(width = .9)) +
  labs(y= "No. Antigens", fill = "Treatment") +
  theme_classic() +
  theme(axis.title.x = element_blank())

library(cowplot)
pg1 <- plot_grid(p3, p4, align = "v",ncol = 2)

ggsave2("./plots/F2_AntigenPredictedStats_OtherCL.pdf", pg1, width = 12, height = 2.6, device = cairo_pdf)

```


```{r}
currentCellLines <- c("B36", "B49", "B66", "hFB", "NHA")
heatmapplotLists <- list()
i = 1

for (currentCellLine in currentCellLines){
  
  annotatedcufftranscripts.cand.cl <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname %in% transcriptPeakTable$transcriptname[transcriptPeakTable[[paste0(currentCellLine,'_antigenic')]]],]
  
  HLA.melt.cl <- HLA.melt[HLA.melt$file_label == currentCellLine,]
  
  resultmhc.final.cl <- resultmhc.final[resultmhc.final$peak %in% annotatedcufftranscripts.cand.cl$uniqid & resultmhc.final$HLA %in% HLA.melt.cl$value, ]
  
  #resultmhc.final.cl$HLA <- factor(resultmhc.final.cl$HLA, levels = HLA.melt.cl$value)
  
  resultmhc.final.cl.unique <- unique(resultmhc.final.cl[,c("peak", "HLA")])
  
  #indexids <- match(fracexpressiontable.m.exp.t$variable, annotatedcufftranscripts.cand$transcriptname)
  #fracexpressiontable.m.exp.t$uniqid <- annotatedcufftranscripts.cand$uniqid[indexids]
  
  resultstats <- apply(resultmhc.final.cl.unique[,c("peak", "HLA")], 1, function(x) getSummaryStats2(resultmhc.final.cl[resultmhc.final.cl$peak == x[1] & resultmhc.final.cl$HLA == x[2],]))
  resultstats = data.frame(t(resultstats))
  
  resultstats[resultstats == Inf] <- 25000
  resultstats[resultstats > 25000] <- 25000
  resultmhc.final.cl.unique = cbind.data.frame(resultmhc.final.cl.unique, resultstats)
  colnames(resultmhc.final.cl.unique) <- c('file_label', 'HLA.allele', 'totalBA', 'ifBA', 'oofBA')
  
  resultmhc.final.cl.unique$HLA.group <- HLA.melt.cl$variable[match(resultmhc.final.cl.unique$HLA.allele, HLA.melt.cl$value)]
  
  rbindTable <- data.frame()
  for (HLAgroup in unique(resultmhc.final.cl.unique$HLA.group)){
    HLAroot <- paste(strsplit(HLAgroup, '-')[[1]][1], strsplit(HLAgroup, '-')[[1]][2], sep = "-")
    if (length(unique(resultmhc.final.cl.unique$HLA.allele[grepl(HLAroot,resultmhc.final.cl.unique$HLA.group)])) == 1){
      rbindTable.temp <- resultmhc.final.cl.unique[resultmhc.final.cl.unique$HLA.group == HLAgroup, ]
      rbindTable.temp$HLA.group <- gsub("1","2",rbindTable.temp$HLA.group)
      rbindTable <- rbind(rbindTable, rbindTable.temp)
    }
  }
  
  resultmhc.final.cl.unique <- rbind(resultmhc.final.cl.unique, rbindTable)
  
  averageHLA.melt <- aggregate(. ~ file_label, resultmhc.final.cl.unique[,c('file_label', 'totalBA', 'ifBA', 'oofBA')], FUN=mean) 
  averageHLA.melt <- averageHLA.melt[order(-averageHLA.melt$totalBA),]
  
  resultmhc.final.cl.unique$file_label <- factor(resultmhc.final.cl.unique$file_label, levels = averageHLA.melt$file_label)
  
  heatmapdata <- resultmhc.final.cl.unique[,c('file_label','HLA.group', 'totalBA', 'ifBA', 'oofBA')]
  #Cutting the data to be able to make a categorical scale so that 50 nM and 500 nM can be highlighted. 
  
  heatmapdata = heatmapdata %>%
    group_by(file_label) %>%
    complete(HLA.group = unique(heatmapdata$HLA.group))
  
  heatmapdata[is.na(heatmapdata)] <- 25000
  
  heatmapdata$file_label.simp <- sapply(heatmapdata$file_label, function(x) paste(annotatedcufftranscripts.cand.cl$subfamTE[annotatedcufftranscripts.cand.cl$uniqid == x], annotatedcufftranscripts.cand.cl$gene2[annotatedcufftranscripts.cand.cl$uniqid == x],sep = "_"))
  
  scalelimits <- c(0.0,50.0,500.0,20000,25001.0)
  setTimeLimit(cpu = Inf, elapsed = Inf, transient = FALSE)
  setSessionTimeLimit(cpu = Inf, elapsed = Inf)
  
  color_palette <- colorRampPalette(c("darkblue","white"))(4)
  
  heatmapdata$nMcattotal <- cut(heatmapdata$totalBA,breaks = c(0.0,50.0,500.0,20000,25000.0),right = TRUE)
  
  heatmapdata.labels <- unique(heatmapdata[c('file_label', 'file_label.simp')])
  
  p1 <- ggplot(heatmapdata, aes(file_label, HLA.group)) + geom_tile(aes(fill = nMcattotal),colour = "black") + scale_fill_manual(values=color_palette, labels=c("<50", "<500", "WB", "NP"))
  p1 <- p1 + scale_x_discrete(expand = c(0, 0), labels = heatmapdata.labels$file_label.simp[order(heatmapdata.labels$file_label)]) + scale_y_discrete(expand = c(0, 0))
  p1 <- p1 + labs(title=paste0(currentCellLine), fill = expression(paste(IC[50],"(nM)")))
  p1 <- p1 + theme_bw() + theme(axis.text.x=element_text(angle=30,hjust=1,size = 8), 
                                axis.title.x = element_blank(),
                                axis.title.y = element_blank(),
                                text = element_text(size=12)) + coord_fixed(ratio = 1) 
  heatmapplotLists[[i]] <- p1
  i = i + 1
  
}
```

```{r}
currentCellLines <- c("B36", "B49", "B66", "hFB", "NHA")
i = 1

for (currentCellLine in currentCellLines){
  ggsave(paste0("./plots/",currentCellLine,"_heatmap.pdf"), heatmapplotLists[[i]], height = 3, width = 18, device = cairo_pdf())
  i = i + 1
}
```

## UpSetR
```{r}
library(UpSetR)

CL.List <- list(B36 = transcriptPeakTable$transcriptname[transcriptPeakTable$B36_antigenic],
                B49 = transcriptPeakTable$transcriptname[transcriptPeakTable$B49_antigenic],
                B66 = transcriptPeakTable$transcriptname[transcriptPeakTable$B66_antigenic],
                hFB = transcriptPeakTable$transcriptname[transcriptPeakTable$hFB_antigenic],
                NHA = transcriptPeakTable$transcriptname[transcriptPeakTable$NHA_antigenic])

upsetAntigenic <- upset(fromList(CL.List), order.by = "freq", mainbar.y.label = "Antigen Intersections", sets.x.label = "Antigenic Candidates\nper Cell Line",  mb.ratio = c(0.55, 0.45))

CairoPDF(file="./plots/AntigenicUpset.pdf", width = 12, height = 3)
upsetAntigenic 
dev.off()


```


#Mapping the cell lines to the transcripts

```{r}
rnaFileNames <- unique(fracexpressiontable.m$TranscriptID)

cageConversion <- as.character(sapply(rnaFileNames, function(x) {
  splitString <- strsplit(x,"_")[[1]]
  cellLine <- splitString[3]
  treatment <- splitString[4]
  if (grepl("DAC", treatment)){
    treatmentPaste <- "DP"
  } else {
    treatmentPaste <- "DMSO"
  }
  
  if (cellLine == "shFB"){
    cellLinePaste <- "QhFB"
  } else if (cellLine == "hFB"){
    cellLinePaste <- "hFB"
  } else if (cellLine == "qNHA"){
    cellLinePaste <- "QNHA"
  } else {
    cellLinePaste <- cellLine
  }
  
  return(paste0(cellLinePaste,"_",treatmentPaste))
}))

fracexpressiontable.m$cageLabel <- cageConversion[match(fracexpressiontable.m$TranscriptID, rnaFileNames)]

```

```{r}
indexMatch <- match(transcriptPeakTable$clusterPeak, b36.cagadata$consensus.cluster)

transcriptPeakTable$B36_DP <- b36.cagadata$B36_DP[indexMatch]
transcriptPeakTable$B36_DMSO <- b36.cagadata$B36_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, b49.cagadata$consensus.cluster)

transcriptPeakTable$B49_DP <- b49.cagadata$B49_DP[indexMatch]
transcriptPeakTable$B49_DMSO <- b49.cagadata$B49_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, b66.cagadata$consensus.cluster)

transcriptPeakTable$B66_DP <- b66.cagadata$B66_DP[indexMatch]
transcriptPeakTable$B66_DMSO <- b66.cagadata$B66_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, hfb.cagadata$consensus.cluster)

transcriptPeakTable$hFB_DP <- hfb.cagadata$hFB_DP[indexMatch]
transcriptPeakTable$hFB_DMSO <- hfb.cagadata$hFB_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, qhfb.cagadata$consensus.cluster)

transcriptPeakTable$QhFB_DP <- qhfb.cagadata$QhFB_DP[indexMatch]
transcriptPeakTable$QhFB_DMSO <- qhfb.cagadata$QhFB_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, nha.cagadata$consensus.cluster)

transcriptPeakTable$NHA_DP <- nha.cagadata$NHA_DP[indexMatch]
transcriptPeakTable$NHA_DMSO <- nha.cagadata$NHA_DMSO[indexMatch]

indexMatch <- match(transcriptPeakTable$clusterPeak, qnha.cagadata$consensus.cluster)

transcriptPeakTable$QNHA_DP <- qnha.cagadata$QNHA_DP[indexMatch]
transcriptPeakTable$QNHA_DMSO <- qnha.cagadata$QNHA_DMSO[indexMatch]
```

```{r}
fracexpressiontable.m$cageExpression <- apply(fracexpressiontable.m[,c("variable","cageLabel")], 
                                           1,
                                           function(x){
                                             if (x[1] %in% transcriptPeakTable$transcriptname){
                                               return(transcriptPeakTable[transcriptPeakTable$transcriptname == x[1],c(x[2])])
                                             } else {
                                               return(0)
                                             }
                                           })

fracexpressiontable.m$cagepresent <- fracexpressiontable.m$cageExpression >= 1
```



# Endogenous TITEA Expression Analysis

We will be generating MHC pulldown data for B49 and B66. We want to first do a method that matches what other epople do to find TE peptides where they will just translate the repeatmasker sequence. We will then augment this strategy with proper annotation and expression quantification of ERVs. 

```{r}
pathRoot <- "/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/squireOut/squire_call_"

#GSC squire file names

gscLines <- c("B36", "B49", "B66", "NHA", "qNHA", "hFB", "shFB")

firstTime = TRUE

for (gscLine in gscLines){
  
  
  subfamTable <- read.delim(paste0(pathRoot, gscLine, "_subfam"), header = TRUE)
  subfamTable$cLine <- rep(gscLine, nrow(subfamTable))
  subfamTable$teLabel <- row.names(subfamTable)
  
  if (firstTime == TRUE){
    subfamTableFinal <- subfamTable
    firstTime = FALSE
  } else {
    subfamTableFinal <- rbind(subfamTableFinal, subfamTable)
  }
}

```

This will import the subfamlies that are upregulated in B66 and B49
```{r}
upSubfamTable <- read.delim('/scratch/jmaeng/GSC_JoshNakul/for_Nakul/Enriched_TEsubfam_B49_B66_RNA_SQUIRE/EnrichedTEsubfam.either_B49_B66.RNA_SQUIRE.txt', header= TRUE, stringsAsFactors = FALSE, sep = '\t')

write(upSubfamTable$TEsubfam, 'subfamanalysis.txt')
```

Already transplated all TEs and able to generate 113432860 potential peptides.
Subsetting from the subfmailies that were upregulated got us to 2428528. In addition, this we did not force the peptides to start with methionine since we are not sure what the transcripts that include these sequences look like. 

```{bash echo=F, eval=F}
grep -F -f subfamanalysis.txt ~/reference/repeatmasker/hg38/result_rmsk-single_l7_e_multi.txt > subfamUpPeptides.txt
```

```{r}

te_translation_table <- read.delim('subfamUpPeptides.txt', header= FALSE, stringsAsFactors = FALSE, sep = ' ')
colnames_trans <- c('subfam',
                    'chromosome',
                    'start',
                    'end',
                    'strand',
                    'dnalength',
                    'direction',
                    'frame',
                    'proteinstart',
                    'proteinend',
                    'proteinlength',
                    'proteinseq')
colnames(te_translation_table) <- colnames_trans
```

```{r}
minlimit = 0
p <- ggplot(te_translation_table, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(te_translation_table$proteinlength), by=25), aes(fill=direction), col="black") + 
  labs(title="Size of Peptides Detected", x="Size of Peptide (AA)", y="Number of TE-peptides") + 
  scale_fill_manual(values = c('darkblue','red')) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_',minlimit,'.pdf'),p,width = 8, height = 8, device = cairo_pdf)


minlimit = 50
p <- ggplot(te_translation_table, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(te_translation_table$proteinlength), by=25), aes(fill=direction), col="black") + 
  labs(title="Size of Peptides Detected", x="Size of Peptide (AA)", y="Number of TE-peptides") + 
  scale_fill_manual(values = c('darkblue','red')) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_',minlimit,'.pdf'),p,width = 8, height = 8, device = cairo_pdf)

minlimit = 250
graphtable <- te_translation_table[te_translation_table$proteinlength > minlimit,]
p <- ggplot(graphtable, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(graphtable$proteinlength), by=25), aes(fill=direction), col="black") + 
  labs(title="", x="", y="") + 
  scale_fill_manual(values = c('darkblue','red'), guide = FALSE) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_',minlimit,'.pdf'),p,width = 6, height = 6, device = cairo_pdf)

#te_translation_table$presence <- apply(te_translation_table[,c('subfam','proteinseq')],1, function(x) sum(grepl(x[2], te_translation_table$proteinseq)))


```

```{r}

TEreftable <- read.delim("/bar/nshah/reference/repeatmasker/hg38/repeatmasker_description_uniq_TE.lst", skip=1, header=FALSE, stringsAsFactors = FALSE)
TEreftable <- TEreftable[,c('V1','V2')]

indexsubfams <- match(te_translation_table$subfam, TEreftable$V1)
TEclass_v1 <- TEreftable$V2[indexsubfams]
te_translation_table$class <- TEclass_v1
te_translation_table$class <- factor(te_translation_table$class)

colorPallete <- c('darkblue','grey','green3','purple','black', 'red')
names(colorPallete) <- c("DNA", "LINE", "LTR", "Retroposon", "Satellite", "SINE")

minlimit = 0
p <- ggplot(te_translation_table, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(te_translation_table$proteinlength), by=25), aes(fill=class), col="black") + 
  labs(title="Size of Peptides Detected", x="Size of Peptide (AA)", y="Number of TE-peptides") + 
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = colorPallete) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_class_',minlimit,'.pdf'),p,width = 8, height = 8, device = cairo_pdf)

minlimit = 50
p <- ggplot(te_translation_table, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(te_translation_table$proteinlength), by=25), aes(fill=class), col="black") + 
  labs(title="Size of Peptides Detected", x="Size of Peptide (AA)", y="Number of TE-peptides") + 
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_manual(values = colorPallete) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_class_',minlimit,'.pdf'),p,width = 8, height = 8, device = cairo_pdf)

minlimit = 250
graphtable <- te_translation_table[te_translation_table$proteinlength > minlimit,]
p <- ggplot(graphtable, aes(proteinlength)) + 
  geom_histogram(breaks = seq(minlimit, max(graphtable$proteinlength), by=25), aes(fill=class), col="black") + 
  labs(title="", x="", y="") + 
  scale_fill_manual(values = colorPallete, guide = FALSE) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0, 0)) +
  theme_classic() + 
  theme() + 
  geom_vline(aes(xintercept=mean(proteinlength)), alpha = .5)
p

ggsave(paste0('TE_proteins_class_',minlimit,'.pdf'),p,width = 6, height = 6, device = cairo_pdf)

```

The previous analysis made me think it would be worth it to get teh length of each class
```{r}
aggregatelength <- aggregate(. ~ class,te_translation_table[,c('class','dnalength')] , FUN = length)

```

Seeing how many are unique. We see that there 1923830

```{r}
te_translation_table <- te_translation_table[order(te_translation_table$proteinseq),]
te_translation_table$duplicated <- duplicated(te_translation_table$proteinseq)

te_translation_table.u <- te_translation_table[!te_translation_table$duplicated,]

uniqueProteinSequences <- te_translation_table.u$proteinseq

library('snow')
clus <- makeCluster(14)

clusterExport(clus, "uniqueProteinSequences", envir = .GlobalEnv)
resultsinitial <- parSapply(clus,uniqueProteinSequences, function(x) sum(grepl(x, uniqueProteinSequences, fixed = TRUE)))

stopCluster(clus)
save.image("nanoCAGE_2.RData")

resultsinitial.num <- as.numeric(resultsinitial)

te_translation_table.u$encompassnum <- resultsinitial.num 
te_translation_table.u.e <- te_translation_table.u[te_translation_table.u$encompassnum <= 1,]

te_translation_table.u.e$TEid <- paste(te_translation_table.u.e$subfam, te_translation_table.u.e$chromosome, te_translation_table.u.e$start, te_translation_table.u.e$end, te_translation_table.u.e$strand, sep = '_')

te_translation_table.u.e$Pepid <- paste(te_translation_table.u.e$TEid, te_translation_table.u.e$direction, te_translation_table.u.e$frame, te_translation_table.u.e$proteinstart, te_translation_table.u.e$proteinend, sep = '_')
```

```{r}
fastaoutputvector.result <- apply(te_translation_table.u.e[,c("Pepid","subfam","proteinseq")],
                                  1,
                                  function(x){
                                    labelhere <-  paste0(">tr|",x[1],"|",x[1],"_HUMAN_both ",x[1],"_HUMAN_both OS=Homo sapiens OX=9606 GN=",x[2])
                                    return(c(labelhere, x[3]))
                                  })



fastaoutputvector <- as.vector(fastaoutputvector.result)
  
fileConn<-file("05062022_TEAntigens_GSC.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash echo=F, eval=F}
cat <(cat uniprot-proteome_2_sl.fasta) <(cat /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/05062022_TEAntigens_GSC.fa) <(cat /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/candidates_proteinseq_unfiltered.fa) > uniprot-proteome_2_sl_GSCProject_wTE_05062022.fasta
```


##Mass Spec Analysis with just the TE-gene chimeric transcript antigens

```{r}
RunGSC_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TCGAAntigen/LC_MS_012820_GBM/peptides.txt', header = TRUE, stringsAsFactors = FALSE)

RunGSC_MHCProteome_FDR05 <- RunGSC_MHCProteome_FDR05[!grepl('CON_|REV',RunGSC_MHCProteome_FDR05$Proteins),]
RunGSC_MHCProteome_FDR05 <- RunGSC_MHCProteome_FDR05[!grepl('CON_|REV',RunGSC_MHCProteome_FDR05$Leading.razor.protein),]

RunGSC_MHCProteome_FDR05$TECand <- grepl('_both|_og|_cpc2', RunGSC_MHCProteome_FDR05$Proteins)

RunGSC_MHCProteome_FDR05$uniqueToCand <- apply(RunGSC_MHCProteome_FDR05[,c("Sequence", "Proteins")], 1, function(x){
  splitvec <- strsplit(x[2],';')[[1]]
  if (length(splitvec) == sum(grepl('_both|_og|_cpc2', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})

RunGSC_MHCProteome_FDR05.fil <- RunGSC_MHCProteome_FDR05[RunGSC_MHCProteome_FDR05$uniqueToCand == "yes",]

```

###Graph some data on peptides

```{r}
library(ggplot2)

RunGSC_MHCproteome_100 <- RunGSC_MHCProteome_FDR05

p1 <- ggplot(RunGSC_MHCproteome_100, aes(Length)) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Peptide Length") +
  ylab("Number of Peptides") +
  labs(title="RunGSC HLA Proteome") +
  theme_classic()
p1

p2  <- ggplot(RunGSC_MHCproteome_100, aes(as.numeric(Charges))) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Charges") +
  ylab("Number of Peptides") +
  labs(title="RunGSC HLA Proteome") +
  theme_classic()
p2


masses <- c()
charges <- c()
lengths <- c()

currenttable <- RunGSC_MHCproteome_100

i = 1
for (chargeText in currenttable$Charges){
  if (chargeText == ""){
    i = i + 1
    next
  }
  
  if (grepl(";",chargeText)){
    chargevec <- strsplit(chargeText,";")[[1]]
    
    for (chargevalue in chargevec){
      masses <- c(masses, currenttable$Mass[i])
      charges <- c(charges, as.numeric(chargevalue))
      lengths <- c(lengths, currenttable$Length[i])
    }
  } else{
    masses <- c(masses, currenttable$Mass[i])
    charges <- c(charges, as.numeric(chargeText))
    lengths <- c(lengths, currenttable$Length[i])
  }
  i = i + 1
}

RunGSC_MHCstats <- data.frame(masses = masses, charges = charges, lengths = lengths)

p3 <- ggplot(RunGSC_MHCstats, aes(x=masses/charges, fill = factor(charges))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSC HLA Proteome Mass/charge | Charge Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p3

p4 <- ggplot(RunGSC_MHCstats, aes(x=masses/charges, fill = factor(lengths))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSC HLA Proteome Mass/charge | Length Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p4


#Create a peptide format file that can be fed into netmhc pan

#Only peptides that are greater than 7AA in length should be considered. netMHCpan will break with 7 or below
fileConn<-file("sequences.peptide")
writeLines(RunGSC_MHCproteome_100$Sequence[RunGSC_MHCproteome_100$Length > 7], fileConn)
close(fileConn)
```

```{r}
library(gridExtra)

a375_grob <- arrangeGrob(p1, p2, p3, p4, ncol=2)

ggsave("RunGSC_mass_spec_stats.pdf",a375_grob, width=12, height = 8, device = cairo_pdf())
```


```{r}

sampleNames <- colnames(RunGSC_MHCProteome_FDR05)[grepl('LFQ.intensity.',colnames(RunGSC_MHCProteome_FDR05))]

sampleCounts <- sapply(sampleNames, function(x) sum(RunGSC_MHCProteome_FDR05[,x[1]] > 0))

df.Samples <- data.frame(sampleNames, sampleCounts)

df.Samples$labels <- c('B49_DMSO_Brep1',
                      'B49_DACPano_Brep1',
                      'B66_DACPano_Brep1',
                      'B66_DACPano_Brep2',
                      'B49_DACPano_Brep2',
                      'B49_DACPano_Brep3',
                      'B49_DMSO_Brep2',
                      'B49_DMSO_Brep3',
                      'B66_DACPano_Brep3',
                      'B66_DMSO_Brep1',
                      'B66_DMSO_Brep2',
                      'B66_DMSO_Brep3')

p <- ggplot(df.Samples,aes(labels, sampleCounts)) + 
  geom_bar(stat='identity', color = "black", fill = "orchid") + 
  theme_classic() + 
  labs(x = "Sample", y = "Number of Peptides\nRecovered") +
  theme(axis.text.x = element_text(angle=90))

p

ggsave("Peptides_per_Cell_Line.pdf",p, width = 8, height = 5, device = cairo_pdf)
```

```{r}
#Convert the column names with presence information to the correct one

colNameToCellLine <- data.frame(colName = c('Experiment.107_Josh_MHC_B49_DMSO_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B49_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep3',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DACPANO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep1',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep2',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep3'),
                                cellLine = c('B49_DMSO',
                                             'B49_DP',
                                             'B66_DP',
                                             'B66_DP',
                                             'B49_DP',
                                             'B49_DP',
                                             'B49_DMSO',
                                             'B49_DMSO',
                                             'B66_DP',
                                             'B66_DMSO',
                                             'B66_DMSO',
                                             'B66_DMSO'),
                                stringsAsFactors = FALSE)
```


Begin to create the dataframe that will be tested. 

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(RunGSC_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- RunGSC_MHCProteome_FDR05.fil$Sequence[i]
  candidateProteins <- strsplit(RunGSC_MHCProteome_FDR05.fil$Proteins[i],';')[[1]]
  numProteins <- length(candidateProteins)
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
  }
  
  presentColumns <- colNameExperiment[!is.na(RunGSC_MHCProteome_FDR05.fil[i,colNameExperiment])]
  
  numberSamples <- length(presentColumns)
  
  Peptides <- rep(Peptides, numberSamples)
  Candidate <- rep(Candidate, numberSamples)
  UniqMultiple <- rep(UniqMultiple, numberSamples)
  Samples <- sort(rep(presentColumns, numProteins))
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSC.table <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("Maxquant", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSC.table$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSC.table$sample, colNameToCellLine$colName)]
```

```{r}
pfindGSC_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TCGAAntigen/LC_MS_012820_GBM/all_result.txt', header = TRUE, stringsAsFactors = FALSE)

pfindGSC_MHCProteome_FDR05 <- pfindGSC_MHCProteome_FDR05[!grepl('CON_|REV',pfindGSC_MHCProteome_FDR05$Protein.AC),]

pfindGSC_MHCProteome_FDR05$TECand <- grepl('_both|_og|_cpc2', pfindGSC_MHCProteome_FDR05$Protein.AC)

pfindGSC_MHCProteome_FDR05$uniqueToCand <- apply(pfindGSC_MHCProteome_FDR05[,c("Sq", "Protein.AC")], 1, function(x){
  splitvec <- strsplit(x[2],'/')[[1]]
  if (length(splitvec) == sum(grepl('_both|_og|_cpc2', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})
pfindGSC_MHCProteome_FDR05.fil <- pfindGSC_MHCProteome_FDR05[pfindGSC_MHCProteome_FDR05$uniqueToCand == "yes",]
```

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(pfindGSC_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- pfindGSC_MHCProteome_FDR05.fil$Sq[i]
  candidateProteins <- strsplit(pfindGSC_MHCProteome_FDR05.fil$Protein.AC[i],'\\/')[[1]]
  numProteins <- length(candidateProteins)
  sample <- strsplit(pfindGSC_MHCProteome_FDR05.fil$Title[i],"\\.")[[1]][1]
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
    Samples <- c(Samples,sample)
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
    Samples <- c(Samples,rep(sample, numProteins))
  }
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSC.table.pf <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("pFind", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSC.table.pf$sample <- gsub("20200","Experiment.",massSpecPeptide.GSC.table.pf$sample)
massSpecPeptide.GSC.table.pf$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSC.table.pf$sample, colNameToCellLine$colName)]

massSpecPeptide.GSC.table <- rbind(massSpecPeptide.GSC.table, massSpecPeptide.GSC.table.pf)
```




```{r}

massSpecPeptide.GSC.table$uniqid <- sapply(massSpecPeptide.GSC.table$protein, function(x){
  if(grepl('_cpc2|_og|_both',x)){
    tempstring <- strsplit(x,'\\|')[[1]][2]
    return(gsub('_cpc2|_og|_both', '', tempstring))
  } else{
    return("None")
  }
})

massSpecPeptide.GSC.table$inframe <- apply(massSpecPeptide.GSC.table[,c("protein", "uniqid")], 1, function(x){
  if(grepl('_cpc2|_og|_both',x[1])){
      if(grepl('_cpc2|_both',x[1])){
        return(as.character(annotatedcufftranscripts.fil$cpc2_type)[annotatedcufftranscripts.fil$uniqid == x[2]])
      } else{
        return(as.character(annotatedcufftranscripts.fil$type)[annotatedcufftranscripts.fil$uniqid == x[2]])
      }
  } else{
    return("None")
  }
})

massSpecPeptide.GSC.table$cageTPM <- apply(massSpecPeptide.GSC.table[,c('uniqid',
                                                                         'sampleclean')],
                                            1,
                                            function(x){
                                              return(fracexpressiontable.m$cageExpression[fracexpressiontable.m$uniqid == x[1] &
                                                                                        fracexpressiontable.m$cageLabel == x[2]][1])
                                            })

massSpecPeptide.GSC.table$cagePresence <- massSpecPeptide.GSC.table$cageTPM >= 1

massSpecPeptide.GSC.table$consensus.cluster <- transcriptPeakTable$clusterPeak[match(massSpecPeptide.GSC.table$uniqid, transcriptPeakTable$uniqid)]

#This will store the max DAC value for the GBM cell line
massSpecPeptide.GSC.table$DACmax <- sapply(massSpecPeptide.GSC.table$consensus.cluster, function(x){
  return(max(b36.cagadata$B36_DP[b36.cagadata$consensus.cluster == x],
         b49.cagadata$B49_DP[b49.cagadata$consensus.cluster == x],
         b66.cagadata$B66_DP[b66.cagadata$consensus.cluster == x]))
})

#This will store teh max DMSO value for the GBM cell lines
massSpecPeptide.GSC.table$DMSOmax <- sapply(massSpecPeptide.GSC.table$consensus.cluster, function(x){
  return(max(b36.cagadata$B36_DMSO[b36.cagadata$consensus.cluster == x],
         b49.cagadata$B49_DMSO[b49.cagadata$consensus.cluster == x],
         b66.cagadata$B66_DMSO[b66.cagadata$consensus.cluster == x]))
})

#This will store the max value in the Quiescent cell lines
massSpecPeptide.GSC.table$DACmaxQuiescent <- sapply(massSpecPeptide.GSC.table$consensus.cluster, function(x){
  return(max(qnha.cagadata$QNHA_DP[qnha.cagadata$consensus.cluster == x],
         qhfb.cagadata$QhFB_DP[qhfb.cagadata$consensus.cluster == x]))
})

```

```{r}
uniquePepSeq <- unique(massSpecPeptide.GSC.table$sequence)

fastaoutputvector <- c()

for (i in 1:length(uniquePepSeq)){
  fastaoutputvector <- c(fastaoutputvector, paste0(">CAND_",uniquePepSeq[i]))
  fastaoutputvector <- c(fastaoutputvector,uniquePepSeq[i])
}

fileConn<-file("uniquePeptidesCandidates.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash}
nshah@budweiser:/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal$ blat ~/reference/genomefasta/GRCh38.d1.vd1.fa uniquePeptidesCandidates.fa out.psl -t=dnax -q=prot -minScore=0 -tileSize=5 -stepSize=1 -minIdentity=5 -repMatch=10000000 ; cat out.psl | awk '{if($1==$11){print}}' > out.filtered.psl
```

```{r}
blat.result <- read.delim("out.filtered.psl", header = FALSE, sep = "\t")

blat.result <- blat.result[blat.result$V18 == 1,]

blat.result$location <- paste0(blat.result$V14,':',blat.result$V16,'-',blat.result$V17)

table.blat.result <- as.data.frame(table(blat.result$V10))

table.blat.result$peptide <- gsub('CAND_','',table.blat.result$Var1)

massSpecPeptide.GSC.table$blatNum <- table.blat.result$Freq[match(massSpecPeptide.GSC.table$sequence, table.blat.result$peptide)]

massSpecPeptide.GSC.table$blatNum[is.na(massSpecPeptide.GSC.table$blatNum)] <- 0
```

```{bash, eval = FALSE}
#Remote will increase the 
nshah@bluemoon:~/reference/blastdb$ blastp -query /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.fa -db nr -remote -task 'blastp-short' -outfmt "6 qseqid salltitles pident qcovs sstart send sscinames" > /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output 
```

Getting RNA and Protein Information In one table for candidates

Incorporating BLAST information to decide which peptides are truelly unique to a candidate

```{r}
blastResult = read.delim("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output", stringsAsFactors = FALSE, header = FALSE)

blastResult <- blastResult[blastResult$V3 == 100 & blastResult$V4 == 100 & blastResult$V7 == "Homo sapiens",]

blastResult <- blastResult[!grepl('hCG|unnamed|hypothetical',blastResult$V2),]

blastResult$peptide <- gsub("CAND_", "", blastResult$V1)

massSpecPeptide.GSC.table$blastdetected <- massSpecPeptide.GSC.table$sequence %in% blastResult
```

```{r}
massSpecPeptide.GSC.table.u <-  unique(massSpecPeptide.GSC.table[,c("sequence", "protein", "uniqmulti", "inframe", "blatNum", "DACmax", "DMSOmax", "DACmaxQuiescent")])

massSpecPeptide.GSC.table.u$B49_DMSO <- apply(massSpecPeptide.GSC.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "B49_DMSO")
                                                    })

massSpecPeptide.GSC.table.u$B49_DP <- apply(massSpecPeptide.GSC.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "B49_DP")
                                                    })

massSpecPeptide.GSC.table.u$B66_DMSO <- apply(massSpecPeptide.GSC.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "B66_DMSO")
                                                    })

massSpecPeptide.GSC.table.u$B66_DP <- apply(massSpecPeptide.GSC.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "B66_DP")
                                                    })

massSpecPeptide.GSC.table.u$method <- apply(massSpecPeptide.GSC.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  pFind <- sum(massSpecPeptide.GSC.table$method[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "pFind")
                                                  Maxquant <- sum(massSpecPeptide.GSC.table$method[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2]] == "Maxquant")
                                                  if (pFind > 0 & Maxquant > 0){
                                                    return("Both")
                                                  } else if (pFind > 0){
                                                    return("pFind")
                                                  } else if (Maxquant > 0){
                                                    return("Maxquant")
                                                  }
                                                    })
```

Add in information about the peak actually being regarded as being upregulated in the analysis. 

```{r}
massSpecPeptide.GSC.table.u$uniqid <- massSpecPeptide.GSC.table$uniqid[match(massSpecPeptide.GSC.table.u$protein,
                                                                             massSpecPeptide.GSC.table$protein)]

massSpecPeptide.GSC.table.u$B49_actived <- transcriptPeakTable$B49_activated[match(massSpecPeptide.GSC.table.u$uniqid,
                                                                                   transcriptPeakTable$uniqid)]
massSpecPeptide.GSC.table.u$B66_actived <- transcriptPeakTable$B66_activated[match(massSpecPeptide.GSC.table.u$uniqid,
                                                                                   transcriptPeakTable$uniqid)]
```

```{r}
massSpecPeptide.GSC.table.u$blastFound <- sapply(massSpecPeptide.GSC.table.u$sequence,
                                                 function(x) return(x %in% massSpecPeptide.GSC.table$sequence[massSpecPeptide.GSC.table$blastdetected]))

massSpecPeptide.GSC.table.u.bf <-  massSpecPeptide.GSC.table.u[massSpecPeptide.GSC.table.u$blastFound == FALSE,]
```

```{r}
massSpecPeptide.GSC.table.u.bf$B49_DMSO_GS <- apply(massSpecPeptide.GSC.table.u.bf[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2] & massSpecPeptide.GSC.table$cageTPM >= 1] == "B49_DMSO")
                                                    })

massSpecPeptide.GSC.table.u.bf$B49_DP_GS <- apply(massSpecPeptide.GSC.table.u.bf[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2] & massSpecPeptide.GSC.table$cageTPM >= 1] == "B49_DP")
                                                    })

massSpecPeptide.GSC.table.u.bf$B66_DMSO_GS <- apply(massSpecPeptide.GSC.table.u.bf[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2] & massSpecPeptide.GSC.table$cageTPM >= 1] == "B66_DMSO")
                                                    })

massSpecPeptide.GSC.table.u.bf$B66_DP_GS <- apply(massSpecPeptide.GSC.table.u.bf[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSC.table$sampleclean[massSpecPeptide.GSC.table$sequence == x[1] & massSpecPeptide.GSC.table$protein == x[2] & massSpecPeptide.GSC.table$cageTPM >= 1] == "B66_DP")
                                                    })
```



#Figure Generation
Creating the figures that will be in the final paper

```{r}
cellLines <- c("B49 DMSO", "B49 DP", "B66 DMSO", "B66 DP")

GBMAntigenNumbers <- data.frame(CL = cellLines,
                           `Total Number` = c(sum(fracexpressiontable.m$cageExpression >= 1 & fracexpressiontable.m$cageLabel == "B49_DMSO"),
                                              sum(fracexpressiontable.m$cageExpression >= 1 & fracexpressiontable.m$cageLabel == "B49_DP"),
                                            sum(fracexpressiontable.m$cageExpression >= 1 & fracexpressiontable.m$cageLabel == "B66_DMSO"),
                                              sum(fracexpressiontable.m$cageExpression >= 1 & fracexpressiontable.m$cageLabel == "B66_DP")),
                           `MS Detected` = c(length(unique(massSpecPeptide.GSC.table.u$sequence[massSpecPeptide.GSC.table.u$B49_DMSO > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u$sequence[massSpecPeptide.GSC.table.u$B49_DP > 0])),
                                            length(unique(massSpecPeptide.GSC.table.u$sequence[massSpecPeptide.GSC.table.u$B66_DMSO > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u$sequence[massSpecPeptide.GSC.table.u$B66_DP > 0]))),
                           `BLAST Filter` = c(length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DMSO > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DP > 0])),
                                            length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B66_DMSO > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B66_DP > 0]))),
                           `Genomic Support` = c(length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DMSO_GS > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DP_GS > 0])),
                                            length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B66_DMSO_GS > 0])),
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B66_DP_GS > 0]))),
                           `Not DMSO` = c(NA,
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DP_GS > 0 & massSpecPeptide.GSC.table.u.bf$B49_DMSO == 0 & massSpecPeptide.GSC.table.u.bf$B66_DMSO == 0])),
                                            NA,
                                              length(unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B66_DP_GS > 0 & massSpecPeptide.GSC.table.u.bf$B49_DMSO == 0 & massSpecPeptide.GSC.table.u.bf$B66_DMSO == 0]))))
```

```{r}
GBMAntigenNumbers.m <- melt(GBMAntigenNumbers, id.vars = c('CL'))

## Set the orders so that we get the correct positioning of the dots within the matrix
orderLabels <- colnames(GBMAntigenNumbers)[2:length(colnames(GBMAntigenNumbers))]

GBMAntigenNumbers.m$variable <- factor(GBMAntigenNumbers.m$variable, levels = orderLabels)

GBMAntigenNumbers.m$CL <- factor(GBMAntigenNumbers.m$CL, levels = rev(cellLines))
```


```{r}
segment.df <- data.frame(x = c(1,1,1,1,1),
                         y = c(1,1,2,3,4),
                         xends = c(1,5,4,5,4),
                         yends = c(4,1,2,3,4))
```

```{r}
p1 <- ggplot(GBMAntigenNumbers.m, aes(x = variable, y = CL)) +
  geom_point(alpha = 0) +
  geom_segment(data = segment.df, aes(x = x,y = y,xend = xends, yend = yends), alpha = .5) +
  geom_point(aes(size = value), shape = 21, color = "black", fill = "aliceblue") +
  geom_text(aes(label = value), size = 2.5) +
  labs(y = "", x = "") +
  scale_size_continuous(range = c(6, 12)) +
  scale_x_discrete(labels=c("Total\nNo. Peaks", "LC MS/MS\nDetected", "BLAST\nFilter", "Genomic\nSupport", "Not in\nDMSO")) +
  theme_classic() +
  theme(text = element_text(size=8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = 'none') 
p1

ggsave("./plots/F2_GBM_Antigen_DotPlot.pdf", p1, width = 3, height = 2, device = cairo_pdf)
```

```{r}
genomicSupportedPeptides <- unique(massSpecPeptide.GSC.table.u.bf$sequence[massSpecPeptide.GSC.table.u.bf$B49_DMSO_GS > 0 | massSpecPeptide.GSC.table.u.bf$B49_DP_GS > 0 | massSpecPeptide.GSC.table.u.bf$B66_DMSO_GS > 0 | massSpecPeptide.GSC.table.u.bf$B66_DP_GS > 0])

massSpecPeptide.GSC.table.gspeptides <- massSpecPeptide.GSC.table[massSpecPeptide.GSC.table$sequence %in% genomicSupportedPeptides,]

massSpecPeptide.GSC.table.gspeptides$Brep <- sapply(massSpecPeptide.GSC.table.gspeptides$sample, function(x) tail(strsplit(x,"_")[[1]], n=1))

massSpecPeptide.GSC.table.gspeptides$BrepNum <- sapply(massSpecPeptide.GSC.table.gspeptides$Brep,function(x) gsub("Brep", "", x))

massSpecPeptide.GSC.table.gspeptides$labels <- paste0(gsub("_"," ", massSpecPeptide.GSC.table.gspeptides$sampleclean)," ",massSpecPeptide.GSC.table.gspeptides$BrepNum)

massSpecPeptide.GSC.table.gspeptides$labels <- factor(massSpecPeptide.GSC.table.gspeptides$labels, levels = c(
  "B49 DMSO 1",
  "B49 DMSO 2",
  "B49 DMSO 3",
  "B49 DP 1",
  "B49 DP 2",
  "B49 DP 3",
  "B66 DMSO 1",
  "B66 DMSO 2",
  "B66 DMSO 3",
  "B66 DP 1",
  "B66 DP 2",
  "B66 DP 3"
))

peptidePresenceTable <- as.data.frame(table(massSpecPeptide.GSC.table.gspeptides$labels,massSpecPeptide.GSC.table.gspeptides$sequence))

colnames(peptidePresenceTable) <- c("labels", "peptide", "frequency")
peptidePresenceTable$present <- sapply(peptidePresenceTable$frequency,
                                       function(x){
                                         if(x>0){
                                           return(1)
                                         } else {
                                           return(0)
                                         }
                                       })
```

```{r}
p2 <- ggplot(peptidePresenceTable, aes(labels, peptide)) +
  geom_point(aes(alpha = factor(present)), color = "black", fill = "darkorchid3", shape = 21, size = 5) +
  scale_alpha_manual(values = c(0,1)) +
  theme_classic() +
  theme(legend.position = "None",
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))
p2

ggsave("./plots/F2_GBM_Antigen_Peptide_Presence_DotPlot.pdf", p2, width = 6, height = 2.6, device = cairo_pdf)
```

#Structure Plots

Putting the plots of the structure in one place that will have the transcirpt and the lcoation of the antigen that can be hilighted throughoutthe manuscript. 


Structure Plots

I have created a set of figures that can help highlight the structure and transcript structure of candidates. I did this previously, but this new function gives a better asthetic and shows where the open reading frame is on the transcript. I want to compile it into a function so then its easier to use on any generic table of candidates and to get a large variety of plots. 


Functions to calculate the positioning of the highlighting figures. 
```{r}

getExonCoordViz <- function(structurestring, structureref){
  longvector <- c()
  chrexample <- strsplit(structurestring, ",")[[1]][2]
  strandexample <- strsplit(structurestring, ",")[[1]][1]
  elementsvec <- as.numeric(tail(strsplit(structurestring, ",")[[1]],-2))
  elementsvec <- sort(elementsvec)
  startexons <- elementsvec[c(TRUE, FALSE)]
  endexons <- elementsvec[c(FALSE, TRUE)]
  
  elementsvecRef <- as.numeric(strsplit(structureref, ",")[[1]])
  elementsvecRef <- sort(elementsvecRef)
  startexonsRef <- elementsvecRef[c(TRUE, FALSE)]
  endexonsRef <- elementsvecRef[c(FALSE, TRUE)]
  startexonsRef <- startexonsRef[c(TRUE, FALSE)]
  endexonsRef <- endexonsRef[c(TRUE, FALSE)]
  
  
  
  if(strandexample == "+"){
    currentStart = 0 #We will start at 0 and then build out the vectors to be in Exon space rather than genomic space
    i = 1
    newStartExons <- c()
    newEndExons <- c()
    labelExon <- c()
    
    ref.df <- data.frame(start = startexonsRef, end = endexonsRef)
    for (startExon in startexons){
      
      diffExon <- endexons[i] - startExon + 1
      newStartExons <- c(newStartExons, currentStart)
      newEndExons <- c(newEndExons, currentStart + diffExon)
      currentStart <- currentStart + diffExon
      
      anyoverlap <- apply(ref.df[,c('start','end')], 1, function(x) as.numeric(max(0,min(endexons[i],x[2])-max(startExon,x[1]))))
      if (sum(anyoverlap) > 0){
        labelExon <- c(labelExon, "reference")
      } else {
        labelExon <- c(labelExon, "novel")
      }
      
      i = i + 1
    }
  } else if(strandexample == "-"){
    currentStart = 0 #We will start at 0 and then build out the vectors to be in Exon space rather than genomic space
    
    startexons <- rev(startexons)
    endexons <- rev(endexons)
    labelExon <- c()
    
    i = 1
    newStartExons <- c()
    newEndExons <- c()
    
    ref.df <- data.frame(start = startexonsRef, end = endexonsRef)
    for (startExon in startexons){
      
      diffExon <- endexons[i] - startExon + 1
      newStartExons <- c(newStartExons, currentStart)
      newEndExons <- c(newEndExons, currentStart + diffExon)
      currentStart <- currentStart + diffExon
      
      anyoverlap <- apply(ref.df[,c('start','end')], 1, function(x) as.numeric(max(0,min(endexons[i],x[2])-max(startExon,x[1]))))
      if (sum(anyoverlap) > 0){
        labelExon <- c(labelExon, "reference")
      } else {
        labelExon <- c(labelExon, "novel")
      }
      
      i = i + 1
    }
  }

  return(data.frame(xmins = newStartExons, xmaxs = newEndExons, labels = labelExon))
}

getTEOverlap <- function(structurestring, startTE, endTE){
  totalOverlap <- 0
  chrexample <- strsplit(structurestring, ",")[[1]][2]
  strandexample <- strsplit(structurestring, ",")[[1]][1]
  elementsvec <- as.numeric(tail(strsplit(structurestring, ",")[[1]],-2))
  elementsvec <- sort(elementsvec)
  startexons <- elementsvec[c(TRUE, FALSE)]
  endexons <- elementsvec[c(FALSE, TRUE)]
  
  if(strandexample == "+"){
    currentStart = 0 #We will start at 0 and then build out the vectors to be in Exon space rather than genomic space
    i = 1
    
    for (startExon in startexons){
      
      anyoverlap <- as.numeric(max(0,min(endexons[i],endTE)-max(startExon,startTE)))
      totalOverlap <- totalOverlap + anyoverlap
      
      i = i + 1
    }
  } else if(strandexample == "-"){
    currentStart = 0 #We will start at 0 and then build out the vectors to be in Exon space rather than genomic space
    
    startexons <- rev(startexons)
    endexons <- rev(endexons)
    
    i = 1
    for (startExon in startexons){
      
      anyoverlap <- as.numeric(max(0,min(endexons[i],endTE)-max(startExon,startTE)))
      totalOverlap <- totalOverlap + anyoverlap
      
      i = i + 1
    }
  }

  return(totalOverlap)
}
```

```{r}
dir.create("structurePlots2")
dir.create("transcriptPlots")
```


```{r}
colorsTE <- c("#528d4c", "#ff8e56", "#7796ee", "#dc544d", "#f7a8a8")
names(colorsTE) <- c("LTR", "LINE", "DNA", "SINE", "Retroposon")

currentFocusTable <- annotatedcufftranscripts.fil.c
currentStrategy <- "cpc2"

for (currentTranscript in currentFocusTable$transcriptname){
  candidateTable <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname == currentTranscript,]
  
  currentColorTE <- colorsTE[names(colorsTE) == candidateTable$classTE]
  currentColorTE <- currentColorTE[[1]]
  
  vizExons <- apply(candidateTable[,c("transcoord","elements2")], 1,function(x) getExonCoordViz(x[1],x[2]))
  
  overlapTE <- getTEOverlap(candidateTable$transcoord, candidateTable$startTE, candidateTable$endTE)
  #Depending on your analysis goals, you may want a different width to height ratio 
  
  widthToHeight <- 75
  ratioAnnotation <- .75 #this is the the percentage of height of the main transcript the lower annotations should be
  
  if (currentStrategy == "cpc2"){
    currentStrongStart <- as.numeric(as.character(candidateTable$cpc2_strongstartindex))
    addLength <- nchar(candidateTable$cpc2_proteinseqfull2)*3
  } else {
    currentStrongStart <- as.numeric(as.character(candidateTable$strongstartindex))
    addLength <- nchar(candidateTable$proteinseqfull2)*3
  }
  
  annotation.df <- data.frame(xmins = c(currentStrongStart), xmaxs = c(currentStrongStart + addLength), levelNum = c(1))
  
  
  dfTranscript <- as.data.frame(vizExons[[1]])
  
  numExons <- nrow(dfTranscript)
  
  xmaxValue <- max(dfTranscript$xmaxs)
  ymaxValue <- xmaxValue/widthToHeight
  
  #Create the TE annotation table
  annotation.df.TE <- data.frame(xmins = c(0), xmaxs = c(overlapTE))
  annotation.df.TE$ymins <- -1*(ymaxValue)
  annotation.df.TE$ymaxs <- -1*(ymaxValue) + ymaxValue*ratioAnnotation
  annotation.df.TE$ymiddle <- (annotation.df.TE$ymins + annotation.df.TE$ymaxs)/2
  
  #Create an annotation for the arrows on the TE depends on orientation of TE in relation to the transcript
  
  if (candidateTable$strand == candidateTable$strandTE){
    annotation.df.TE.segment <- data.frame(xs = c(annotation.df.TE$xmaxs, overlapTE/2, overlapTE/2),
                                           ys = c(annotation.df.TE$ymiddle, annotation.df.TE$ymins, annotation.df.TE$ymaxs))
  } else {
    annotation.df.TE.segment <- data.frame(xs = c(overlapTE/2, annotation.df.TE$xmaxs, annotation.df.TE$xmaxs),
                                           ys = c(annotation.df.TE$ymiddle, annotation.df.TE$ymins, annotation.df.TE$ymaxs))
  }
  
  #Create dataframe with subfamily annotations
  annotation.df.TE.subfam <- data.frame(xs = c(annotation.df.TE$xmaxs + 1),
                               ys = c(annotation.df.TE$ymiddle),
                               label = c(as.character(candidateTable$subfamTE)),
                               stringsAsFactors = FALSE)
  
  #Create the annotation of the ORF
  annotation.df$ymins <- -1*(ymaxValue)*(annotation.df$levelNum+1)
  annotation.df$ymaxs <- -1*(ymaxValue)*(annotation.df$levelNum+1) + ymaxValue*ratioAnnotation
  annotation.df$ymiddle <- (annotation.df$ymins + annotation.df$ymaxs)/2
  
  dfTranscript$ymins <- rep(0, numExons)
  dfTranscript$ymaxs <- rep(ymaxValue, numExons)
  dfTranscript$exonnum <- seq(1,numExons)
  
  dfTranscript$xmiddle <- (dfTranscript$xmins + dfTranscript$xmaxs)/2
  dfTranscript$ymiddle <- (dfTranscript$ymins + dfTranscript$ymaxs)/2
  
  #The Text Labels for the tracks
  xposLabel = -1*xmaxValue/9
  labelTracks.df <- data.frame(xs = c(xposLabel,
                                      xposLabel,
                                      xposLabel),
                               ys = seq(ymaxValue/2, -3*ymaxValue/2, -1*ymaxValue),
                               label = c("Transcript",
                                         "TE",
                                         "ORF")
                               )
  
  #This will hold the adjustment to the hline
  adjustmentHline = 1
  
  gg_splice <- ggplot(data = dfTranscript, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs)) + 
      geom_rect(aes(fill = labels), color = "black", alpha = .85) +
      geom_text(aes(x=xmiddle, y=ymiddle, label = exonnum), color = "black") +
    geom_rect(data = annotation.df.TE, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs), color = "white", fill = currentColorTE, alpha = .95) +
    geom_polygon(data = annotation.df.TE.segment, aes(x=xs, y=ys), inherit.aes = FALSE) +
    geom_text(data=annotation.df.TE.subfam, aes(x=xs, y=ys, label = label, fontface = 3), inherit.aes = FALSE, hjust = 0) +
    geom_rect(data = annotation.df, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs), color = "white", fill = "navyblue", alpha = .95) +
    geom_segment(data = annotation.df, aes(x=xmins, xend=xmaxs, y=ymiddle, yend=ymiddle), color ="white", arrow = arrow(length = unit(0.5, "cm")),size = 1) +
      scale_fill_manual(values = c(currentColorTE, "gray94"))+
    labs(x = "Transcript Nucleotide") +
    geom_hline(yintercept = range(0-adjustmentHline,-1*ymaxValue-adjustmentHline), color = "grey42", alpha = 0.85, linetype="dashed") +
    geom_vline(xintercept = range(0), color = "black") +
    geom_text(data=labelTracks.df, aes(x=xs, y=ys, label = label), inherit.aes = FALSE, hjust = 0) +
      theme_classic() + 
    scale_x_continuous(expand = c(0,0)) +
    theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          legend.position = "none")
  
  ggsave(paste0("./transcriptPlots/","_", candidateTable$uniqid ,currentTranscript,"_",currentStrategy,"_TranscriptFigure.pdf"), gg_splice, width = 9, height = 1.8, device = cairo_pdf)
  
  baseColor = "gray94"
  newAAColor = "darkorchid3"
  tmColor = "gold"
  
  currentRow <- candidateTable
  
  
  if (currentStrategy == "cpc2"){
    newProteinSequence <- currentRow$cpc2_proteinseqfull2
    origProteinLeft <- as.numeric(as.character(currentRow$cpc2_origprotleft))
    origProteinSequence <- currentRow$orig_proteinsequence
    proteinLength <- nchar(origProteinSequence)
    newProteinStart <- proteinLength - origProteinLeft
    TypeNow <- currentRow$cpc2_type_final
  } else {
    newProteinSequence <- currentRow$proteinseqfull2
    origProteinLeft <- as.numeric(as.character(currentRow$origprotleft))
    origProteinSequence <- currentRow$orig_proteinsequence
    proteinLength <- nchar(origProteinSequence)
    newProteinStart <- proteinLength - origProteinLeft
    TypeNow <- currentRow$type_final
  }
  
  
  #Only if the final type is Normal, chimeric, or truncated will we use it
  #Pfam with domains highlighted to show what is happening ot the proteins
  if (TypeNow %in% c("chimeric normal", "chimeric truncated", "normal", "truncated")){
    xminVec <- c(0,newProteinStart)
    xmaxVec <- c(proteinLength, proteinLength)
    yminVec <- c(1,-1)
    ymaxVec <- c(2,0)
    colorVec <- c("Background", "Background")
    
    if (grepl("chimeric",TypeNow)){
      xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
      xmaxVec <- c(xmaxVec, newProteinStart)
      yminVec <- c(yminVec, -1)
      ymaxVec <- c(ymaxVec, 0)
      colorVec <- c(colorVec, "Novel AA")
    }
    
    pfam.df <- pfamDomains[pfamDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
    
    if (!is.na(pfam.df$pfam_start)){
      for(i in 1:nrow(pfam.df)){
        xminVec <- c(xminVec, pfam.df$pfam_start[i])
        xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
        yminVec <- c(yminVec, 1)
        ymaxVec <- c(ymaxVec, 2)
        colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
      }
      for(i in 1:nrow(pfam.df)){
        if(pfam.df$pfam_start[i] > newProteinStart){
          xminVec <- c(xminVec, pfam.df$pfam_start[i])
          xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
          yminVec <- c(yminVec, -1)
          ymaxVec <- c(ymaxVec, 0)
          colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
        }
      }
    }
    
    df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
    
    fam.add <- brewer.pal(n = 8, name = "Set1")
    
    if (grepl("chimeric",TypeNow)){
      colorPallete <- c(baseColor, newAAColor, fam.add[1:(length(unique(df.rect$colorVec)) - 2)])
    } else {
      colorPallete <- c(baseColor, fam.add[1:(length(unique(df.rect$colorVec)) - 1)])
    }
    
    tm.df <- tmDomains[tmDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
    
    if (!is.na(tm.df$transmembrane_domain_start)){
      for(i in 1:nrow(tm.df)){
        xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
        xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
        yminVec <- c(yminVec, 1)
        ymaxVec <- c(ymaxVec, 2)
        colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
      }
      for(i in 1:nrow(tm.df)){
        if(tm.df$transmembrane_domain_start[i] > newProteinStart){
          xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
          xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
          yminVec <- c(yminVec, -1)
          ymaxVec <- c(ymaxVec, 0)
          colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
        }
      }
      colorPallete <- c(colorPallete, tmColor)
      df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
    }
    
    gg_protein <- ggplot() + 
      geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
      scale_y_continuous(limits=c(-2,3))+
      scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
      annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = 2.3, label = currentRow$gene2) +
      annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = .3, label = paste0(currentRow$subfamTE,"-",currentRow$gene2)) +
      geom_vline(xintercept = 0, alpha = .1)+
      labs(x = "Reference Protein AA #", fill = "Key")+
      scale_fill_manual(values = colorPallete) +
      theme_classic() +
      theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          legend.position = "bottom")
    
    ggsave(paste0("./structurePlots2/",currentRow$uniqid,"_",currentStrategy,"_","pfam.pdf"), gg_protein, width = 9, height = 3.6, device = cairo_pdf)
    
    library(cowplot)
    
    pg1 <- plot_grid(gg_splice,gg_protein, ncol = 1, rel_heights = c(1/3, 2/3))
    
    ggsave2(paste0("./structurePlots2/",currentRow$uniqid,"_",currentStrategy,"_","pfam_withtranscript.pdf"), pg1, width = 9, height = 5.4, device = cairo_pdf)
  }
}
```

```{r}
currentStrategy <- "kozak"

for (currentTranscript in currentFocusTable$transcriptname){
  candidateTable <- annotatedcufftranscripts.fil.c[annotatedcufftranscripts.fil.c$transcriptname == currentTranscript,]
  
  currentColorTE <- colorsTE[names(colorsTE) == candidateTable$classTE]
  currentColorTE <- currentColorTE[[1]]
  
  vizExons <- apply(candidateTable[,c("transcoord","elements2")], 1,function(x) getExonCoordViz(x[1],x[2]))
  
  overlapTE <- getTEOverlap(candidateTable$transcoord, candidateTable$startTE, candidateTable$endTE)
  #Depending on your analysis goals, you may want a different width to height ratio 
  
  widthToHeight <- 75
  ratioAnnotation <- .75 #this is the the percentage of height of the main transcript the lower annotations should be
  
  if (currentStrategy == "cpc2"){
    currentStrongStart <- as.numeric(as.character(candidateTable$cpc2_strongstartindex))
    addLength <- nchar(candidateTable$cpc2_proteinseqfull2)*3
  } else {
    currentStrongStart <- as.numeric(as.character(candidateTable$strongstartindex))
    addLength <- nchar(candidateTable$proteinseqfull2)*3
  }
  
  annotation.df <- data.frame(xmins = c(currentStrongStart), xmaxs = c(currentStrongStart + addLength), levelNum = c(1))
  
  
  dfTranscript <- as.data.frame(vizExons[[1]])
  
  numExons <- nrow(dfTranscript)
  
  xmaxValue <- max(dfTranscript$xmaxs)
  ymaxValue <- xmaxValue/widthToHeight
  
  #Create the TE annotation table
  annotation.df.TE <- data.frame(xmins = c(0), xmaxs = c(overlapTE))
  annotation.df.TE$ymins <- -1*(ymaxValue)
  annotation.df.TE$ymaxs <- -1*(ymaxValue) + ymaxValue*ratioAnnotation
  annotation.df.TE$ymiddle <- (annotation.df.TE$ymins + annotation.df.TE$ymaxs)/2
  
  #Create an annotation for the arrows on the TE depends on orientation of TE in relation to the transcript
  
  if (candidateTable$strand == candidateTable$strandTE){
    annotation.df.TE.segment <- data.frame(xs = c(annotation.df.TE$xmaxs, overlapTE/2, overlapTE/2),
                                           ys = c(annotation.df.TE$ymiddle, annotation.df.TE$ymins, annotation.df.TE$ymaxs))
  } else {
    annotation.df.TE.segment <- data.frame(xs = c(overlapTE/2, annotation.df.TE$xmaxs, annotation.df.TE$xmaxs),
                                           ys = c(annotation.df.TE$ymiddle, annotation.df.TE$ymins, annotation.df.TE$ymaxs))
  }
  
  #Create dataframe with subfamily annotations
  annotation.df.TE.subfam <- data.frame(xs = c(annotation.df.TE$xmaxs + 1),
                               ys = c(annotation.df.TE$ymiddle),
                               label = c(as.character(candidateTable$subfamTE)),
                               stringsAsFactors = FALSE)
  
  #Create the annotation of the ORF
  annotation.df$ymins <- -1*(ymaxValue)*(annotation.df$levelNum+1)
  annotation.df$ymaxs <- -1*(ymaxValue)*(annotation.df$levelNum+1) + ymaxValue*ratioAnnotation
  annotation.df$ymiddle <- (annotation.df$ymins + annotation.df$ymaxs)/2
  
  dfTranscript$ymins <- rep(0, numExons)
  dfTranscript$ymaxs <- rep(ymaxValue, numExons)
  dfTranscript$exonnum <- seq(1,numExons)
  
  dfTranscript$xmiddle <- (dfTranscript$xmins + dfTranscript$xmaxs)/2
  dfTranscript$ymiddle <- (dfTranscript$ymins + dfTranscript$ymaxs)/2
  
  #The Text Labels for the tracks
  xposLabel = -1*xmaxValue/9
  labelTracks.df <- data.frame(xs = c(xposLabel,
                                      xposLabel,
                                      xposLabel),
                               ys = seq(ymaxValue/2, -3*ymaxValue/2, -1*ymaxValue),
                               label = c("Transcript",
                                         "TE",
                                         "ORF")
                               )
  
  #This will hold the adjustment to the hline
  adjustmentHline = 1
  
  gg_splice <- ggplot(data = dfTranscript, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs)) + 
      geom_rect(aes(fill = labels), color = "black", alpha = .85) +
      geom_text(aes(x=xmiddle, y=ymiddle, label = exonnum), color = "black") +
    geom_rect(data = annotation.df.TE, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs), color = "white", fill = currentColorTE, alpha = .95) +
    geom_polygon(data = annotation.df.TE.segment, aes(x=xs, y=ys), inherit.aes = FALSE) +
    geom_text(data=annotation.df.TE.subfam, aes(x=xs, y=ys, label = label, fontface = 3), inherit.aes = FALSE, hjust = 0) +
    geom_rect(data = annotation.df, aes(xmin=xmins, xmax=xmaxs, ymin=ymins, ymax=ymaxs), color = "white", fill = "navyblue", alpha = .95) +
    geom_segment(data = annotation.df, aes(x=xmins, xend=xmaxs, y=ymiddle, yend=ymiddle), color ="white", arrow = arrow(length = unit(0.5, "cm")),size = 1) +
      scale_fill_manual(values = c(currentColorTE, "gray94"))+
    labs(x = "Transcript Nucleotide") +
    geom_hline(yintercept = range(0-adjustmentHline,-1*ymaxValue-adjustmentHline), color = "grey42", alpha = 0.85, linetype="dashed") +
    geom_vline(xintercept = range(0), color = "black") +
    geom_text(data=labelTracks.df, aes(x=xs, y=ys, label = label), inherit.aes = FALSE, hjust = 0) +
      theme_classic() + 
    scale_x_continuous(expand = c(0,0)) +
    theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          legend.position = "none")
  
  ggsave(paste0("./transcriptPlots/","_", candidateTable$uniqid ,currentTranscript,"_",currentStrategy,"_TranscriptFigure.pdf"), gg_splice, width = 9, height = 1.8, device = cairo_pdf)
  
  baseColor = "gray94"
  newAAColor = "darkorchid3"
  tmColor = "gold"
  
  currentRow <- candidateTable
  
  
  if (currentStrategy == "cpc2"){
    newProteinSequence <- currentRow$cpc2_proteinseqfull2
    origProteinLeft <- as.numeric(as.character(currentRow$cpc2_origprotleft))
    origProteinSequence <- currentRow$orig_proteinsequence
    proteinLength <- nchar(origProteinSequence)
    newProteinStart <- proteinLength - origProteinLeft
    TypeNow <- currentRow$cpc2_type_final
  } else {
    newProteinSequence <- currentRow$proteinseqfull2
    origProteinLeft <- as.numeric(as.character(currentRow$origprotleft))
    origProteinSequence <- currentRow$orig_proteinsequence
    proteinLength <- nchar(origProteinSequence)
    newProteinStart <- proteinLength - origProteinLeft
    TypeNow <- currentRow$type_final
  }
  
  
  #Only if the final type is Normal, chimeric, or truncated will we use it
  #Pfam with domains highlighted to show what is happening ot the proteins
  if (TypeNow %in% c("chimeric normal", "chimeric truncated", "normal", "truncated")){
    xminVec <- c(0,newProteinStart)
    xmaxVec <- c(proteinLength, proteinLength)
    yminVec <- c(1,-1)
    ymaxVec <- c(2,0)
    colorVec <- c("Background", "Background")
    
    if (grepl("chimeric",TypeNow)){
      xminVec <- c(xminVec, newProteinStart - (nchar(newProteinSequence) - origProteinLeft))
      xmaxVec <- c(xmaxVec, newProteinStart)
      yminVec <- c(yminVec, -1)
      ymaxVec <- c(ymaxVec, 0)
      colorVec <- c(colorVec, "Novel AA")
    }
    
    pfam.df <- pfamDomains[pfamDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
    
    if (!is.na(pfam.df$pfam_start)){
      for(i in 1:nrow(pfam.df)){
        xminVec <- c(xminVec, pfam.df$pfam_start[i])
        xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
        yminVec <- c(yminVec, 1)
        ymaxVec <- c(ymaxVec, 2)
        colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
      }
      for(i in 1:nrow(pfam.df)){
        if(pfam.df$pfam_start[i] > newProteinStart){
          xminVec <- c(xminVec, pfam.df$pfam_start[i])
          xmaxVec <- c(xmaxVec, pfam.df$pfam_end[i])
          yminVec <- c(yminVec, -1)
          ymaxVec <- c(ymaxVec, 0)
          colorVec <- c(colorVec, paste0(pfam.df$pfam[i],": ",pfam.df$Description[i]))
        }
      }
    }
    
    df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
    
    fam.add <- brewer.pal(n = 8, name = "Set1")
    
    if (grepl("chimeric",TypeNow)){
      colorPallete <- c(baseColor, newAAColor, fam.add[1:(length(unique(df.rect$colorVec)) - 2)])
    } else {
      colorPallete <- c(baseColor, fam.add[1:(length(unique(df.rect$colorVec)) - 1)])
    }
    
    tm.df <- tmDomains[tmDomains$ensembl_transcript_id == currentRow$transcriptmapEns, ]
    
    if (!is.na(tm.df$transmembrane_domain_start)){
      for(i in 1:nrow(tm.df)){
        xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
        xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
        yminVec <- c(yminVec, 1)
        ymaxVec <- c(ymaxVec, 2)
        colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
      }
      for(i in 1:nrow(tm.df)){
        if(tm.df$transmembrane_domain_start[i] > newProteinStart){
          xminVec <- c(xminVec, tm.df$transmembrane_domain_start[i])
          xmaxVec <- c(xmaxVec, tm.df$transmembrane_domain_end[i])
          yminVec <- c(yminVec, -1)
          ymaxVec <- c(ymaxVec, 0)
          colorVec <- c(colorVec, tm.df$transmembrane_domain[i])
        }
      }
      colorPallete <- c(colorPallete, tmColor)
      df.rect <- data.frame(xmin = xminVec, xmax = xmaxVec, ymin = yminVec, ymax = ymaxVec, colorVec = colorVec, stringsAsFactors = FALSE)
    }
    
    gg_protein <- ggplot() + 
      geom_rect(data = df.rect, xmin=df.rect$xmin, xmax=df.rect$xmax, ymin=df.rect$ymin, ymax=df.rect$ymax,aes(fill = colorVec), color = "black") +
      scale_y_continuous(limits=c(-2,3))+
      scale_x_continuous(limits=c(min(xminVec),max(xmaxVec)))+
      annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = 2.3, label = currentRow$gene2) +
      annotate("text", x = mean(c(min(xminVec),max(xmaxVec))), y = .3, label = paste0(currentRow$subfamTE,"-",currentRow$gene2)) +
      geom_vline(xintercept = 0, alpha = .1)+
      labs(x = "Reference Protein AA #", fill = "Key")+
      scale_fill_manual(values = colorPallete) +
      theme_classic() +
      theme(axis.line.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          legend.position = "bottom")
    
    ggsave(paste0("./structurePlots2/",currentRow$uniqid,"_",currentStrategy,"_","pfam.pdf"), gg_protein, width = 9, height = 3.6, device = cairo_pdf)
    
    library(cowplot)
    
    pg1 <- plot_grid(gg_splice,gg_protein, ncol = 1, rel_heights = c(1/3, 2/3))
    
    ggsave2(paste0("./structurePlots2/",currentRow$uniqid,"_",currentStrategy,"_","pfam_withtranscript.pdf"), pg1, width = 9, height = 5.4, device = cairo_pdf)
  }
}
```


### Overall Numbers

I need to redo the creation of the antigen table. These next ew lines are processing maxquant and pfind output and being able to extract peptides and the corresponding TE/protein that they belong to. 

```{r}
#Convert the column names with presence information to the correct one

colNameToCellLine <- data.frame(colName = c('Experiment.107_Josh_MHC_B49_DMSO_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B49_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep3',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DACPANO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep1',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep2',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep3'),
                                cellLine = c('B49_DMSO_1',
                                             'B49_DAC_1',
                                             'B66_DAC_1',
                                             'B66_DAC_2',
                                             'B49_DAC_2',
                                             'B49_DAC_3',
                                             'B49_DMSO_2',
                                             'B49_DMSO_3',
                                             'B66_DAC_3',
                                             'B66_DMSO_1',
                                             'B66_DMSO_2',
                                             'B66_DMSO_3'),
                                stringsAsFactors = FALSE)
```


Begin to create the dataframe that will be tested. 

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(RunGSC_MHCProteome_FDR05)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- RunGSC_MHCProteome_FDR05$Sequence[i]
  candidateProteins <- strsplit(RunGSC_MHCProteome_FDR05$Proteins[i],';')[[1]]
  numProteins <- length(candidateProteins)
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
  }
  
  presentColumns <- colNameExperiment[!is.na(RunGSC_MHCProteome_FDR05[i,colNameExperiment])]
  
  numberSamples <- length(presentColumns)
  
  Peptides <- rep(Peptides, numberSamples)
  Candidate <- rep(Candidate, numberSamples)
  UniqMultiple <- rep(UniqMultiple, numberSamples)
  Samples <- sort(rep(presentColumns, numProteins))
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSC.table.allantigens <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("Maxquant", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSC.table.allantigens$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSC.table.allantigens$sample, colNameToCellLine$colName)]
```

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(pfindGSC_MHCProteome_FDR05)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- pfindGSC_MHCProteome_FDR05$Sq[i]
  candidateProteins <- strsplit(pfindGSC_MHCProteome_FDR05$Protein.AC[i],'\\/')[[1]]
  numProteins <- length(candidateProteins)
  sample <- strsplit(pfindGSC_MHCProteome_FDR05$Title[i],"\\.")[[1]][1]
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
    Samples <- c(Samples,sample)
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
    Samples <- c(Samples,rep(sample, numProteins))
  }
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSC.table.allantigens.pf <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("pFind", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSC.table.allantigens.pf$sample <- gsub("20200","Experiment.",massSpecPeptide.GSC.table.allantigens.pf$sample)
massSpecPeptide.GSC.table.allantigens.pf$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSC.table.allantigens.pf$sample, colNameToCellLine$colName)]

massSpecPeptide.GSC.table.allantigens <- rbind(massSpecPeptide.GSC.table.allantigens, massSpecPeptide.GSC.table.allantigens.pf)
```


```{r}
massSpecPeptide.GSC.table.allantigens.u <-  unique(massSpecPeptide.GSC.table.allantigens[,c("sequence", "sampleclean")])

massSpecPeptide.GSC.table.allantigens.u$method <- apply(massSpecPeptide.GSC.table.allantigens.u[,c("sequence", "sampleclean")],
                                                    1,
                                                    function(x){
                                                  pFind <- sum(massSpecPeptide.GSC.table.allantigens$method[massSpecPeptide.GSC.table.allantigens$sequence == x[1]] == "pFind")
                                                  Maxquant <- sum(massSpecPeptide.GSC.table.allantigens$method[massSpecPeptide.GSC.table.allantigens$sequence == x[1]] == "Maxquant")
                                                  if (pFind > 0 & Maxquant > 0){
                                                    return("Both")
                                                  } else if (pFind > 0){
                                                    return("pFind")
                                                  } else if (Maxquant > 0){
                                                    return("Maxquant")
                                                  }
                                                    })

massSpecPeptide.GSC.table.allantigens.u$CL_Tx <- substr(massSpecPeptide.GSC.table.allantigens.u$sampleclean,1,nchar(massSpecPeptide.GSC.table.allantigens.u$sampleclean)-2)

massSpecPeptide.GSC.table.allantigens.u.cl <- unique(massSpecPeptide.GSC.table.allantigens.u[,c("sequence", "CL_Tx", "method")])
```

```{r}
antigenStats.oe.i <- as.data.frame(table(massSpecPeptide.GSC.table.allantigens.u$sampleclean, massSpecPeptide.GSC.table.allantigens.u$method), stringsAsFactors = F)

antigenStats.oe.i$totalColumn <- rep("No", nrow(antigenStats.oe.i))

antigenStats.oe.t <- as.data.frame(table(massSpecPeptide.GSC.table.allantigens.u.cl$CL_Tx, massSpecPeptide.GSC.table.allantigens.u.cl$method), stringsAsFactors = F)

antigenStats.oe.t$Var1 <- paste0(antigenStats.oe.t$Var1, "_Total")

antigenStats.oe.t$totalColumn <- rep("Yes", nrow(antigenStats.oe.t))

antigenStats.oe <- rbind(antigenStats.oe.i, antigenStats.oe.t)

antigenStats.oe$Var2 <- factor(antigenStats.oe$Var2, levels = c("pFind", "Both", "Maxquant"))

p1 <- ggplot(antigenStats.oe, aes(Var1, Freq)) +
  geom_bar(aes(alpha = totalColumn, fill=Var2), stat = "identity", color = "black", position="stack", width = .75) +
  scale_alpha_manual(values=c(.5,1), guide = FALSE) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = c("blue", "grey", "purple")) +
  labs(y = "Total Peptides", fill = "Method") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))
p1

ggsave("./plots/N1_GSC_peptidestats.pdf", p1, width = 8, height = 2.2, device = cairo_pdf)
```

```{r}
massSpecPeptide.GSC.table.u.gsantigens <- massSpecPeptide.GSC.table.u[massSpecPeptide.GSC.table.u$sequence %in% genomicSupportedPeptides,]

blatSumTable <- unique(massSpecPeptide.GSC.table.u.gsantigens[,c("sequence", "blatNum")])

p2 <- ggplot(blatSumTable, aes(sequence, blatNum)) +
  geom_bar(stat = "identity", color = "black", fill = "grey", alpha = 0.75) +
  labs(y = "No. Genomic Loci") +
  scale_y_continuous(limits= c(0,1400),expand=c(0,0)) +
  geom_text(aes(label = blatNum), vjust=-0.25) +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
library(cowplot)

pg1 <- plot_grid(p1,p2, ncol = 2, align = "h", rel_widths = c(4/5,1/5))

ggsave2("./plots/N1_GSC_peptidestats_all.pdf", pg1, width = 12, height = 2.2, device = cairo_pdf)
```


```{r}
colorsGSC=c(B36_DMSO="#E31A1C", B36_DP="#FB9A99",
           B49_DMSO="#33A02C", B49_DP="#B2DF8A",
           B66_DMSO="#1F78B4", B66_DP="#A6CEE3",
           hFB_DMSO="#C51B7D", hFB_DP="#DE77AE",
           QhFB_DMSO="#6A3D9A", QhFB_DP="#CAB2D6",
           NHA_DMSO="#FF7F00", NHA_DP="#FDBF6F",
           QNHA_DMSO="#B15928", QNHA_DP="#D3A74B" )

colorsGSC2 <- colorsGSC
names(colorsGSC2) <- gsub("_", " ", names(colorsGSC2))
```

```{r}
massSpecPeptide.GSC.table.u.gsantigens$identifier <- paste0(massSpecPeptide.GSC.table.u.gsantigens$uniqid,"--",massSpecPeptide.GSC.table.u.gsantigens$sequence)

peptideRepeatGraphTable <- massSpecPeptide.GSC.table.u.gsantigens[,c("uniqid","sequence","identifier")]

peptideRepeatGraphTable <- unique(peptideRepeatGraphTable)

indexMatch <- match(peptideRepeatGraphTable$uniqid, transcriptPeakTable$uniqid)

colNamesExpression <- colnames(transcriptPeakTable)[grepl("_DP|_DMSO", colnames(transcriptPeakTable))]

for (cname in colNamesExpression){
  peptideRepeatGraphTable[cname] <- transcriptPeakTable[indexMatch, c(cname)]
}

indexMatch <- match(peptideRepeatGraphTable$uniqid,annotatedcufftranscripts$uniqid)

peptideRepeatGraphTable$subfamTE <- annotatedcufftranscripts$subfamTE[indexMatch]
peptideRepeatGraphTable$gene2 <- annotatedcufftranscripts$gene2[indexMatch]
peptideRepeatGraphTable$labels <- paste0(peptideRepeatGraphTable$subfamTE, "_",peptideRepeatGraphTable$gene2)
peptideRepeatGraphTable <- peptideRepeatGraphTable[order(peptideRepeatGraphTable$labels),]
peptideRepeatGraphTable$identifier2 <- paste0(peptideRepeatGraphTable$labels,"--",peptideRepeatGraphTable$sequence)

peptideRepeatGraphTable$duplicatedi2 <- duplicated(peptideRepeatGraphTable$identifier2)
peptideRepeatGraphTable <- peptideRepeatGraphTable[!peptideRepeatGraphTable$duplicatedi2,]

peptideRepeatGraphTable.m <- melt(peptideRepeatGraphTable[,c("uniqid","sequence","identifier", "labels", colNamesExpression)], id.vars = c("uniqid","sequence","identifier", "labels"))
peptideRepeatGraphTable.m$sequence <- factor(peptideRepeatGraphTable.m$sequence, levels = sort(unique(peptideRepeatGraphTable.m$sequence)))

peptideRepeatGraphTable.m <- peptideRepeatGraphTable.m[order(peptideRepeatGraphTable.m$sequence, peptideRepeatGraphTable.m$identifier),]
peptideRepeatGraphTable.m$identifier <- factor(peptideRepeatGraphTable.m$identifier,  unique(peptideRepeatGraphTable.m$identifier))

peptideRepeatGraphTable.m$variableclean <- gsub("_"," ",peptideRepeatGraphTable.m$variable)
```

```{r}
library(RColorBrewer)

label.df <- unique(peptideRepeatGraphTable.m[,c("identifier", "labels")])

p3 <- ggplot(peptideRepeatGraphTable.m, aes(identifier, log2(value+1))) + 
  geom_beeswarm(aes(color = variableclean)) +
  scale_x_discrete(labels = label.df$labels) +
  scale_y_continuous(expand = c(0,0)) +
  scale_color_manual(values = colorsGSC2) +
  geom_text_repel(data=peptideRepeatGraphTable.m[peptideRepeatGraphTable.m$value >= 1,],aes(label = variableclean), size=2.75) +
  geom_hline(yintercept = c(1), alpha = .75, linetype = "dashed") +
  geom_vline(xintercept = c(1.5, 2.5, 3.5, 4.5, 5.5), alpha = .75, linetype = "dashed") +
  labs(y = "CAGE log2(TPM+1)", color = "Cell Line") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "bottom") +
  guides(color=guide_legend(nrow=2, byrow=TRUE))

ggsave("./plots/N1_GSCpeptideExpression.pdf", p3, width = 12, height = 5, device = cairo_pdf)
```


#All TE Analysis Mass spec

After running Maxquant and Pfind across the peptide list that includes the All TE Analysis antigen code translation, we will rerun the mass spec analysis

```{r}
RunGSCTEAll_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TCGAAntigen/LC_MS_060522_GBM_TE/peptides.txt', header = TRUE, stringsAsFactors = FALSE)

RunGSCTEAll_MHCProteome_FDR05 <- RunGSCTEAll_MHCProteome_FDR05[!grepl('CON_|REV',RunGSCTEAll_MHCProteome_FDR05$Proteins),]
RunGSCTEAll_MHCProteome_FDR05 <- RunGSCTEAll_MHCProteome_FDR05[!grepl('CON_|REV',RunGSCTEAll_MHCProteome_FDR05$Leading.razor.protein),]

RunGSCTEAll_MHCProteome_FDR05$TECand <- grepl('_both|_og|_cpc2|_F_|_R_', RunGSCTEAll_MHCProteome_FDR05$Proteins)

RunGSCTEAll_MHCProteome_FDR05$uniqueToCand <- apply(RunGSCTEAll_MHCProteome_FDR05[,c("Sequence", "Proteins")], 1, function(x){
  splitvec <- strsplit(x[2],';')[[1]]
  if (length(splitvec) == sum(grepl('_both|_og|_cpc2|_F_|_R_', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})

RunGSCTEAll_MHCProteome_FDR05.fil <- RunGSCTEAll_MHCProteome_FDR05[RunGSCTEAll_MHCProteome_FDR05$uniqueToCand == "yes",]

```

###Graph some data on peptides

```{r}
library(ggplot2)

RunGSCTEAll_MHCproteome_100 <- RunGSCTEAll_MHCProteome_FDR05

p1 <- ggplot(RunGSCTEAll_MHCproteome_100, aes(Length)) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Peptide Length") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTEAll HLA Proteome") +
  theme_classic()
p1

p2  <- ggplot(RunGSCTEAll_MHCproteome_100, aes(as.numeric(Charges))) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Charges") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTEAll HLA Proteome") +
  theme_classic()
p2


masses <- c()
charges <- c()
lengths <- c()

currenttable <- RunGSCTEAll_MHCproteome_100

i = 1
for (chargeText in currenttable$Charges){
  if (chargeText == ""){
    i = i + 1
    next
  }
  
  if (grepl(";",chargeText)){
    chargevec <- strsplit(chargeText,";")[[1]]
    
    for (chargevalue in chargevec){
      masses <- c(masses, currenttable$Mass[i])
      charges <- c(charges, as.numeric(chargevalue))
      lengths <- c(lengths, currenttable$Length[i])
    }
  } else{
    masses <- c(masses, currenttable$Mass[i])
    charges <- c(charges, as.numeric(chargeText))
    lengths <- c(lengths, currenttable$Length[i])
  }
  i = i + 1
}

RunGSCTEAll_MHCstats <- data.frame(masses = masses, charges = charges, lengths = lengths)

p3 <- ggplot(RunGSCTEAll_MHCstats, aes(x=masses/charges, fill = factor(charges))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTEAll HLA Proteome Mass/charge | Charge Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p3

p4 <- ggplot(RunGSCTEAll_MHCstats, aes(x=masses/charges, fill = factor(lengths))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTEAll HLA Proteome Mass/charge | Length Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p4


#Create a peptide format file that can be fed into netmhc pan

#Only peptides that are greater than 7AA in length should be considered. netMHCpan will break with 7 or below
fileConn<-file("sequences.peptide")
writeLines(RunGSCTEAll_MHCproteome_100$Sequence[RunGSCTEAll_MHCproteome_100$Length > 7], fileConn)
close(fileConn)
```

```{r}
library(gridExtra)

a375_grob <- arrangeGrob(p1, p2, p3, p4, ncol=2)

ggsave("RunGSCTEAll_mass_spec_stats.pdf",a375_grob, width=12, height = 8, device = cairo_pdf())
```


```{r}

sampleNames <- colnames(RunGSCTEAll_MHCProteome_FDR05)[grepl('LFQ.intensity.',colnames(RunGSCTEAll_MHCProteome_FDR05))]

sampleCounts <- sapply(sampleNames, function(x) sum(RunGSCTEAll_MHCProteome_FDR05[,x[1]] > 0))

df.Samples <- data.frame(sampleNames, sampleCounts)

df.Samples$labels <- c('B49_DMSO_Brep1',
                      'B49_DACPano_Brep1',
                      'B66_DACPano_Brep1',
                      'B66_DACPano_Brep2',
                      'B49_DACPano_Brep2',
                      'B49_DACPano_Brep3',
                      'B49_DMSO_Brep2',
                      'B49_DMSO_Brep3',
                      'B66_DACPano_Brep3',
                      'B66_DMSO_Brep1',
                      'B66_DMSO_Brep2',
                      'B66_DMSO_Brep3')

p <- ggplot(df.Samples,aes(labels, sampleCounts)) + 
  geom_bar(stat='identity', color = "black", fill = "orchid") + 
  theme_classic() + 
  labs(x = "Sample", y = "Number of Peptides\nRecovered") +
  theme(axis.text.x = element_text(angle=90))

p

ggsave("Peptides_per_Cell_Line_ALL.pdf",p, width = 8, height = 5, device = cairo_pdf)
```

```{r}
#Convert the column names with presence information to the correct one

colNameToCellLine <- data.frame(colName = c('Experiment.107_Josh_MHC_B49_DMSO_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B49_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep3',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DACPANO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep1',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep2',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep3'),
                                cellLine = c('DMSOaverageB49',
                                             'DACaverageB49',
                                             'DACaverageB66',
                                             'DACaverageB66',
                                             'DACaverageB49',
                                             'DACaverageB49',
                                             'DMSOaverageB49',
                                             'DMSOaverageB49',
                                             'DACaverageB66',
                                             'DMSOaverageB66',
                                             'DMSOaverageB66',
                                             'DMSOaverageB66'),
                                stringsAsFactors = FALSE)
```


Begin to create the dataframe that will be tested. 

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(RunGSCTEAll_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- RunGSCTEAll_MHCProteome_FDR05.fil$Sequence[i]
  candidateProteins <- strsplit(RunGSCTEAll_MHCProteome_FDR05.fil$Proteins[i],';')[[1]]
  numProteins <- length(candidateProteins)
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
  }
  
  presentColumns <- colNameExperiment[!is.na(RunGSCTEAll_MHCProteome_FDR05.fil[i,colNameExperiment])]
  
  numberSamples <- length(presentColumns)
  
  Peptides <- rep(Peptides, numberSamples)
  Candidate <- rep(Candidate, numberSamples)
  UniqMultiple <- rep(UniqMultiple, numberSamples)
  Samples <- sort(rep(presentColumns, numProteins))
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTEAll.table <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("Maxquant", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTEAll.table$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTEAll.table$sample, colNameToCellLine$colName)]
```

```{r}
pfindGSCTEAll_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TCGAAntigen/LC_MS_060522_GBM_TE/all_result.txt', header = TRUE, stringsAsFactors = FALSE)

pfindGSCTEAll_MHCProteome_FDR05 <- pfindGSCTEAll_MHCProteome_FDR05[!grepl('CON_|REV',pfindGSCTEAll_MHCProteome_FDR05$Protein.AC),]

pfindGSCTEAll_MHCProteome_FDR05$TECand <- grepl('_both|_og|_cpc2|_F_|_R_', pfindGSCTEAll_MHCProteome_FDR05$Protein.AC)

pfindGSCTEAll_MHCProteome_FDR05$uniqueToCand <- apply(pfindGSCTEAll_MHCProteome_FDR05[,c("Sq", "Protein.AC")], 1, function(x){
  splitvec <- strsplit(x[2],'/')[[1]]
  if (length(splitvec) == sum(grepl('_both|_og|_cpc2|_F_|_R_', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})
pfindGSCTEAll_MHCProteome_FDR05.fil <- pfindGSCTEAll_MHCProteome_FDR05[pfindGSCTEAll_MHCProteome_FDR05$uniqueToCand == "yes",]
```

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(pfindGSCTEAll_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- pfindGSCTEAll_MHCProteome_FDR05.fil$Sq[i]
  candidateProteins <- strsplit(pfindGSCTEAll_MHCProteome_FDR05.fil$Protein.AC[i],'\\/')[[1]]
  numProteins <- length(candidateProteins)
  sample <- strsplit(pfindGSCTEAll_MHCProteome_FDR05.fil$Title[i],"\\.")[[1]][1]
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
    Samples <- c(Samples,sample)
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
    Samples <- c(Samples,rep(sample, numProteins))
  }
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTEAll.table.pf <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("pFind", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTEAll.table.pf$sample <- gsub("20200","Experiment.",massSpecPeptide.GSCTEAll.table.pf$sample)
massSpecPeptide.GSCTEAll.table.pf$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTEAll.table.pf$sample, colNameToCellLine$colName)]

massSpecPeptide.GSCTEAll.table <- rbind(massSpecPeptide.GSCTEAll.table, massSpecPeptide.GSCTEAll.table.pf)
```




```{r}

massSpecPeptide.GSCTEAll.table$uniqid <- sapply(massSpecPeptide.GSCTEAll.table$protein, function(x){
  if(grepl('_cpc2|_og|_both',x)){
    tempstring <- strsplit(x,'\\|')[[1]][2]
    return(gsub('_cpc2|_og|_both', '', tempstring))
  } else{
    return("None")
  }
})

massSpecPeptide.GSCTEAll.table$inframe <- apply(massSpecPeptide.GSCTEAll.table[,c("protein", "uniqid")], 1, function(x){
  if(grepl('_cpc2|_og|_both',x[1])){
      if(grepl('_cpc2|_both',x[1])){
        return(as.character(annotatedcufftranscripts.fil$cpc2_type_final)[annotatedcufftranscripts.fil$uniqid == x[2]])
      } else{
        return(as.character(annotatedcufftranscripts.fil$type_final)[annotatedcufftranscripts.fil$uniqid == x[2]])
      }
  } else{
    return("None")
  }
})

massSpecPeptide.GSCTEAll.table$cagePresence <- apply(massSpecPeptide.GSCTEAll.table[,c('uniqid',
                                                                         'sampleclean')],
                                            1,
                                            function(x){
                                              return(fracexpressiontable.m$cagepresent[fracexpressiontable.m$uniqid == x[1] &
                                                                                        fracexpressiontable.m$cageLabel == x[2]][1])
                                            })
massSpecPeptide.GSCTEAll.table$cageTPM <- apply(massSpecPeptide.GSCTEAll.table[,c('uniqid',
                                                                         'sampleclean')],
                                            1,
                                            function(x){
                                              return(fracexpressiontable.m$cageExpression[fracexpressiontable.m$uniqid == x[1] &
                                                                                        fracexpressiontable.m$cageLabel == x[2]][1])
                                            })
indexMatch <- match(massSpecPeptide.GSCTEAll.table$uniqid, annotatedcufftranscripts.fil.c$uniqid)

massSpecPeptide.GSCTEAll.table$consensus.cluster <- transcriptPeakTable$clusterPeak[match(massSpecPeptide.GSCTEAll.table$uniqid, transcriptPeakTable$uniqid)]

massSpecPeptide.GSCTEAll.table$DACmax <- sapply(massSpecPeptide.GSCTEAll.table$consensus.cluster, function(x){ if(is.na(x)){return(NA)} else{
  return(max(b36.cagadata$B36_DP[b36.cagadata$consensus.cluster == x],
         b49.cagadata$B49_DP[b49.cagadata$consensus.cluster == x],
         b66.cagadata$B66_DP[b66.cagadata$consensus.cluster == x]))
}
})

#This will store teh max DMSO value for the GBM cell lines
massSpecPeptide.GSCTEAll.table$DMSOmax <- sapply(massSpecPeptide.GSCTEAll.table$consensus.cluster, function(x){
  if(is.na(x)){return(NA)} else{
  return(max(b36.cagadata$B36_DMSO[b36.cagadata$consensus.cluster == x],
         b49.cagadata$B49_DMSO[b49.cagadata$consensus.cluster == x],
         b66.cagadata$B66_DMSO[b66.cagadata$consensus.cluster == x]))
  }
})

#This will store the max value in the Quiescent cell lines
massSpecPeptide.GSCTEAll.table$DACmaxQuiescent <- sapply(massSpecPeptide.GSCTEAll.table$consensus.cluster, function(x){
  if(is.na(x)){return(NA)} else{
  return(max(qnha.cagadata$QNHA_DP[qnha.cagadata$consensus.cluster == x],
         qhfb.cagadata$QhFB_DP[qhfb.cagadata$consensus.cluster == x]))
  }
})

```

##BLAT filter to try and explain the prevalence of candidates without signal

```{r}
uniquePepSeq <- unique(massSpecPeptide.GSCTEAll.table$sequence)

fastaoutputvector <- c()

for (i in 1:length(uniquePepSeq)){
  fastaoutputvector <- c(fastaoutputvector, paste0(">CAND_",uniquePepSeq[i]))
  fastaoutputvector <- c(fastaoutputvector,uniquePepSeq[i])
}

fileConn<-file("uniquePeptidesCandidates.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash}
#The parameters need to be adjusted, but with this it will work better and everything that should be found will be found. 

nshah@budweiser:/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal$ blat ~/reference/genomefasta/GRCh38.d1.vd1.fa uniquePeptidesCandidates.fa out.psl -t=dnax -q=prot -minScore=1 -minIdentity=100 ; cat out.psl | awk '{if($1==$11){print}}' > out.filtered.psl
```

```{r}
blat.result <- read.delim("out.filtered.psl", header = FALSE, sep = "\t")

blat.result <- blat.result[blat.result$V18 == 1,]

blat.result$location <- paste0(blat.result$V14,':',blat.result$V16,'-',blat.result$V17)

table.blat.result <- as.data.frame(table(blat.result$V10))

table.blat.result$peptide <- gsub('CAND_','',table.blat.result$Var1)

massSpecPeptide.GSCTEAll.table$blatNum <- table.blat.result$Freq[match(massSpecPeptide.GSCTEAll.table$sequence, table.blat.result$peptide)]

massSpecPeptide.GSCTEAll.table$blatNum[is.na(massSpecPeptide.GSCTEAll.table$blatNum)] <- 0
```
## TEnum instead of BLATnum

Another issue that arises is that blat is not



##
```{bash, eval = FALSE}
#Remote will increase the 
nshah@bluemoon:~/reference/blastdb$ blastp -query /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.fa -db nr -num_threads 4 -task 'blastp-short' -outfmt "6 qseqid salltitles pident qcovs sstart send sscinames" > /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output 
```

Getting RNA and Protein Information In one table for candidates

Incorporating BLAST information to decide which peptides are truelly unique to a candidate

```{r}
blastResult = read.delim("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output", stringsAsFactors = FALSE, header = FALSE)

blastResult <- blastResult[blastResult$V3 == 100 & blastResult$V4 == 100 & blastResult$V7 == "Homo sapiens",]

blastResult <- blastResult[!grepl('hCG|unnamed|hypothetical',blastResult$V2),]

uniquePepSeqNum <- sapply(uniquePepSeq, function(x) sum(blastResult$V1 == paste0("CAND_",x)))

forbiddenPeptide <- gsub("CAND_","", blastResult$V1)

#There is only one peptide found that is in Blast and is i the Fukitin gene
```


```{r}
massSpecPeptide.GSCTEAll.table.fil <- massSpecPeptide.GSCTEAll.table[!(massSpecPeptide.GSCTEAll.table$sequence == forbiddenPeptide),]

#Patch fix
massSpecPeptide.GSCTEAll.table.fil$blatNum <- massSpecPeptide.GSCTEAll.table$blatNum[match(massSpecPeptide.GSCTEAll.table.fil$sequence, massSpecPeptide.GSCTEAll.table$sequence)]
```

Getting the antigen table

```{r}
massSpecPeptide.GSCTEAll.table.u <-  unique(massSpecPeptide.GSCTEAll.table[,c("sequence", "protein", "uniqmulti", "inframe", "blatNum", "DACmax", "DMSOmax", "DACmaxQuiescent")])
#Patch fix
massSpecPeptide.GSCTEAll.table.u$blatNum <- massSpecPeptide.GSCTEAll.table$blatNum[match(massSpecPeptide.GSCTEAll.table.u$sequence, massSpecPeptide.GSCTEAll.table$sequence)]


massSpecPeptide.GSCTEAll.table.u$DMSOaverageB49 <- apply(massSpecPeptide.GSCTEAll.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSCTEAll.table$sampleclean[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "DMSOaverageB49")
                                                    })

massSpecPeptide.GSCTEAll.table.u$DACaverageB49 <- apply(massSpecPeptide.GSCTEAll.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSCTEAll.table$sampleclean[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "DACaverageB49")
                                                    })

massSpecPeptide.GSCTEAll.table.u$DMSOaverageB66 <- apply(massSpecPeptide.GSCTEAll.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSCTEAll.table$sampleclean[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "DMSOaverageB66")
                                                    })

massSpecPeptide.GSCTEAll.table.u$DACaverageB66 <- apply(massSpecPeptide.GSCTEAll.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  sum(massSpecPeptide.GSCTEAll.table$sampleclean[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "DACaverageB66")
                                                    })

massSpecPeptide.GSCTEAll.table.u$method <- apply(massSpecPeptide.GSCTEAll.table.u[,c("sequence", "protein")],
                                                    1,
                                                    function(x){
                                                  pFind <- sum(massSpecPeptide.GSCTEAll.table$method[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "pFind")
                                                  Maxquant <- sum(massSpecPeptide.GSCTEAll.table$method[massSpecPeptide.GSCTEAll.table$sequence == x[1] & massSpecPeptide.GSCTEAll.table$protein == x[2]] == "Maxquant")
                                                  if (pFind > 0 & Maxquant > 0){
                                                    return("Both")
                                                  } else if (pFind > 0){
                                                    return("pFind")
                                                  } else if (Maxquant > 0){
                                                    return("Maxquant")
                                                  }
                                                    })
```

```{r}
uniqueTotalPeptides <- unique(massSpecPeptide.GSCTEAll.table.u$sequence)
uniqueTotalPeptides.u <- unique(massSpecPeptide.GSCTEAll.table.u$sequence[massSpecPeptide.GSCTEAll.table.u$blatNum == 1])
uniqueTotalPeptides.m <- unique(massSpecPeptide.GSCTEAll.table.u$sequence[massSpecPeptide.GSCTEAll.table.u$blatNum > 1])

massSpecPeptide.GSCTEAll.table.u$DACsum <- massSpecPeptide.GSCTEAll.table.u$DACaverageB66 + massSpecPeptide.GSCTEAll.table.u$DACaverageB49
massSpecPeptide.GSCTEAll.table.u$DMSOsum <- massSpecPeptide.GSCTEAll.table.u$DMSOaverageB66 + massSpecPeptide.GSCTEAll.table.u$DMSOaverageB49

uniqueTotalPeptides.u.DAC <- unique(massSpecPeptide.GSCTEAll.table.u$sequence[massSpecPeptide.GSCTEAll.table.u$blatNum == 1 & massSpecPeptide.GSCTEAll.table.u$DACsum > 0 &  massSpecPeptide.GSCTEAll.table.u$DMSOsum == 0])
uniqueTotalPeptides.m.DAC <- unique(massSpecPeptide.GSCTEAll.table.u$sequence[massSpecPeptide.GSCTEAll.table.u$blatNum > 1 & massSpecPeptide.GSCTEAll.table.u$DACsum > 0 &massSpecPeptide.GSCTEAll.table.u$DMSOsum == 0])
```

## All TE Analysis ##

Using the upregulated TE subfamilies in either B66 or B49, I analyzed the mass spectrometry data to see if there would be 

I am using the massSpecPeptide.GSCTEAll.table.u table which has the all TE analysis. There are two ways to try and see how many places an antigen could come from. 

```{r}
library("snow")

clus <- makeCluster(16)

clusterExport(clus,"te_translation_table")

resultSapply <- parSapply(clus, massSpecPeptide.GSCTEAll.table.u$sequence,function(x) sum(grepl(x, te_translation_table$proteinseq)))
stopCluster(clus)

massSpecPeptide.GSCTEAll.table.u$numTranslated <- resultSapply 

```

Fixing peptide assignments.  

```{r}
library("snow")

te_translation_table$TEid <- paste(te_translation_table$subfam, te_translation_table$chromosome, te_translation_table$start, te_translation_table$end, te_translation_table$strand, sep = '_')
 
te_translation_table$Pepid <- paste(te_translation_table$TEid, te_translation_table$direction, te_translation_table$frame, te_translation_table$proteinstart, te_translation_table$proteinend, sep = '_')

clus <- makeCluster(16)

clusterExport(clus,"te_translation_table")

resultSapply <- parSapply(clus, massSpecPeptide.GSCTEAll.table.u$sequence,function(x) paste(te_translation_table$Pepid[grepl(x, te_translation_table$proteinseq)], collapse = ","))
stopCluster(clus)

massSpecPeptide.GSCTEAll.table.u$origTE <- resultSapply 

```

## Overall Numbers

```{r}
#Convert the column names with presence information to the correct one

colNameToCellLine <- data.frame(colName = c('Experiment.107_Josh_MHC_B49_DMSO_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B49_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B66_2_DACPano_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep3',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DACPANO_Brep3',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep1',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep2',
                                            'Experiment.311_Josh_MHC_B66_DMSO_Brep3'),
                                cellLine = c('B49_DMSO_1',
                                             'B49_DAC_1',
                                             'B66_DAC_1',
                                             'B66_DAC_2',
                                             'B49_DAC_2',
                                             'B49_DAC_3',
                                             'B49_DMSO_2',
                                             'B49_DMSO_3',
                                             'B66_DAC_3',
                                             'B66_DMSO_1',
                                             'B66_DMSO_2',
                                             'B66_DMSO_3'),
                                stringsAsFactors = FALSE)
```


Begin to create the dataframe that will be tested. 

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(RunGSCTEAll_MHCProteome_FDR05)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- RunGSCTEAll_MHCProteome_FDR05$Sequence[i]
  candidateProteins <- strsplit(RunGSCTEAll_MHCProteome_FDR05$Proteins[i],';')[[1]]
  numProteins <- length(candidateProteins)
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
  }
  
  presentColumns <- colNameExperiment[!is.na(RunGSCTEAll_MHCProteome_FDR05[i,colNameExperiment])]
  
  numberSamples <- length(presentColumns)
  
  Peptides <- rep(Peptides, numberSamples)
  Candidate <- rep(Candidate, numberSamples)
  UniqMultiple <- rep(UniqMultiple, numberSamples)
  Samples <- sort(rep(presentColumns, numProteins))
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTEAll.table.allantigens <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("Maxquant", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTEAll.table.allantigens$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTEAll.table.allantigens$sample, colNameToCellLine$colName)]
```

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(pfindGSCTEAll_MHCProteome_FDR05)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- pfindGSCTEAll_MHCProteome_FDR05$Sq[i]
  candidateProteins <- strsplit(pfindGSCTEAll_MHCProteome_FDR05$Protein.AC[i],'\\/')[[1]]
  numProteins <- length(candidateProteins)
  sample <- strsplit(pfindGSCTEAll_MHCProteome_FDR05$Title[i],"\\.")[[1]][1]
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
    Samples <- c(Samples,sample)
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
    Samples <- c(Samples,rep(sample, numProteins))
  }
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTEAll.table.allantigens.pf <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("pFind", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTEAll.table.allantigens.pf$sample <- gsub("20200","Experiment.",massSpecPeptide.GSCTEAll.table.allantigens.pf$sample)
massSpecPeptide.GSCTEAll.table.allantigens.pf$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTEAll.table.allantigens.pf$sample, colNameToCellLine$colName)]

massSpecPeptide.GSCTEAll.table.allantigens <- rbind(massSpecPeptide.GSCTEAll.table.allantigens, massSpecPeptide.GSCTEAll.table.allantigens.pf)
```


```{r}
massSpecPeptide.GSCTEAll.table.allantigens.u <-  unique(massSpecPeptide.GSCTEAll.table.allantigens[,c("sequence", "sampleclean")])

massSpecPeptide.GSCTEAll.table.allantigens.u$method <- apply(massSpecPeptide.GSCTEAll.table.allantigens.u[,c("sequence", "sampleclean")],
                                                    1,
                                                    function(x){
                                                  pFind <- sum(massSpecPeptide.GSCTEAll.table.allantigens$method[massSpecPeptide.GSCTEAll.table.allantigens$sequence == x[1]] == "pFind")
                                                  Maxquant <- sum(massSpecPeptide.GSCTEAll.table.allantigens$method[massSpecPeptide.GSCTEAll.table.allantigens$sequence == x[1]] == "Maxquant")
                                                  if (pFind > 0 & Maxquant > 0){
                                                    return("Both")
                                                  } else if (pFind > 0){
                                                    return("pFind")
                                                  } else if (Maxquant > 0){
                                                    return("Maxquant")
                                                  }
                                                    })

massSpecPeptide.GSCTEAll.table.allantigens.u$CL_Tx <- substr(massSpecPeptide.GSCTEAll.table.allantigens.u$sampleclean,1,nchar(massSpecPeptide.GSCTEAll.table.allantigens.u$sampleclean)-2)

massSpecPeptide.GSCTEAll.table.allantigens.u.cl <- unique(massSpecPeptide.GSCTEAll.table.allantigens.u[,c("sequence", "CL_Tx", "method")])
```

```{r}
antigenStats.i <- as.data.frame(table(massSpecPeptide.GSCTEAll.table.allantigens.u$sampleclean, massSpecPeptide.GSCTEAll.table.allantigens.u$method), stringsAsFactors = F)

antigenStats.i$totalColumn <- rep("No", nrow(antigenStats.i))

antigenStats.t <- as.data.frame(table(massSpecPeptide.GSCTEAll.table.allantigens.u.cl$CL_Tx, massSpecPeptide.GSCTEAll.table.allantigens.u.cl$method), stringsAsFactors = F)

antigenStats.t$Var1 <- paste0(antigenStats.t$Var1, "_Total")

antigenStats.t$totalColumn <- rep("Yes", nrow(antigenStats.t))

antigenStats <- rbind(antigenStats.i, antigenStats.t)

antigenStats$Var2 <- factor(antigenStats$Var2, levels = c("pFind", "Both", "Maxquant"))

p1 <- ggplot(antigenStats, aes(Var1, Freq)) +
  geom_bar(aes(alpha = totalColumn, fill=Var2), stat = "identity", color = "black", position="stack", width = .5) +
  scale_alpha_manual(values=c(.5,1), guide = FALSE) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = c("blue", "grey", "purple")) +
  labs(y = "Total Peptides", fill = "Method") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))
p1

ggsave("./plots/1_GSCALLTE_peptidestats.pdf", p1, width = 12, height = 2.2, device = cairo_pdf)
```

```{r}
#First extract the numtranslated and the combined subfamily information from above

indexMatch <- match(massSpecPeptide.GSCTEAll.table$sequence, massSpecPeptide.GSCTEAll.table.u$sequence)
massSpecPeptide.GSCTEAll.table$numTranslated <- massSpecPeptide.GSCTEAll.table.u$numTranslated[indexMatch]
massSpecPeptide.GSCTEAll.table$origTE <- massSpecPeptide.GSCTEAll.table.u$origTE[indexMatch]

#For the remaining analysis I am going to remove the solely TE-gene ones and then can talk about which ones were found in another discussion. 

massSpecPeptide.GSCTEAll.table.TeOnly <- massSpecPeptide.GSCTEAll.table[massSpecPeptide.GSCTEAll.table$origTE != "",]

#Assign classes to peptides. If they come from all the same subfamily 

TEreftable <- read.delim("/bar/nshah/reference/repeatmasker/hg38/repeatmasker_description_uniq_TE.lst", skip=1, header=FALSE, stringsAsFactors = FALSE)
TEreftable <- TEreftable[,c('V1','V2')]

peptide_TE.df <- unique(massSpecPeptide.GSCTEAll.table.TeOnly[,c('sequence',"numTranslated",'origTE')])

getClass <- function(numTE, teString){
  if (numTE == 1){
    teString <- strsplit(teString,'_chr')[[1]][1]
    indexsubfams <- match(teString, TEreftable$V1)
    return(TEreftable$V2[indexsubfams])
  } else {
    teString.vec <- unlist(strsplit(teString, split=","))
    teString.vec.clean <- sapply(teString.vec, function(x) strsplit(x,'_chr')[[1]][1])
    indexsubfams <- match(teString.vec.clean, TEreftable$V1)
    classTE <- TEreftable$V2[indexsubfams]
    classTE.freq <- as.data.frame(table(classTE))
    if(nrow(classTE.freq) == 1){
      return(classTE[1])
    } else {
      return('Multiple')
    }
  }
}

peptide_TE.df$classTE <- apply(peptide_TE.df[,c("numTranslated", "origTE")], 1, function(x) getClass(as.numeric(x[1]), x[2]))
```

```{r}
massSpecPeptide.GSCTEAll.table.TeOnly$classTE <- peptide_TE.df$classTE[match(massSpecPeptide.GSCTEAll.table.TeOnly$sequence, peptide_TE.df$sequence)]

massSpecPeptide.GSCTEAll.table.TeOnly.byCL <- unique(massSpecPeptide.GSCTEAll.table.TeOnly[,c("sequence","sampleclean", "blatNum", "numTranslated","origTE", "classTE")])

massSpecPeptide.GSCTEAll.table.TeOnly.byCL$CL <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.byCL$sampleclean,function(x) strsplit(x,'average')[[1]][2])
massSpecPeptide.GSCTEAll.table.TeOnly.byCL$Treatment <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.byCL$sampleclean,function(x) strsplit(x,'average')[[1]][1])
```

```{r}
#Change these to chang ethe default coloring for DMSO versus DAC

colorDMSO = "#A5C8E4"
colorDAC = "#F9F0C1"
```


```{r}
graphTable <- massSpecPeptide.GSCTEAll.table.TeOnly.byCL

graphTable$classTE[graphTable$classTE == "Retroposon"] <-  "SVA"

graphTable.b49 <- graphTable[graphTable$CL == "B49",]

graphTable.b49$classTE <- factor(graphTable.b49$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))
graphTable.b49$Treatment <- factor(graphTable.b49$Treatment, 
                            levels = c(
                              "DMSO", 
                              "DAC"
                              ))

graphTable.b49.t <- as.data.frame(table(graphTable.b49$classTE, graphTable.b49$Treatment))

p2 <- ggplot(graphTable.b49.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="dodge", width = .75) +
  scale_y_continuous(limits = c(0,700), expand = c(0,0)) +
  scale_fill_manual(values = c(colorDMSO, colorDAC)) +
  geom_text(aes(label=Freq),angle = 90, position=position_dodge(width=0.75), hjust = -.25, vjust = .5) +
  labs(y = "Total MHC Peptides", y = "TE Class", fill = "Treatment", title = "B49") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.85,.85))
p2

ggsave("./plots/2_GSCALLTE_peptidesbyclass_B49.pdf", p2, width = 3, height = 2.2, device = cairo_pdf)
```

```{r}
graphTable.b66 <- graphTable[graphTable$CL == "B66",]

graphTable.b66$classTE <- factor(graphTable.b66$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))
graphTable.b66$Treatment <- factor(graphTable.b66$Treatment, 
                            levels = c(
                              "DMSO", 
                              "DAC"
                              ))

graphTable.b66.t <- as.data.frame(table(graphTable.b66$classTE, graphTable.b66$Treatment))

p2 <- ggplot(graphTable.b66.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="dodge", width = .75) +
  scale_y_continuous(limits = c(0,700), expand = c(0,0)) +
  scale_fill_manual(values = c(colorDMSO, colorDAC)) +
  geom_text(aes(label=Freq),angle = 90, position=position_dodge(width=0.75), hjust = -.25, vjust = .5) +
  labs(y = "Total MHC Peptides", y = "TE Class", fill = "Treatment", title = "B66") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.85,.85))
p2

ggsave("./plots/2_GSCALLTE_peptidesbyclass_B66.pdf", p2, width = 3, height = 2.2, device = cairo_pdf)
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/3_GSCALLTE_B49_Venn.pdf", width = 3.3, height = 3.3)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- graphTable.b49$sequence[graphTable.b49$Treatment == "DMSO"], 
                       B <- graphTable.b49$sequence[graphTable.b49$Treatment == "DAC"]),
                  NULL,
                  fill=c(colorDMSO, colorDAC), 
                  alpha=c(0.5,0.5), 
             cex = 1, 
             category.names=c("DMSO","DAC"),
             main="MHC Peptides Found B49")

grid.draw(p)
dev.off()
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/3_GSCALLTE_B66_Venn.pdf", width = 3.3, height = 3.3)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- graphTable.b66$sequence[graphTable.b66$Treatment == "DMSO"], 
                       B <- graphTable.b66$sequence[graphTable.b66$Treatment == "DAC"]),
                  NULL,
                  fill=c(colorDMSO, colorDAC), 
                  alpha=c(0.5,0.5), 
             cex = 1, 
             category.names=c("DMSO","DAC"),
             main="MHC Peptides Found B66")

grid.draw(p)
dev.off()
```

### Treatment Specific

```{r}
massSpecPeptide.GSCTEAll.table.TeOnly$sampleclean.rep <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTEAll.table.TeOnly$sample,
                                                                                          colNameToCellLine$colName)]

massSpecPeptide.GSCTEAll.table.TeOnly.byRep <- unique(massSpecPeptide.GSCTEAll.table.TeOnly[,c("sequence", "blatNum", "numTranslated","origTE", "classTE", "sampleclean.rep")])

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence <- unique(massSpecPeptide.GSCTEAll.table.TeOnly[,c("sequence", "blatNum", "numTranslated","origTE", "classTE")])

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$classTE[massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$classTE == "Retroposon"] <-  "SVA"

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$B66_DMSO <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$sequence, 
                                                                    function(x) return(sum(massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sequence == x &
                                                                                             grepl("B66_DMSO",
                                                                                                   massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sampleclean.rep))))

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$B49_DMSO <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$sequence, 
                                                                    function(x) return(sum(massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sequence == x &
                                                                                             grepl("B49_DMSO",
                                                                                                   massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sampleclean.rep))))

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$B66_DAC <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$sequence, 
                                                                    function(x) return(sum(massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sequence == x &
                                                                                             grepl("B66_DAC",
                                                                                                   massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sampleclean.rep))))

massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$B49_DAC <- sapply(massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$sequence, 
                                                                    function(x) return(sum(massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sequence == x &
                                                                                             grepl("B49_DAC",
                                                                                                   massSpecPeptide.GSCTEAll.table.TeOnly.byRep$sampleclean.rep))))

```

```{r}
graphTable = massSpecPeptide.GSCTEAll.table.TeOnly.bySequence

graphTable.b66.activated <- graphTable[graphTable$B66_DAC > 0 & graphTable$B66_DMSO == 0,]

graphTable.b66.activated$classTE <- factor(graphTable.b66.activated$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))

graphTable.b66.activated.t <- as.data.frame(table(graphTable.b66.activated$classTE, graphTable.b66.activated$B66_DAC))

p3 <- ggplot(graphTable.b66.activated.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="dodge", width = .75) +
  scale_y_continuous(limits = c(0,200), expand = c(0,0)) +
  scale_fill_brewer() +
  geom_text(aes(label=Freq),angle = 90, position=position_dodge(width=0.75), hjust = -.25, vjust = .5) +
  labs(y = "Total MHC Peptides", y = "TE Class", fill = "Replicates", title = "B66") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.925,.85))
p3


ggsave("./plots/4_GSCALLTE_peptidesbyclass_B66.pdf", p3, width = 4.5, height = 2.2, device = cairo_pdf)
```

```{r}
graphTable.b49.activated <- graphTable[graphTable$B49_DAC > 0 & graphTable$B49_DMSO == 0,]

graphTable.b49.activated$classTE <- factor(graphTable.b49.activated$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))

graphTable.b49.activated.t <- as.data.frame(table(graphTable.b49.activated$classTE, graphTable.b49.activated$B49_DAC))

p3 <- ggplot(graphTable.b49.activated.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="dodge", width = .75) +
  scale_y_continuous(limits = c(0,200), expand = c(0,0)) +
  scale_fill_brewer() +
  geom_text(aes(label=Freq),angle = 90, position=position_dodge(width=0.75), hjust = -.25, vjust = .5) +
  labs(y = "Total MHC Peptides", y = "TE Class", fill = "Replicates", title = "B49") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.925,.85))
p3


ggsave("./plots/4_GSCALLTE_peptidesbyclass_B49.pdf", p3, width = 4.5, height = 2.2, device = cairo_pdf)
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/5_GSCALLTE_B49-B66_Venn.pdf", width = 3.3, height = 3.3)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- graphTable.b49.activated$sequence, 
                       B <- graphTable.b66.activated$sequence),
                  NULL,
                  fill=c("#D2E9DA", colorDMSO), 
                  alpha=c(0.5,0.5), 
             cex = 1, 
             category.names=c("B49","B66"),
             main="Treatment Induced MHC Peptides")

grid.draw(p)
dev.off()
```

```{r}
#Bin the Multimapping 
graphTable = massSpecPeptide.GSCTEAll.table.TeOnly.bySequence

#Patch fix
massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$blatNum <- massSpecPeptide.GSCTEAll.table$blatNum[match(massSpecPeptide.GSCTEAll.table.TeOnly.bySequence$sequence, massSpecPeptide.GSCTEAll.table$sequence)]

binCalc <- function(x){
  if (x==1){
    return("1")
  } else if (x > 1000) {
    return(">1000")
  } else if (x > 100) {
    return("101-1000") 
  } else if (x > 10) {
    return("11-100") 
  } else {
    return("2-10")
  }
}

graphTable$mapBin <- sapply(graphTable$blatNum,
                            function(x) binCalc(x))

#Color Scheme for the TEs

colorsTE <- c("#528d4c", "#ff8e56", "#7796ee", "#dc544d", "#f7a8a8", "grey")
names(colorsTE) <- c("LTR", "LINE", "DNA", "SINE", "SVA", "Multiple")
```

```{r}
graphTable.b66.activated <- graphTable[graphTable$B66_DAC > 0 & graphTable$B66_DMSO == 0,]

graphTable.b66.activated$classTE <- factor(graphTable.b66.activated$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))

graphTable.b66.activated$mapBin <- factor(graphTable.b66.activated$mapBin,
                                 levels = c(
                                   "1",
                                   "2-10",
                                   "11-100",
                                   "101-1000",
                                   ">1000"
                                 ))

#Split the plot up

graphTable.b66.activated.1 <- graphTable.b66.activated[graphTable.b66.activated$mapBin == "1",]

p4 <- ggplot(graphTable.b66.activated.1, aes(mapBin, fill = classTE)) +
  geom_bar(stat = "count",color = "black", position="stack", width = .5) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(y = "MHC Peptides", fill = "TE Class", title = "B66") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "None")

graphTable.b66.activated.not1 <- graphTable.b66.activated[graphTable.b66.activated$mapBin != "1",]

p5 <- ggplot(graphTable.b66.activated.not1, aes(mapBin, fill = classTE)) +
  geom_bar(stat = "count",color = "black", position="stack", width = .5) +
  scale_y_continuous(limits = c(0,50), expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(x = "Genomic Locations Mapped", fill = "TE Class") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.75,.75))

library(cowplot)

pg1 <- plot_grid(p4,p5, ncol = 2, axis = "lbt", align = "hv", rel_widths = c(31/100, 69/100))
pg1

ggsave("./plots/6_GSCALLTE_peptidesmultimapping_B66.pdf", pg1, width = 4, height = 4.4, device = cairo_pdf)
```

```{r}
graphTable.b49.activated <- graphTable[graphTable$B49_DAC > 0 & graphTable$B49_DMSO == 0,]

graphTable.b49.activated$classTE <- factor(graphTable.b49.activated$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))

graphTable.b49.activated$mapBin <- factor(graphTable.b49.activated$mapBin,
                                 levels = c(
                                   "1",
                                   "2-10",
                                   "11-100",
                                   "101-1000",
                                   ">1000"
                                 ))

#Split the plot up

graphTable.b49.activated.1 <- graphTable.b49.activated[graphTable.b49.activated$mapBin == "1",]

p4 <- ggplot(graphTable.b49.activated.1, aes(mapBin, fill = classTE)) +
  geom_bar(stat = "count",color = "black", position="stack", width = .5) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(y = "MHC Peptides", fill = "TE Class", title = "B49") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "None")

graphTable.b49.activated.not1 <- graphTable.b49.activated[graphTable.b49.activated$mapBin != "1",]

graphTable.b49.activated.not1.t <- as.data.frame(table(graphTable.b49.activated.not1$mapBin, graphTable.b49.activated.not1$classTE))
graphTable.b49.activated.not1.t <- graphTable.b49.activated.not1.t[graphTable.b49.activated.not1.t$Var1 != "1",]

p5 <- ggplot(graphTable.b49.activated.not1.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="stack", width = .5) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(x = "Genomic Locations Mapped", fill = "TE Class") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.75,.75))

library(cowplot)

pg1 <- plot_grid(p4,p5, ncol = 2, axis = "lbt", align = "hv", rel_widths = c(31/100, 69/100))
pg1

ggsave("./plots/6_GSCALLTE_peptidesmultimapping_B49.pdf", pg1, width = 4, height = 4.4, device = cairo_pdf)
```

```{r}
graphTable.b49andb66.activated <- graphTable[graphTable$B49_DAC > 0 & graphTable$B49_DMSO == 0 & graphTable$B66_DAC > 0 & graphTable$B66_DMSO == 0 ,]

graphTable.b49andb66.activated$classTE <- factor(graphTable.b49andb66.activated$classTE,
                                 levels = c(
                                   "DNA",
                                   "LINE",
                                   "LTR",
                                   "SINE",
                                   "SVA",
                                   "Multiple"
                                 ))

graphTable.b49andb66.activated$mapBin <- factor(graphTable.b49andb66.activated$mapBin,
                                 levels = c(
                                   "1",
                                   "2-10",
                                   "11-100",
                                   "101-1000",
                                   ">1000"
                                 ))

#Split the plot up

graphTable.b49andb66.activated.1 <- graphTable.b49andb66.activated[graphTable.b49andb66.activated$mapBin == "1",]

p4 <- ggplot(graphTable.b49andb66.activated.1, aes(mapBin, fill = classTE)) +
  geom_bar(stat = "count",color = "black", position="stack", width = .5) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(y = "MHC Peptides", fill = "TE Class", title = "B49 and B66 Shared") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "None")

graphTable.b49andb66.activated.not1 <- graphTable.b49andb66.activated[graphTable.b49andb66.activated$mapBin != "1",]

graphTable.b49andb66.activated.not1.t <- as.data.frame(table(graphTable.b49andb66.activated.not1$mapBin, graphTable.b49andb66.activated.not1$classTE))
graphTable.b49andb66.activated.not1.t <- graphTable.b49andb66.activated.not1.t[graphTable.b49andb66.activated.not1.t$Var1 != "1",]

p5 <- ggplot(graphTable.b49andb66.activated.not1.t, aes(Var1, Freq, fill = Var2)) +
  geom_bar(stat = "identity",color = "black", position="stack", width = .5) +
  scale_y_continuous(expand = c(0,0)) +
  scale_fill_manual(values = colorsTE) +
  labs(x = "Genomic Locations Mapped", fill = "TE Class") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(.75,.75))

library(cowplot)

pg1 <- plot_grid(p4,p5, ncol = 2, axis = "lbt", align = "hv", rel_widths = c(31/100, 69/100))
pg1

ggsave("./plots/6_GSCALLTE_peptidesmultimapping_B49andB66.pdf", pg1, width = 4, height = 4.4, device = cairo_pdf)
```

#Exporting the uniquelly mapping candidates

The next thing is to export the TE locations of the uniquelly mapping candidates for Juheon to create the expression matrix for those TEs and then we can do some analysis on wha tthe expression looks like for these candidates even in DMSO samples. 

```{r}
b66unique.te <- graphTable.b66.activated.1[,c("sequence", "origTE")]

b49unique.te <- graphTable.b49.activated.1[,c("sequence", "origTE")]

indexMatch <- match(b66unique.te$origTE, te_translation_table$Pepid)
b66unique.te$chr <- te_translation_table$chromosome[indexMatch]
b66unique.te$start <- te_translation_table$start[indexMatch]
b66unique.te$end <- te_translation_table$end[indexMatch]
b66unique.te$strand <- te_translation_table$start[indexMatch]
b66unique.te <- b66unique.te[!is.na(b66unique.te$chr),]

indexMatch <- match(b49unique.te$origTE, te_translation_table$Pepid)
b49unique.te$chr <- te_translation_table$chromosome[indexMatch]
b49unique.te$start <- te_translation_table$start[indexMatch]
b49unique.te$end <- te_translation_table$end[indexMatch]
b49unique.te$strand <- te_translation_table$start[indexMatch]
b49unique.te <- b49unique.te[!is.na(b49unique.te$chr),]

write.csv(b66unique.te, "./finalFigures/b66unique.te.csv", quote = F, row.names = F)
write.csv(b49unique.te, "./finalFigures/b49unique.te.csv", quote = F, row.names = F)
```

```{r}
#
b49unique.te$TEid <- paste0(b49unique.te$chr,"_",b49unique.te$start-1,"_",b49unique.te$end)
b66unique.te$TEid <- paste0(b66unique.te$chr,"_",b66unique.te$start-1,"_",b66unique.te$end)
```


## Expression Analysis of Endogenous TI-TEA Loci

```{r}
expressionSquireTPMLoci <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/TEloci_expression/7cells_SQUIRE_RNA_TE_TPM.chr1_22_X.intergenic.txt", sep = "\t", header = TRUE)
```

```{r}
indexMatch <- match(b49unique.te$TEid, as.character(expressionSquireTPMLoci$TEid))

colNamesExpression <- colnames(expressionSquireTPMLoci)[grepl("_DP_BR|_DMSO_BR", colnames(expressionSquireTPMLoci))]

b49unique.te.expression <- b49unique.te[!is.na(indexMatch),]
indexMatch <- match(b49unique.te.expression$TEid, as.character(expressionSquireTPMLoci$TEid))

for (cname in colNamesExpression){
  b49unique.te.expression[cname] <- expressionSquireTPMLoci[indexMatch, c(cname)]
}

b49unique.te.expression.m <- melt(b49unique.te.expression[,c("sequence","origTE", "TEid", colNamesExpression)], id.vars = c("sequence","origTE", "TEid"))

b49unique.te.expression.m[is.na(b49unique.te.expression.m)] <- 0.0
b49unique.te.expression.m$labels <- gsub("_"," ",gsub("_BR1|_BR2","",b49unique.te.expression.m$variable))

p4 <- ggplot(b49unique.te.expression.m, aes(labels, log2(value+1))) + 
  geom_jitter(aes(color = labels)) +
  scale_y_continuous(expand = c(0,0)) +
  scale_color_manual(values = colorsGSC2) +
  geom_text_repel(data=b49unique.te.expression.m[b49unique.te.expression.m$value >= 1,],aes(label = sequence), size=2.75) +
  geom_hline(yintercept = c(1), alpha = .75, linetype = "dashed") +
  labs(y = "RNA log2(TPM+1) B49 Candidates") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") 

ggsave("./plots/N5_GSCpeptideExpression_SQUIRE_B49.pdf", p4, width = 12, height = 3.5, device = cairo_pdf)
```

```{r}
indexMatch <- match(b66unique.te$TEid, as.character(expressionSquireTPMLoci$TEid))

colNamesExpression <- colnames(expressionSquireTPMLoci)[grepl("_DP_BR|_DMSO_BR", colnames(expressionSquireTPMLoci))]

b66unique.te.expression <- b66unique.te[!is.na(indexMatch),]
indexMatch <- match(b66unique.te.expression$TEid, as.character(expressionSquireTPMLoci$TEid))

for (cname in colNamesExpression){
  b66unique.te.expression[cname] <- expressionSquireTPMLoci[indexMatch, c(cname)]
}

#Of note, there are 102 locations (out of 164 total) in B66 where Squire did not calculate a loci level expresison based on its methods, and thus there is no expression that can be gotten from it. 
#peptideRepeatGraphTable.m <- melt(peptideRepeatGraphTable[,c("uniqid","sequence","identifier", "labels", colNamesExpression)], id.vars = c("uniqid","sequence","identifier", "labels"))
b66unique.te.expression.m <- melt(b66unique.te.expression[,c("sequence","origTE", "TEid", colNamesExpression)], id.vars = c("sequence","origTE", "TEid"))

b66unique.te.expression.m[is.na(b66unique.te.expression.m)] <- 0.0
b66unique.te.expression.m$labels <- gsub("_"," ",gsub("_BR1|_BR2","",b66unique.te.expression.m$variable))

p5 <- ggplot(b66unique.te.expression.m, aes(labels, log2(value+1))) + 
  geom_jitter(aes(color = labels)) +
  scale_y_continuous(expand = c(0,0)) +
  scale_color_manual(values = colorsGSC2) +
  geom_text_repel(data=b66unique.te.expression.m[b66unique.te.expression.m$value >= 1,],aes(label = sequence), size=2.75) +
  geom_hline(yintercept = c(1), alpha = .75, linetype = "dashed") +
  labs(y = "RNA log2(TPM+1) B66 Candidates") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") 

ggsave("./plots/N5_GSCpeptideExpression_SQUIRE_B66.pdf", p5, width = 12, height = 3.5, device = cairo_pdf)
```

Need to pick a CPM cutoff that matches the TPM cutoff. The plan is to run a regression with the tpm of B49 (since it actually has values that go above 1 TPM) and see what the equation and intercept would be so that can be used 

```{r}
expressionCPMLoci <- read.delim("/scratch/jmaeng/GSC_JoshNakul/for_Nakul/TEloci_expression/7cells.TE_umap.CPM.intergenicTE.txt", sep = "\t", header = TRUE)
```

```{r}
indexMatch <- match(b49unique.te$TEid, as.character(expressionCPMLoci$Geneid))

colNamesExpression <- colnames(expressionCPMLoci)[grepl("_DP_BR|_DMSO_BR", colnames(expressionCPMLoci))]

b49unique.te.cpm.expression <- b49unique.te[!is.na(indexMatch),]
indexMatch <- match(b49unique.te.cpm.expression$TEid, as.character(expressionCPMLoci$Geneid))

for (cname in colNamesExpression){
  b49unique.te.cpm.expression[cname] <- expressionCPMLoci[indexMatch, c(cname)]
}

#Of note, there are 69 locations in B49(out of 163 total)  where there is not a CPM value corresponding.  

b49unique.te.cpm.expression.m <- melt(b49unique.te.cpm.expression[,c("sequence","origTE", "TEid", colNamesExpression)], id.vars = c("sequence","origTE", "TEid"))

b49unique.te.cpm.expression.m[is.na(b49unique.te.cpm.expression.m)] <- 0.0
b49unique.te.cpm.expression.m$labels <- gsub("_"," ",gsub("_BR1|_BR2","",b49unique.te.cpm.expression.m$variable))

p6 <- ggplot(b49unique.te.cpm.expression.m, aes(labels, log2(value+1))) + 
  geom_jitter(aes(color = labels)) +
  scale_y_continuous(expand = c(0,0)) +
  scale_color_manual(values = colorsGSC2) +
  geom_text_repel(data=b49unique.te.cpm.expression.m[b49unique.te.cpm.expression.m$value >= log2(0.5+1),],aes(label = sequence), size=2.75) +
  geom_hline(yintercept = c(log2(0.5+1)), alpha = .75, linetype = "dashed") +
  labs(y = "RNA log2(CPM+1) B49 Candidates") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") 

ggsave("./plots/N5_GSCpeptideExpression_CPM_B49.pdf", p6, width = 12, height = 3.5, device = cairo_pdf)
```

```{r}
b49unique.te.expression.m$matchlabel <- paste0(b49unique.te.expression.m$TEid,"--",b49unique.te.expression.m$variable)
b49unique.te.cpm.expression.m$matchlabel <- paste0(b49unique.te.cpm.expression.m$TEid,"--",b49unique.te.cpm.expression.m$variable)

matchbetween <- match(b49unique.te.expression.m$matchlabel, b49unique.te.cpm.expression.m$matchlabel)

b49unique.te.expression.m$CPM <- b49unique.te.cpm.expression.m$value[matchbetween]

b49unique.te.expression.m.corr <- b49unique.te.expression.m[b49unique.te.expression.m$value >  0 | b49unique.te.expression.m$CPM > 0,]
```

```{r}
lm_eqn <- function(df){
    m <- lm(CPM ~ value, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

pCorr <- ggplot(data = b49unique.te.expression.m.corr, aes(value, CPM)) +
            geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
            geom_point() + 
            geom_text(x = 2, y = 4, label = lm_eqn(b49unique.te.expression.m.corr), parse = TRUE) +
            theme_bw()

pCorr

ggsave("./plots/N5_GSCpeptideExpression_CPM_Correlation.pdf", pCorr, width = 5, height = 5, device = cairo_pdf)
```

```{r}
indexMatch <- match(b66unique.te$TEid, as.character(expressionCPMLoci$Geneid))

colNamesExpression <- colnames(expressionCPMLoci)[grepl("_DP_BR|_DMSO_BR", colnames(expressionCPMLoci))]

b66unique.te.cpm.expression <- b66unique.te[!is.na(indexMatch),]
indexMatch <- match(b66unique.te.cpm.expression$TEid, as.character(expressionCPMLoci$Geneid))

for (cname in colNamesExpression){
  b66unique.te.cpm.expression[cname] <- expressionCPMLoci[indexMatch, c(cname)]
}

#Of note, there are 69 locations in B66(out of 163 total)  where there is not a CPM value corresponding.  

b66unique.te.cpm.expression.m <- melt(b66unique.te.cpm.expression[,c("sequence","origTE", "TEid", colNamesExpression)], id.vars = c("sequence","origTE", "TEid"))

b66unique.te.cpm.expression.m[is.na(b66unique.te.cpm.expression.m)] <- 0.0
b66unique.te.cpm.expression.m$labels <- gsub("_"," ",gsub("_BR1|_BR2","",b66unique.te.cpm.expression.m$variable))

p7 <- ggplot(b66unique.te.cpm.expression.m, aes(labels, log2(value+1))) + 
  geom_jitter(aes(color = labels)) +
  scale_y_continuous(expand = c(0,0)) +
  scale_color_manual(values = colorsGSC2) +
  geom_text_repel(data=b66unique.te.cpm.expression.m[b66unique.te.cpm.expression.m$value >= log2(0.5+1),],aes(label = sequence), size=2.75) +
  geom_hline(yintercept = c(log2(0.5+1)), alpha = .75, linetype = "dashed") +
  labs(y = "RNA log2(CPM+1) B66 Candidates") +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") 

ggsave("./plots/N5_GSCpeptideExpression_CPM_B66.pdf", p7, width = 12, height = 3.5, device = cairo_pdf)
```

```{r}
b66unique.te.expression.m$matchlabel <- paste0(b66unique.te.expression.m$TEid,"--",b66unique.te.expression.m$variable)
b66unique.te.cpm.expression.m$matchlabel <- paste0(b66unique.te.cpm.expression.m$TEid,"--",b66unique.te.cpm.expression.m$variable)

matchbetween <- match(b66unique.te.expression.m$matchlabel, b66unique.te.cpm.expression.m$matchlabel)

b66unique.te.expression.m$CPM <- b66unique.te.cpm.expression.m$value[matchbetween]

b66unique.te.expression.m.corr <- b66unique.te.expression.m[b66unique.te.expression.m$value >  0 | b66unique.te.expression.m$CPM > 0,]
```

```{r}
lm_eqn <- function(df){
    m <- lm(CPM ~ value, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

pCorr <- ggplot(data = b66unique.te.expression.m.corr, aes(value, CPM)) +
            geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
            geom_point() + 
            geom_text(x = 0.5, y = 2, label = lm_eqn(b66unique.te.expression.m.corr), parse = TRUE) +
            theme_bw()

pCorr

ggsave("./plots/N5_GSCpeptideExpression_CPM_Correlation_B66.pdf", pCorr, width = 5, height = 5, device = cairo_pdf)
```
Can put all these plots together for the final figure

```{r}
library(cowplot)

pg1 <- plot_grid(p4,p5,p6,p7, ncol = 1, align = "hv")

ggsave2("./plots/N5_GSCpeptideExpression_COW.pdf", pg1, width = 12, height = 14, device = cairo_pdf)
```

```{r}
peptides.teg.blastfiltered <- massSpecPeptide.GSC.table.u.bf[(massSpecPeptide.GSC.table.u.bf$B66_DP > 0 & massSpecPeptide.GSC.table.u.bf$B66_DMSO == 0) | (massSpecPeptide.GSC.table.u.bf$B49_DP > 0 & massSpecPeptide.GSC.table.u.bf$B49_DMSO == 0),]

peptides.teg.blastfiltered.seq <- unique(peptides.teg.blastfiltered$sequence)

peptides.allte.blastfiltered.seq <- unique(c(graphTable.b66.activated$sequence, graphTable.b49.activated$sequence))
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/9_allTEandChimericVenn_1.pdf", width = 3.3, height = 3.3)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- peptides.teg.blastfiltered.seq, 
                       B <- peptides.allte.blastfiltered.seq),
                  NULL,
                  fill=c("turquoise", "violet"), 
                  alpha=c(0.5,0.5), 
             cex = 1, 
             category.names=c("TE chimeric","All TE"))

grid.draw(p)
dev.off()
```

```{r}
peptides.teg.blastfiltered.fil <- peptides.teg.blastfiltered[peptides.teg.blastfiltered$blatNum <=1,]
peptides.teg.blastfiltered.seq.fil <- unique(peptides.teg.blastfiltered.fil$sequence)

b66unique.te.expression.m.f <- b66unique.te.expression.m[b66unique.te.expression.m$labels == "B66 DP" & (b66unique.te.expression.m$value >= 1 | b66unique.te.expression.m$CPM >= 0.5),]
b49unique.te.expression.m.f <- b49unique.te.expression.m[b49unique.te.expression.m$labels == "B49 DP" & (b49unique.te.expression.m$value >= 1 | b49unique.te.expression.m$CPM >= 0.5),]

peptides.allte.blastfiltered.seq.fil <- unique(c(b66unique.te.expression.m.f$sequence, b49unique.te.expression.m.f$sequence))
```

```{r}
library(VennDiagram)
library(Cairo)

CairoPDF(file="./plots/9_allTEandChimericVenn_2.pdf", width = 3.3, height = 3.3)

grid.newpage(recording = TRUE)
p <- venn.diagram(list(A <- peptides.teg.blastfiltered.seq.fil, 
                       B <- peptides.allte.blastfiltered.seq.fil),
                  NULL,
                  fill=c("turquoise", "violet"), 
                  alpha=c(0.5,0.5), 
             cex = 1, 
             category.names=c("TE chimeric","All TE"))

grid.draw(p)
dev.off()
```

```{r}
peptideRepeatGraphTable.m.fil <- peptideRepeatGraphTable.m[peptideRepeatGraphTable.m$sequence %in% peptides.teg.blastfiltered.seq.fil,]
peptideRepeatGraphTable.m.fil$present <- sapply(peptideRepeatGraphTable.m.fil$value, function(x) if(x >= 1){return(1)}else{return(0)})
```


```{r}
peptideRepeatGraphTable.m.fil$present <- sapply(peptideRepeatGraphTable.m.fil$value, function(x) if(x >= 1){return("Yes")}else{return("No")})

phm1 <- ggplot(peptideRepeatGraphTable.m.fil, aes(variableclean, sequence)) +
  geom_tile(aes(alpha = present), color = "black", fill = "blue4")+
  scale_y_discrete(expand = c(0,0)) +
  scale_x_discrete(expand = c(0,0)) +
  scale_alpha_discrete(range = c(0,1)) +
  theme_bw() +
  theme(axis.title = element_blank(),
        legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```

```{r}
b66unique.te.expression.m.fil <- b66unique.te.expression.m[b66unique.te.expression.m$sequence %in% peptides.allte.blastfiltered.seq.fil,]
b66unique.te.expression.m.fil.a <- aggregate(. ~ sequence + TEid + labels,b66unique.te.expression.m.fil[,c("sequence","TEid","value","labels","CPM" )], FUN=max)
b49unique.te.expression.m.fil <- b49unique.te.expression.m[b49unique.te.expression.m$sequence %in% peptides.allte.blastfiltered.seq.fil,]
b49unique.te.expression.m.fil.a <- aggregate(. ~ sequence + TEid + labels,b49unique.te.expression.m.fil[,c("sequence","TEid","value","labels","CPM" )], FUN=max)

b66b49unique.te.expression.m.fil <- rbind(b66unique.te.expression.m.fil.a , b49unique.te.expression.m.fil.a )
b66b49unique.te.expression.m.fil$present <- apply(b66b49unique.te.expression.m.fil[,c("value", "CPM")], 1, function(x){
  if(x[1] >= 1 | x[2] >= 0.5){
    return("Yes")
  } else{
    return("No")
  }
})
```


```{r}

phm2 <- ggplot(b66b49unique.te.expression.m.fil, aes(labels, sequence)) +
  geom_tile(aes(alpha = present), color = "black", fill = "blue4")+
  scale_y_discrete(expand = c(0,0)) +
  scale_x_discrete(expand = c(0,0)) +
  scale_alpha_discrete(range = c(0,1)) +
  theme_bw() +
  theme(axis.title = element_blank(),
        legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```

```{r}
library(cowplot)

pghm <- plot_grid(phm1,phm2, ncol = 1, align = "hv")

ggsave2("./plots/9_GSCpeptideExpression_heatmap.pdf", pghm, width = 8, height = 6, device = cairo_pdf)
```

# Long-read Analysis

```{r}
exonSkipMax <- 2
keepNone <- 'yes'
filterTE <- 'yes'
annotationFile <- '/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/longreadb49/B49_mock_DACPano_gtf.TALON_talon.conf.wpeak.gff3_annotated_filtered_test_all'

annotatedcufftranscripts.longread <-read.delim(annotationFile, sep = "\t", stringsAsFactors = FALSE, header = FALSE)
columnlabels <- c("transcriptname", "type1", "gene1", "chr1", "start1", "end1", "exonintron1", "number1" ,"startcodon1" , "transcriptstart1", "transcriptend1", "elements1", "id1", "splicing", "type2", "gene2", "chr2", "start2", "end2", "exonintron2", "number2" ,"startcodon2", "transcriptstart2", "transcriptend2", "elements2", "id2", "chromtrans", "starttrans", "endtrans", "transcoord", "intronanno", "chrTE", "startTE", "endTE", "subfamTE", "numTE", "strandTE", "strand")
colnames(annotatedcufftranscripts.longread) <- columnlabels

#This is one exaple where a different name for an isoofrm of a gene is causing issues in tabulation. 

annotatedcufftranscripts.longread[annotatedcufftranscripts.longread == "RP11-545J16.1"] <- 'SLCO1B3'
annotatedcufftranscripts.longread <- annotatedcufftranscripts.longread[annotatedcufftranscripts.longread$exonintron1 != 'exon',]

annotatedcufftranscripts.longread$uniqid <- paste(annotatedcufftranscripts.longread$subfamTE,annotatedcufftranscripts.longread$startTE,annotatedcufftranscripts.longread$gene1,annotatedcufftranscripts.longread$exonintron1, annotatedcufftranscripts.longread$number1, annotatedcufftranscripts.longread$gene2, annotatedcufftranscripts.longread$exonintron2, annotatedcufftranscripts.longread$number2,annotatedcufftranscripts.longread$transcriptstart2,sep = "_")

#Annotate the TEs with class and family information

#TEreftable <- read.delim(repeatAnnotationFile, skip=1, header=FALSE, stringsAsFactors = FALSE)

indexsubfams <- match(annotatedcufftranscripts.longread$subfamTE, TEreftable$V1)
TEclass_v1 <- TEreftable$V2[indexsubfams]
TEfamily_v1 <- TEreftable$V3[indexsubfams]

annotatedcufftranscripts.longread$classTE <- TEclass_v1
annotatedcufftranscripts.longread$familyTE <- TEfamily_v1

#Calculate additional statistics on the transcripts and filter based on exon skipping and exon 1 length. 

calcExonSkip <- function(gene1, gene2, number1, number2){
  if (gene1 != gene2 | (gene1 == 'None' & gene2 == 'None')){
    exonskipped <- -1
  } else {
    exonskipped <- as.numeric(number2)-as.numeric(number1)
  }
  return(exonskipped)
}

annotatedcufftranscripts.longread$exonskipped <- apply(annotatedcufftranscripts.longread[,c('gene1','gene2', 'number1', 'number2')],1,function(x) calcExonSkip(x[1],x[2],x[3],x[4]))

#Do not remove the exon skipped yet. LEt's see how much this happens in long-read data and that can help decide if this is real or fake when we see it inshort read data. 
#annotatedcufftranscripts.longread <- annotatedcufftranscripts.longread[annotatedcufftranscripts.longread$exonskipped <= exonSkipMax,]

if (keepNone == 'no'){
  annotatedcufftranscripts.longread <- annotatedcufftranscripts.longread[annotatedcufftranscripts.longread$gene2 != 'None',]
  annotatedcufftranscripts.longread <- annotatedcufftranscripts.longread[annotatedcufftranscripts.longread$exonintron2 != 'intron',]
}

if(filterTE == 'yes'){
  annotatedcufftranscripts.longread <- annotatedcufftranscripts.longread[annotatedcufftranscripts.longread$classTE %in% c('LINE', 'SINE', 'SINE?', 'LTR', 'LTR?', 'DNA', 'DNA?', 'Retroposon'),]
}


```

Add in expression data. TALON generates a large file, but all we really need is counts per transcript to decide on future steps. Thus I will load it in, extract a table with the counts and transcripts, and then get rid of the main table to save memory and be able to move on. 

```{r}
annotatedcufftranscripts.longread.readcount <-read.delim("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/longreadb49/B49_mock_DACPano_gtf.TALON_talon_read_annot.peak_annot.tsv", sep = "\t", stringsAsFactors = FALSE, header = TRUE)

dataset.lr.reads <- as.data.frame(table(annotatedcufftranscripts.longread.readcount$dataset))
colnames(dataset.lr.reads) <- c("dataset","numreads")

dataset.lr.cpm <- as.data.frame(table(annotatedcufftranscripts.longread.readcount$dataset, as.character(annotatedcufftranscripts.longread.readcount$annot_transcript_id)))

colnames(dataset.lr.cpm) <- c("dataset", "transcript","numreads")

indexMatch <- match(dataset.lr.cpm$dataset, dataset.lr.reads$dataset)

dataset.lr.cpm$cpm <- dataset.lr.cpm$numreads*1000000/(dataset.lr.reads$numreads[indexMatch])

dataset.lr.cpm.m <- dcast(dataset.lr.cpm, transcript ~ dataset, value.var=c('cpm'), fun.aggregate = mean)
dataset.lr.cpm.m[is.na(dataset.lr.cpm.m)] <- 0

dataset.lr.cpm.m.matrix <- dataset.lr.cpm.m
rownames(dataset.lr.cpm.m.matrix) <- dataset.lr.cpm.m.matrix$transcript
dataset.lr.cpm.m.matrix$transcript <- NULL

dataset.lr.cpm.m.matrix <- as.matrix(dataset.lr.cpm.m.matrix)
```

There is a difference in the read depth, but want to see what the correlation is like for the CPM values calculated across the samples. 

```{r}
cor.mat <- cor(dataset.lr.cpm.m.matrix)

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

corrplot(cor.mat , method = "shade", shade.col = NA, tl.col = "black", tl.srt = 45,
         col = col(200), addCoef.col = "black", cl.pos = "n", order = "AOE")

p.corr1 <- corrplot(cor.mat , method = "shade", shade.col = NA, tl.col = "black", tl.srt = 45,
         col = col(200), addCoef.col = "black", cl.pos = "n", order = "AOE")
```

See the number of transcripts detected in each sample across the cell lines. 

```{r}
dataset.lr.reads$numtranscripts <- sapply(dataset.lr.reads$dataset, function(x){
  return(sum(dataset.lr.cpm$dataset == x & dataset.lr.cpm$cpm >= 1))
})
```

Create a reference plot and then get rid of the read table that is taking a lot of memory

```{r}
lr.ref.table <- unique(annotatedcufftranscripts.longread.readcount[,c("gene_ID", "annot_gene_id", "annot_transcript_id", "annot_gene_name", "annot_transcript_name")])

rm(annotatedcufftranscripts.longread.readcount)
```

Map the transcript output to the annotated cuff transcripts and look at how many transcripts are there per TE. 

```{r}
annotatedcufftranscripts.longread$TEid <- paste0(annotatedcufftranscripts.longread$subfamTE,"--",annotatedcufftranscripts.longread$chrTE,":",annotatedcufftranscripts.longread$startTE, ":", annotatedcufftranscripts.longread$endTE)

annotatedcufftranscripts.longread.TEtable <- as.data.frame(table(annotatedcufftranscripts.longread$TEid))
```

```{r}
p1 <- ggplot(annotatedcufftranscripts.longread.TEtable, aes(Freq))+
  geom_histogram()

numMultiple <- sum(annotatedcufftranscripts.longread.TEtable$Freq > 1)
```

```{r}
#First calculate the reads by removing replicates in the datasets and then redo the calculations to incorporate into the dataset for calculating more statistics on the transcripts. 

dataset.lr.reads.nr <- dataset.lr.reads
dataset.lr.reads.nr$numtranscripts <- NULL
dataset.lr.reads.nr$cellline <- sapply(as.character(dataset.lr.reads.nr$dataset), function(x) strsplit(x,"_R")[[1]][1])
dataset.lr.reads.nr$dataset <- NULL

dataset.lr.reads.nr <- aggregate(. ~ cellline,dataset.lr.reads.nr, FUN = sum)

#Do the same thing with the reads and then recalculate the cpm values that is without replicates for use in the analysis. 

dataset.lr.cpm.nr <- dataset.lr.cpm 
dataset.lr.cpm.nr$cpm <- NULL
dataset.lr.cpm.nr$cellline <- sapply(as.character(dataset.lr.cpm.nr$dataset), function(x) strsplit(x,"_R")[[1]][1])
dataset.lr.cpm.nr$dataset <- NULL

dataset.lr.cpm.nr <- aggregate(. ~ cellline + transcript,dataset.lr.cpm.nr, FUN = sum)

indexMatch <- match(dataset.lr.cpm.nr$cellline, dataset.lr.reads.nr$cellline)

dataset.lr.cpm.nr$cpm <- dataset.lr.cpm.nr$numreads*1000000/(dataset.lr.reads.nr$numreads[indexMatch])

dataset.lr.cpm.nr.m <- dcast(dataset.lr.cpm.nr, transcript ~ cellline, value.var=c('cpm'), fun.aggregate = mean)
dataset.lr.cpm.nr.m[is.na(dataset.lr.cpm.nr.m)] <- 0

dataset.lr.numreads.nr.m <- dcast(dataset.lr.cpm.nr, transcript ~ cellline, value.var=c('numreads'), fun.aggregate = mean)
dataset.lr.numreads.nr.m[is.na(dataset.lr.numreads.nr.m)] <- 0
```

```{r}
annotatedcufftranscripts.longread.e <- annotatedcufftranscripts.longread
indexMatch <- match(annotatedcufftranscripts.longread$transcriptname, dataset.lr.numreads.nr.m$transcript)

annotatedcufftranscripts.longread.e$B49_DP <- dataset.lr.numreads.nr.m$B49_DP[indexMatch]  
annotatedcufftranscripts.longread.e$B49_WT <- dataset.lr.numreads.nr.m$B49_WT[indexMatch]  
annotatedcufftranscripts.longread.e$B49_DP.cpm <- dataset.lr.cpm.nr.m$B49_DP[indexMatch]  
annotatedcufftranscripts.longread.e$B49_WT.cpm <- dataset.lr.cpm.nr.m$B49_WT[indexMatch]  

annotatedcufftranscripts.longread.e <- annotatedcufftranscripts.longread.e[!is.na(annotatedcufftranscripts.longread.e$B49_DP),]

annotatedcufftranscripts.longread.e.B49 <- annotatedcufftranscripts.longread.e[annotatedcufftranscripts.longread.e$B49_DP >=2 | annotatedcufftranscripts.longread.e$B49_WT >=2,]
```

```{r}
library('ggplot2')
library('parallel')
library('BSgenome.Hsapiens.UCSC.hg38')
library(reshape2)
library(biomaRt)
library('snow')

clus <- makeCluster(8)

clusterEvalQ(clus, .libPaths( "/bar/nshah/R/x86_64-pc-linux-gnu-library/3.5"))
clusterExport(clus, "getSequenceFromCoords")
annotatedcufftranscripts.longread.e.B49$rnasequence <- parApply(clus, annotatedcufftranscripts.longread.e.B49[,c('uniqid','transcoord')], 1, function(x) getSequenceFromCoords(x[2]))
stopCluster(clus)
readline()
```

Now this transcript can be used as input for another algorithm that we have that allows us to translate it in all 3 frames with stop codons with a minimum legnth of 7. 

```{r}
annotatedcufftranscripts.longread.e.B49$rnasequencelength <- sapply(annotatedcufftranscripts.longread.e.B49$rnasequence, function(x) {return(nchar(x))})

#Remove transcripts that have a length of 1 nucleotide

annotatedcufftranscripts.longread.e.B49 <- annotatedcufftranscripts.longread.e.B49[annotatedcufftranscripts.longread.e.B49$rnasequencelength != 1,]
```

now export the fasta for translation

```{r}
fastaoutputvector <- c()

for (i in 1:nrow(annotatedcufftranscripts.longread.e.B49 )){
  fastaoutputvector <- c(fastaoutputvector, paste0(">",annotatedcufftranscripts.longread.e.B49$transcriptname[i],"\t",annotatedcufftranscripts.longread.e.B49$rnasequence[i]))
}

fileConn<-file("longread_rna_candidates.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

We run a python script that will trnaslate the peptides. Only those starting with methionine in all feames at least 7 AA and with a stop codon will be included 

```{r}
te_translation_table.lr <- read.delim('longread_rna_allframestranslation.txt', header= FALSE, stringsAsFactors = FALSE, sep = '\t')
colnames_trans <- c('transcriptname',
                    'dnalength',
                    'direction',
                    'frame',
                    'proteinstart',
                    'proteinend',
                    'proteinlength',
                    'proteinseq')
colnames(te_translation_table.lr ) <- colnames_trans
```

```{r}
te_translation_table.lr <- te_translation_table.lr[order(te_translation_table.lr$proteinseq),]
te_translation_table.lr$duplicated <- duplicated(te_translation_table.lr$proteinseq)

te_translation_table.lr.u <- te_translation_table.lr[!te_translation_table.lr$duplicated,]

uniqueProteinSequences <- te_translation_table.lr.u$proteinseq

library('snow')
clus <- makeCluster(14)

clusterExport(clus, "uniqueProteinSequences", envir = .GlobalEnv)
resultsinitial <- parSapply(clus,uniqueProteinSequences, function(x) sum(grepl(x, uniqueProteinSequences, fixed = TRUE)))

stopCluster(clus)

resultsinitial.num <- as.numeric(resultsinitial)

te_translation_table.lr.u$encompassnum <- resultsinitial.num 
te_translation_table.lr.u.e <- te_translation_table.lr.u[te_translation_table.lr.u$encompassnum <= 1,]
```

```{r}
te_translation_table.lr.u.e$Pepid <- paste(te_translation_table.lr.u.e$transcriptname, te_translation_table.lr.u.e$frame, te_translation_table.lr.u.e$proteinstart, te_translation_table.lr.u.e$proteinend, sep = '_')

te_translation_table.lr$Pepid <- paste(te_translation_table.lr$transcriptname, te_translation_table.lr$frame, te_translation_table.lr$proteinstart, te_translation_table.lr$proteinend, sep = '_')
```

```{r}
fastaoutputvector.result <- apply(te_translation_table.lr.u.e[,c("Pepid","transcriptname","proteinseq")],
                                  1,
                                  function(x){
                                    labelhere <-  paste0(">tr|",x[1],"|",x[1],"_HUMAN_both ",x[1],"_HUMAN_both OS=Homo sapiens OX=9606 GN=",x[2])
                                    return(c(labelhere, x[3]))
                                  })



fastaoutputvector <- as.vector(fastaoutputvector.result)
  
fileConn<-file("021523_TEAntigens_GSC.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash echo=F, eval=F}
cat <(cat uniprot-proteome_2_sl.fasta) <(cat /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/021523_TEAntigens_GSC.fa) > uniprot-proteome_2_sl_GSCProject_wTELongRead_021523.fasta
```


```{r}
RunGSCLRTE_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/longreadb49/peptides.txt', header = TRUE, stringsAsFactors = FALSE)

RunGSCLRTE_MHCProteome_FDR05 <- RunGSCLRTE_MHCProteome_FDR05[!grepl('CON_|REV',RunGSCLRTE_MHCProteome_FDR05$Proteins),]
RunGSCLRTE_MHCProteome_FDR05 <- RunGSCLRTE_MHCProteome_FDR05[!grepl('CON_|REV',RunGSCLRTE_MHCProteome_FDR05$Leading.razor.protein),]

RunGSCLRTE_MHCProteome_FDR05$TECand <- grepl('TALON|ENST', RunGSCLRTE_MHCProteome_FDR05$Proteins)

RunGSCLRTE_MHCProteome_FDR05$uniqueToCand <- apply(RunGSCLRTE_MHCProteome_FDR05[,c("Sequence", "Proteins")], 1, function(x){
  splitvec <- strsplit(x[2],';')[[1]]
  if (length(splitvec) == sum(grepl('TALON|ENST', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})

RunGSCLRTE_MHCProteome_FDR05.fil <- RunGSCLRTE_MHCProteome_FDR05[RunGSCLRTE_MHCProteome_FDR05$uniqueToCand == "yes",]

```

###Graph some data on peptides

```{r}
library(ggplot2)

RunGSCTE_LR_MHCproteome_100 <- RunGSCLRTE_MHCProteome_FDR05

p1 <- ggplot(RunGSCTE_LR_MHCproteome_100, aes(Length)) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Peptide Length") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTE_LR HLA Proteome") +
  theme_classic()
p1

p2  <- ggplot(RunGSCTE_LR_MHCproteome_100, aes(as.numeric(Charges))) +
  geom_histogram(color = 'black', fill = 'darkblue', binwidth=1, center = 0) +
  xlab("Charges") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTE_LR HLA Proteome") +
  theme_classic()
p2


masses <- c()
charges <- c()
lengths <- c()

currenttable <- RunGSCTE_LR_MHCproteome_100

i = 1
for (chargeText in currenttable$Charges){
  if (chargeText == ""){
    i = i + 1
    next
  }
  
  if (grepl(";",chargeText)){
    chargevec <- strsplit(chargeText,";")[[1]]
    
    for (chargevalue in chargevec){
      masses <- c(masses, currenttable$Mass[i])
      charges <- c(charges, as.numeric(chargevalue))
      lengths <- c(lengths, currenttable$Length[i])
    }
  } else{
    masses <- c(masses, currenttable$Mass[i])
    charges <- c(charges, as.numeric(chargeText))
    lengths <- c(lengths, currenttable$Length[i])
  }
  i = i + 1
}

RunGSCTE_LR_MHCstats <- data.frame(masses = masses, charges = charges, lengths = lengths)

p3 <- ggplot(RunGSCTE_LR_MHCstats, aes(x=masses/charges, fill = factor(charges))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTE_LR HLA Proteome Mass/charge | Charge Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p3

p4 <- ggplot(RunGSCTE_LR_MHCstats, aes(x=masses/charges, fill = factor(lengths))) +
  geom_histogram(color = 'black',binwidth=10, center = 0) +
  xlab("Mass/Charge") +
  ylab("Number of Peptides") +
  labs(title="RunGSCTE_LR HLA Proteome Mass/charge | Length Colored") +
  geom_vline(xintercept = 450) +
  theme_classic()
p4


#Create a peptide format file that can be fed into netmhc pan

#Only peptides that are greater than 7AA in length should be considered. netMHCpan will break with 7 or below
fileConn<-file("sequences.peptide")
writeLines(RunGSCTE_LR_MHCproteome_100$Sequence[RunGSCTE_LR_MHCproteome_100$Length > 7], fileConn)
close(fileConn)
```

```{r}
library(gridExtra)

gsclr_grob <- arrangeGrob(p1, p2, p3, p4, ncol=2)

ggsave("RunGSCLRall_mass_spec_stats.pdf",gsclr_grob, width=12, height = 8, device = cairo_pdf())
```


```{r}

sampleNames <- colnames(RunGSCLRTE_MHCProteome_FDR05)[grepl('LFQ.intensity.',colnames(RunGSCLRTE_MHCProteome_FDR05))]

sampleCounts <- sapply(sampleNames, function(x) sum(RunGSCLRTE_MHCProteome_FDR05[,x[1]] > 0))

df.Samples <- data.frame(sampleNames, sampleCounts)

df.Samples$labels <- c('B49_DMSO_Brep1',
                      'B49_DACPano_Brep1',
                      'B49_DACPano_Brep2',
                      'B49_DACPano_Brep3',
                      'B49_DMSO_Brep2',
                      'B49_DMSO_Brep3')

p <- ggplot(df.Samples,aes(labels, sampleCounts)) + 
  geom_bar(stat='identity', color = "black", fill = "orchid") + 
  theme_classic() + 
  labs(x = "Sample", y = "Number of Peptides\nRecovered") +
  theme(axis.text.x = element_text(angle=90))

p

ggsave("Peptides_per_Cell_Line_ALL.pdf",p, width = 8, height = 5, device = cairo_pdf)
```

```{r}
#Convert the column names with presence information to the correct one

colNameToCellLine <- data.frame(colName = c('Experiment.107_Josh_MHC_B49_DMSO_Brep1',
                                            'Experiment.128_Josh_MHC_GSC_B49_DACPano_Brep1',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DACPANO_Brep3',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep2',
                                            'Experiment.310_Josh_MHC_B49_DMSO_Brep3'),
                                cellLine = c('DMSOaverageB49',
                                             'DACaverageB49',
                                             'DACaverageB49',
                                             'DACaverageB49',
                                             'DMSOaverageB49',
                                             'DMSOaverageB49'),
                                stringsAsFactors = FALSE)
```

Initially, to make the mass spec search less complex, we removed duplicate protein entries as well as encompased proteins. However, now, they need to be incorporated back into the table so then it is easier to map them back and now where all the proteins came from for transcripts that are present. Thus, a computationally expensive remapping process needs to happen to then get the right assigments once again into the 

```{r}
RunGSCLRTE_MHCProteome_FDR05.fil$ProteinsNew <- sapply(RunGSCLRTE_MHCProteome_FDR05.fil$Sequence,
                                                       function (x){
                                                         return(paste(te_translation_table.lr$Pepid[grepl(x,te_translation_table.lr$proteinseq)],collapse = ";"))
                                                       })
```


Begin to create the dataframe that will be tested. 

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(RunGSCLRTE_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- RunGSCLRTE_MHCProteome_FDR05.fil$Sequence[i]
  candidateProteins <- strsplit(RunGSCLRTE_MHCProteome_FDR05.fil$ProteinsNew[i],';')[[1]]
  numProteins <- length(candidateProteins)
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
  }
  
  presentColumns <- colNameExperiment[!is.na(RunGSCLRTE_MHCProteome_FDR05.fil[i,colNameExperiment])]
  
  numberSamples <- length(presentColumns)
  
  Peptides <- rep(Peptides, numberSamples)
  Candidate <- rep(Candidate, numberSamples)
  UniqMultiple <- rep(UniqMultiple, numberSamples)
  Samples <- sort(rep(presentColumns, numProteins))
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTE_LR.table <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("Maxquant", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTE_LR.table$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTE_LR.table$sample, colNameToCellLine$colName)]
```

```{r}
pfindGSCTE_LR_MHCProteome_FDR05 <- read.delim('/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/longreadb49/all_result.txt', header = TRUE, stringsAsFactors = FALSE)

pfindGSCTE_LR_MHCProteome_FDR05 <- pfindGSCTE_LR_MHCProteome_FDR05[!grepl('CON_|REV',pfindGSCTE_LR_MHCProteome_FDR05$Protein.AC),]

pfindGSCTE_LR_MHCProteome_FDR05$TECand <- grepl('TALON|ENST', pfindGSCTE_LR_MHCProteome_FDR05$Protein.AC)

pfindGSCTE_LR_MHCProteome_FDR05$uniqueToCand <- apply(pfindGSCTE_LR_MHCProteome_FDR05[,c("Sq", "Protein.AC")], 1, function(x){
  splitvec <- strsplit(x[2],'/')[[1]]
  if (length(splitvec) == sum(grepl('TALON|ENST', splitvec))){
    return('yes')
  } else {
    return('no')
  }
})
pfindGSCTE_LR_MHCProteome_FDR05.fil <- pfindGSCTE_LR_MHCProteome_FDR05[pfindGSCTE_LR_MHCProteome_FDR05$uniqueToCand == "yes",]
```

```{r}
pfindGSCTE_LR_MHCProteome_FDR05.fil$ProteinsNew <- sapply(pfindGSCTE_LR_MHCProteome_FDR05.fil$Sq,
                                                       function (x){
                                                         return(paste(te_translation_table.lr$Pepid[grepl(x,te_translation_table.lr$proteinseq)],collapse = ";"))
                                                       })
```

```{r}
Peptides.all <- c()
Candidate.all <- c()
UniqMultiple.all <- c()
Samples.all <- c()

colNameExperiment <- colNameToCellLine$colName

for (i in 1:nrow(pfindGSCTE_LR_MHCProteome_FDR05.fil)){
  Peptides <- c()
  Candidate <- c()
  UniqMultiple <- c()
  Samples <- c()
  pepseq <- pfindGSCTE_LR_MHCProteome_FDR05.fil$Sq[i]
  candidateProteins <- strsplit(pfindGSCTE_LR_MHCProteome_FDR05.fil$ProteinsNew[i],';')[[1]]
  numProteins <- length(candidateProteins)
  sample <- strsplit(pfindGSCTE_LR_MHCProteome_FDR05.fil$Title[i],"\\.")[[1]][1]
  if (numProteins == 1){
    Peptides <- c(Peptides, pepseq)
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, "unique")
    Samples <- c(Samples,sample)
  } else {
    Peptides <- c(Peptides, rep(pepseq, numProteins))
    Candidate <- c(Candidate, candidateProteins)
    UniqMultiple <- c(UniqMultiple, rep("multiple", numProteins))
    Samples <- c(Samples,rep(sample, numProteins))
  }
  
  Peptides.all <- c(Peptides.all, Peptides)
  Candidate.all <- c(Candidate.all, Candidate)
  UniqMultiple.all <- c(UniqMultiple.all, UniqMultiple)
  Samples.all <- c(Samples.all, Samples)
}

massSpecPeptide.GSCTE_LR.table.pf <- data.frame(sequence = Peptides.all, protein = Candidate.all, uniqmulti = UniqMultiple.all, sample = Samples.all, method = rep("pFind", length(Samples.all)), stringsAsFactors = FALSE)

massSpecPeptide.GSCTE_LR.table.pf$sample <- gsub("20200","Experiment.",massSpecPeptide.GSCTE_LR.table.pf$sample)
massSpecPeptide.GSCTE_LR.table.pf$sampleclean <- colNameToCellLine$cellLine[match(massSpecPeptide.GSCTE_LR.table.pf$sample, colNameToCellLine$colName)]

massSpecPeptide.GSCTE_LR.table <- rbind(massSpecPeptide.GSCTE_LR.table, massSpecPeptide.GSCTE_LR.table.pf)
```




```{r}
massSpecPeptide.GSCTE_LR.table$transcriptid <- sapply(massSpecPeptide.GSCTE_LR.table$protein, function(x){strsplit(x,"_")[[1]][1]})
```


```{r}
massSpecPeptide.GSCTE_LR.table.b49 <- massSpecPeptide.GSCTE_LR.table[grepl("B49",massSpecPeptide.GSCTE_LR.table$sampleclean),]
massSpecPeptide.GSCTE_LR.table.b49$sampleclean[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "DACaverageB49"] <- "B49_DP"
massSpecPeptide.GSCTE_LR.table.b49$sampleclean[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "DMSOaverageB49"] <- "B49_WT"

LR.b49expression <- melt(annotatedcufftranscripts.longread.e.B49[,c("transcriptname", "B49_DP", "B49_WT")], id.vars = c('transcriptname'))

massSpecPeptide.GSCTE_LR.table.b49$matchID <- paste0(massSpecPeptide.GSCTE_LR.table.b49$transcriptid,"_",massSpecPeptide.GSCTE_LR.table.b49$sampleclean)

LR.b49expression$matchID <- paste0(LR.b49expression$transcriptname,"_",LR.b49expression$variable)

massSpecPeptide.GSCTE_LR.table.b49$expression <- LR.b49expression$value[match(massSpecPeptide.GSCTE_LR.table.b49$matchID, LR.b49expression$matchID)]

peptideLevelData <- unique(massSpecPeptide.GSCTE_LR.table.b49[,c("sequence", "sampleclean")])

peptideLevelData$matchID2 <- paste0(peptideLevelData$sequence,"_",peptideLevelData$sampleclean)

massSpecPeptide.GSCTE_LR.table.b49$matchID2 <- paste0(massSpecPeptide.GSCTE_LR.table.b49$sequence,"_",massSpecPeptide.GSCTE_LR.table.b49$sampleclean)

peptideLevelData$maxExp <- sapply(peptideLevelData$matchID2,
                                  function(x) max(massSpecPeptide.GSCTE_LR.table.b49$expression[massSpecPeptide.GSCTE_LR.table.b49$matchID2 == x]))
```

```{r}
peptideTableFinalLR <- data.frame(sequence = unique(peptideLevelData$sequence))
peptideTableFinalLR$B49_DP.MS <- peptideTableFinalLR$sequence %in% peptideLevelData$sequence[peptideLevelData$sampleclean == "B49_DP"]
peptideTableFinalLR$B49_WT.MS <- peptideTableFinalLR$sequence %in% peptideLevelData$sequence[peptideLevelData$sampleclean == "B49_WT"]
```

```{r}
peptideTableFinalLR$B49_DP.LR <- sapply(peptideTableFinalLR$sequence,
                                        function(x){
                                          max(annotatedcufftranscripts.longread.e.B49$B49_DP[annotatedcufftranscripts.longread.e.B49$transcriptname %in% massSpecPeptide.GSCTE_LR.table.b49$transcriptid[massSpecPeptide.GSCTE_LR.table.b49$sequence == x]])
                                        })

peptideTableFinalLR$B49_WT.LR <- sapply(peptideTableFinalLR$sequence,
                                        function(x){
                                          max(annotatedcufftranscripts.longread.e.B49$B49_WT[annotatedcufftranscripts.longread.e.B49$transcriptname %in% massSpecPeptide.GSCTE_LR.table.b49$transcriptid[massSpecPeptide.GSCTE_LR.table.b49$sequence == x]])
                                        })
```

Creating a visualization of transcripts so then it can be compared across the 

```{r}
refbedexamples <- apply(annotatedcufftranscripts.longread.e.B49[,c("uniqid", "transcoord", "gene2", "transcriptname")], 1, function(x) getRefBed(x[1],x[2], x[3], x[4]))
refbedexamples <- unlist(refbedexamples)
refbedexamples.m <- matrix(refbedexamples, nrow=12)
refbedexamples.m <- as.data.frame(t(refbedexamples.m), stringsAsFactors = FALSE)
refbedexamples.m$V2 <- as.numeric(refbedexamples.m$V2)
refbedexamples.m <- refbedexamples.m[order(refbedexamples.m$V1, refbedexamples.m$V2),]
write.table(refbedexamples.m, "merged_transcripts_all_LRB49.refBed", quote = FALSE, col.names = FALSE, row.names = FALSE, sep = "\t")
```

Now can run the last few analysis needed to then create some graphs about this data and a comparison of the number of antigens and the exclusive ones in each treatment condition that are discovered. 

```{r}
uniquePepSeq <- unique(massSpecPeptide.GSCTE_LR.table.b49$sequence)

fastaoutputvector <- c()

for (i in 1:length(uniquePepSeq)){
  fastaoutputvector <- c(fastaoutputvector, paste0(">CAND_",uniquePepSeq[i]))
  fastaoutputvector <- c(fastaoutputvector,uniquePepSeq[i])
}

fileConn<-file("uniquePeptidesCandidates_LR.fa")
writeLines(fastaoutputvector, fileConn)
close(fileConn)
```

```{bash, eval = FALSE}
#Remote will increase the 
nshah@bluemoon:~/reference/blastdb$ blastp -query /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates_LR.fa -db nr -remote -task 'blastp-short' -outfmt "6 qseqid salltitles pident qcovs sstart send sscinames" > /scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output 
```

```{r}
blastResult = read.delim("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/uniquePeptidesCandidates.blastn.output", stringsAsFactors = FALSE, header = FALSE)

blastResult <- blastResult[blastResult$V3 == 100 & blastResult$V4 == 100 & blastResult$V7 == "Homo sapiens",]

blastResult <- blastResult[!grepl('hCG|unnamed|hypothetical',blastResult$V2),]

blastResult$peptide <- gsub("CAND_", "", blastResult$V1)

massSpecPeptide.GSCTE_LR.table.b49$blastdetected <- massSpecPeptide.GSCTE_LR.table.b49$sequence %in% blastResult$peptide
```

```{bash}
nshah@budweiser:/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal$ blat ~/reference/genomefasta/GRCh38.d1.vd1.fa uniquePeptidesCandidates_LR.fa out.psl -t=dnax -q=prot -minScore=0 -tileSize=5 -stepSize=1 -minIdentity=5 -repMatch=10000000 ; cat out.psl | awk '{if($1==$11){print}}' > out.filtered.psl
```

```{r}
blat.result <- read.delim("out.filtered.psl", header = FALSE, sep = "\t")

blat.result <- blat.result[blat.result$V18 == 1,]

blat.result$location <- paste0(blat.result$V14,':',blat.result$V16,'-',blat.result$V17)

table.blat.result <- as.data.frame(table(blat.result$V10))

table.blat.result$peptide <- gsub('CAND_','',table.blat.result$Var1)

massSpecPeptide.GSCTE_LR.table.b49$blatNum <- table.blat.result$Freq[match(massSpecPeptide.GSCTE_LR.table.b49$sequence, table.blat.result$peptide)]

massSpecPeptide.GSCTE_LR.table.b49$blatNum[is.na(massSpecPeptide.GSCTE_LR.table.b49$blatNum)] <- 0

table.blat.result.LR <- table.blat.result 
```

# Longread Graph creation

## Main Figure

Get numbers together for the main graphs
```{r}
gffcompare.stats <- data.frame(labels = c("Exons","Introns","Loci"),
                               missed = c(39652, 25668, 0),
                               refrencetotal = c(216386, 169097, 17378))

gffcompare.stats$percentage <- 1 - gffcompare.stats$missed/gffcompare.stats$refrencetotal
gffcompare.stats$proportionlabel <- paste0(gffcompare.stats$refrencetotal-gffcompare.stats$missed,"/",gffcompare.stats$refrencetotal)

gffcompare.stats.new <- data.frame(labels = c("Exons","Introns","Loci"),
                               number = c(12852, 8126, 1150))

LR.B49.stats <- data.frame(treatment = c("DMSO", "DP"),
                           count = c(sum(annotatedcufftranscripts.longread.e.B49$B49_WT >= 2),
                                     sum(annotatedcufftranscripts.longread.e.B49$B49_DP >= 2)))
  
LR.B49.stats.exclusive <- data.frame(treatment = c("DMSO", "DP"),
                           count = c(sum(annotatedcufftranscripts.longread.e.B49$B49_WT >= 2 & annotatedcufftranscripts.longread.e.B49$B49_DP == 0),
                                     sum(annotatedcufftranscripts.longread.e.B49$B49_DP >= 2 & annotatedcufftranscripts.longread.e.B49$B49_WT == 0)))
```

```{r}
p4a <- ggplot(gffcompare.stats, aes(labels, percentage)) +
  geom_bar(stat = "identity", width = 0.75, color = "black", fill = "seagreen3") +
  scale_y_continuous(expand = c(0,0)) +
  geom_text(aes(label = proportionlabel), hjust = 1.05, color = "black") +
  labs(y = "Proportion Identified") +
  coord_flip() +
  theme_classic() + 
  theme(axis.title.y = element_blank())

p4b <- ggplot(gffcompare.stats.new, aes(labels, number)) +
  geom_bar(stat = "identity", width = 0.75, color = "black", fill = "seagreen3") +
  scale_y_continuous(expand = c(0,0), limits = c(0,20000)) +
  geom_text(aes(label = number), hjust = -0.05, color = "black") +
  labs(y = "Novel Identified") +
  coord_flip() +
  theme_classic() + 
  theme(axis.title.y = element_blank())

p4c <- ggplot(LR.B49.stats, aes(treatment, count)) +
  geom_bar(aes(fill = treatment), stat = "identity", width = 0.5, alpha = 0.75, color = "black") +
  scale_y_continuous(expand = c(0,0), limits = c(0,2250)) +
  geom_text(aes(label = count), hjust = -0.05, color = "black") +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  labs(y = "No. TE Transcripts") +
  coord_flip() +
  theme_classic() + 
  theme(axis.title.y = element_blank(),
        legend.position = "None")

p4d <- ggplot(LR.B49.stats.exclusive, aes(treatment, count)) +
  geom_bar(aes(fill = treatment), stat = "identity", width = 0.5, alpha = 0.75, color = "black") +
  scale_y_continuous(expand = c(0,0), limits = c(0,1600)) +
  geom_text(aes(label = count), hjust = -0.05, color = "black") +
  scale_fill_manual(values = c("dodgerblue", "orchid3")) +
  labs(y = "No. Unique TE Transcripts") +
  coord_flip() +
  theme_classic() + 
  theme(axis.title.y = element_blank(),
        legend.position = "None")
```

```{r}
library(cowplot)

p4r1 <- plot_grid(p4a,p4b,p4c,p4d, ncol = 4, align = "hv")

ggsave2("./plots/N5_4ad_LRstats_COW.pdf", p4r1, width = 9, height = 1.5, device = cairo_pdf)
```

Next will be calculating numbers across the two treatment conditions for the dot plot of the antigens

```{r}
peptideTableFinalLR.bf <- peptideTableFinalLR[!(peptideTableFinalLR$sequence %in% blastResult$peptide),]
```


```{r}
cellLines <- c("B49 DMSO", "B49 DP")

GBMAntigenNumbers.LR <- data.frame(CL = cellLines,
                           `MS Detected Antigens` = c(length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_WT"])),
                                              length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_DP"]))),
                           `BLAST Filter` = c(length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_WT" & massSpecPeptide.GSCTE_LR.table.b49$blastdetected == FALSE])),
                                              length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_DP" & massSpecPeptide.GSCTE_LR.table.b49$blastdetected == FALSE]))),
                           `Genomic Support` = c(length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_WT" & massSpecPeptide.GSCTE_LR.table.b49$blastdetected == FALSE & massSpecPeptide.GSCTE_LR.table.b49$expression >= 2])),
                                              length(unique(massSpecPeptide.GSCTE_LR.table.b49$sequence[massSpecPeptide.GSCTE_LR.table.b49$sampleclean == "B49_DP" & massSpecPeptide.GSCTE_LR.table.b49$blastdetected == FALSE & massSpecPeptide.GSCTE_LR.table.b49$expression >= 2]))),
                           `Treatment Exclusive` = c(sum(peptideTableFinalLR.bf$B49_WT.MS == TRUE & peptideTableFinalLR.bf$B49_DP.MS == FALSE & peptideTableFinalLR.bf$B49_WT.LR >= 2 & peptideTableFinalLR.bf$B49_DP.LR < 2),
                                                     sum(peptideTableFinalLR.bf$B49_DP.MS == TRUE & peptideTableFinalLR.bf$B49_WT.MS == FALSE & peptideTableFinalLR.bf$B49_DP.LR >= 2 & peptideTableFinalLR.bf$B49_WT.LR < 2)))
```

```{r}
GBMAntigenNumbers.LR.m <- melt(GBMAntigenNumbers.LR, id.vars = c('CL'))

## Set the orders so that we get the correct positioning of the dots within the matrix
orderLabels <- colnames(GBMAntigenNumbers.LR)[2:length(colnames(GBMAntigenNumbers.LR))]

GBMAntigenNumbers.LR.m$variable <- factor(GBMAntigenNumbers.LR.m$variable, levels = orderLabels)

GBMAntigenNumbers.LR.m$CL <- factor(GBMAntigenNumbers.LR.m$CL, levels = rev(cellLines))
```


```{r}
segment.df <- data.frame(x = c(1,1,1),
                         y = c(1,1,2),
                         xends = c(1,4,4),
                         yends = c(2,1,2))
```

```{r}
p4e <- ggplot(GBMAntigenNumbers.LR.m, aes(x = variable, y = CL)) +
  geom_point(alpha = 0) +
  geom_segment(data = segment.df, aes(x = x,y = y,xend = xends, yend = yends), alpha = .5) +
  geom_point(aes(size = value), shape = 21, color = "black", fill = "aliceblue") +
  geom_text(aes(label = value)) +
  labs(y = "", x = "") +
  scale_size_continuous(range = c(6, 20)) +
  scale_x_discrete(labels=c("LC MS/MS\nDetected", "BLAST\nFilter", "Genomic\nSupport", "Treatment \nExclusive")) +
  theme_classic() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = 'none') 
p4e

ggsave("./plots/F4_GBM_LRAntigen_DotPlot.pdf", p4e, width = 4.5, height = 2, device = cairo_pdf)
```

```{r}
library(ggplot2)
library(ggbeeswarm)

seq.LR.DMSO <- peptideTableFinalLR.bf$sequence[peptideTableFinalLR.bf$B49_WT.MS == TRUE & peptideTableFinalLR.bf$B49_DP.MS == FALSE & peptideTableFinalLR.bf$B49_DP.LR <= 1 & peptideTableFinalLR.bf$B49_WT.LR >= 2]
seq.LR.DP <- peptideTableFinalLR.bf$sequence[peptideTableFinalLR.bf$B49_DP.MS == TRUE & peptideTableFinalLR.bf$B49_WT.MS == FALSE & peptideTableFinalLR.bf$B49_WT.LR <= 1 & peptideTableFinalLR.bf$B49_DP.LR >= 2]
seq.LR.DMSO.expression <- peptideTableFinalLR.bf$B49_WT.LR[peptideTableFinalLR.bf$B49_WT.MS == TRUE & peptideTableFinalLR.bf$B49_DP.MS == FALSE & peptideTableFinalLR.bf$B49_DP.LR <= 1 & peptideTableFinalLR.bf$B49_WT.LR >= 2]
seq.LR.DP.expression <- peptideTableFinalLR.bf$B49_DP.LR[peptideTableFinalLR.bf$B49_DP.MS == TRUE & peptideTableFinalLR.bf$B49_WT.MS == FALSE & peptideTableFinalLR.bf$B49_WT.LR <= 1 & peptideTableFinalLR.bf$B49_DP.LR >= 2]

expression.LR.df <- data.frame(treatment = c(rep("DMSO", length(seq.LR.DMSO.expression)), rep("DP", length(seq.LR.DP.expression))),
                               expression = c(seq.LR.DMSO.expression, seq.LR.DP.expression))
```

```{r}
p4f <- ggplot(expression.LR.df, aes(treatment, log2(expression))) +
  #geom_boxplot(color = "black", fill = "white", width = 0.25) +
  geom_beeswarm(aes(fill = treatment), size = 3, pch = 21, color = "black", cex = 10) +
  labs(y = "log2(Number of Reads)") +
  scale_fill_manual(values = c("orchid3")) +
  theme_classic() +
  theme(legend.position = "None",
        axis.title.x = element_blank())
p4f
```

We want to compare the amount of antigens found through various methods and try to explain the differences as well as make diagrams to help explain the reading frames that candidates come from. 

```{r}
massSpecPeptide.GSCTE_LR.table.b49.filtered <- massSpecPeptide.GSCTE_LR.table.b49[massSpecPeptide.GSCTE_LR.table.b49$sequence %in% as.character(seq.LR.DP),]

#We only want ones that have blat <= 1

massSpecPeptide.GSCTE_LR.table.b49.filtered.u <- massSpecPeptide.GSCTE_LR.table.b49.filtered[massSpecPeptide.GSCTE_LR.table.b49.filtered$blatNum <= 1,]

annotatedcufftranscripts.longread.e.B49.candidate <- annotatedcufftranscripts.longread.e.B49[annotatedcufftranscripts.longread.e.B49$transcriptname %in% massSpecPeptide.GSCTE_LR.table.b49.filtered.u$transcriptid,]

annotatedcufftranscripts.longread.e.B49.candidate.teg <- annotatedcufftranscripts.longread.e.B49.candidate[annotatedcufftranscripts.longread.e.B49.candidate$exonintron2 == "exon",]

massSpecPeptide.GSCTE_LR.table.b49.filtered.u$uniqid <- annotatedcufftranscripts.longread.e.B49.candidate.teg$uniqid[match(massSpecPeptide.GSCTE_LR.table.b49.filtered.u$transcriptid, annotatedcufftranscripts.longread.e.B49.candidate.teg$transcriptname)]
```



```{r}
library(VennDiagram)
library(Cairo)

p4g <- venn.diagram(list(A <- unique(peptides.teg.blastfiltered.fil$sequence[peptides.teg.blastfiltered.fil$B49_DP > 0]), 
                       B <- unique(b49unique.te.expression.m.f$sequence),
                       C <- as.character(seq.LR.DP)),
                  NULL,
                  fill=c("turquoise", "violet", "seagreen3"), 
                  alpha=c(0.5,0.5, 0.5), 
             cex = 1, 
             category.names=c("TE chimeric","All TE", "Long Read"))

```

```{r}
library(cowplot)

p4r2 <- plot_grid(p4e,p4f,grobTree(p4g), ncol = 3, align = "hv", rel_widths = c(1/2, 1/4, 1/4))

ggsave2("./plots/N5_4eg_LRstats_COW.pdf", p4r2, width = 9, height = 2, device = cairo_pdf)
```
```{r}
p4full <- plot_grid(p4r1,p4r2, ncol = 1, rel_heights = c(3/7, 4/7))

ggsave2("./plots/N5_4full_LRstats_COW.pdf", p4full , width = 9, height = 3.5, device = cairo_pdf)
```

#Supplementary Table Creation

```{r}
SuppData3 <- annotatedcufftranscripts.fil.c[,c("transcriptname", "classTE","familyTE", "subfamTE", "chrTE", "startTE", "endTE", "exonintron1", "number1", "gene2", "exonintron2", "number2","strand", "clusterPeak")]

SuppData3$LocationTE <- paste0(SuppData3$exonintron1,'_',SuppData3$number1)
SuppData3$LocationTE[SuppData3$LocationTE == "None_None"] <- "Intergenic"
SuppData3$SpliceTarget <- paste0(SuppData3$exonintron2,'_',SuppData3$number2)

SuppData3 <- SuppData3[,c("transcriptname", "classTE","familyTE", "subfamTE", "chrTE", "startTE", "endTE", "LocationTE", "gene2", "SpliceTarget" ,"strand", "clusterPeak")]

colnames(SuppData3) <- c('Transcript ID', 'Class','Family', 'Subfam','Chr TE',  'Start TE', 'End TE', 'Location TE', 'Gene', 'Splice Target', 'Strand', 'CAGE Peak')

SuppData3 <- SuppData3[order(SuppData3$`Transcript ID`),]
write.csv(SuppData3, "TABLE S3- TE-chimeric transcripts in GSC Cell Lines.csv", row.names = FALSE)
```
```{r}
SuppData4 <- proteinTableAnnotation 

SuppData4 <- SuppData4[,c("transcriptname", "subfamTE", "gene2", "strongstartindex", "type", "proteinseqfull2", "orig_proteinsequence", "strategy")]

SuppData4 <- SuppData4[,c("transcriptname", "subfamTE", "gene2", "strongstartindex", "type", "proteinseqfull2", "orig_proteinsequence", "strategy")]

colnames(SuppData4) <- c('Transcript ID', 'Subfam', 'Gene', 'Index of Start Codon', 'Frame Type', 'Protein Sequence', 'Original Protein Sequence', 'Strategy')

SuppData4 <- SuppData4[order(SuppData4$`Transcript ID`),]
write.csv(SuppData4, "TABLE S4- Protein Prediction of Candidate Transcripts.csv", row.names = FALSE)
```

```{r}
SuppData5 <- massSpecPeptide.GSC.table

SuppData5$brep <- sapply(SuppData5$sample, function(x) strsplit(x,"_")[[1]][length(strsplit(x,"_")[[1]])])
SuppData5$samplefinal <- paste0(SuppData5$sampleclean,"_",SuppData5$brep)

SuppData5 <- SuppData5[SuppData5$cagePresence == TRUE,]

SuppData5 <- SuppData5[,c("sequence", "samplefinal", "protein", "method", "uniqid", "cageTPM", "blatNum")]

colnames(SuppData5) <- c("Peptide Sequence", "Sample", "Protein", "Ms Detection Method", "Unique ID", "CAGE (TPM)", "Blat Number")

SuppData5 <- SuppData5[order(SuppData5$`Peptide Sequence`),]
write.csv(SuppData5, "TABLE S5- Detected TE-chimeric transcript antigens.csv", row.names = FALSE)
```

```{r}
SuppData7 <- massSpecPeptide.GSCTEAll.table.TeOnly

indexMatch <- match(SuppData7$uniqid, te_translation_table$Pepid)
SuppData7$subfamTE <- te_translation_table$subfam[indexMatch]
SuppData7$chrTE <- te_translation_table$chromosome[indexMatch]
SuppData7$startTE <- te_translation_table$start[indexMatch]
SuppData7$endTE <- te_translation_table$end[indexMatch]
SuppData7$strandTE <- te_translation_table$strand[indexMatch]
SuppData7$direction <- te_translation_table$direction[indexMatch]
SuppData7$startNucleotide <- te_translation_table$proteinstart[indexMatch]
SuppData7$endNucleotide <- te_translation_table$proteinend[indexMatch]

SuppData7 <- SuppData7[,c("sequence", "sampleclean.rep", "protein", "subfamTE", "chrTE", "startTE", "endTE", "strandTE", "direction", "startNucleotide", "endNucleotide", "blatNum")]

colnames(SuppData7) <- c("Peptide Sequence", "Sample", "Protein", "Subfamily", "Chromosome TE", "Start TE", "End TE", "Strand TE", "Direction Translation", "Start Nucleotide Number", "End Nucleotide Number", "Blat Number")

SuppData7 <- SuppData7[order(SuppData7$`Peptide Sequence`),]
write.csv(SuppData7, "TABLE S7- Detected endogenous transposable element transcript antigens.csv", row.names = FALSE)
```



```{r}
##Script used to draw heatmaps showing expressions in GTEx tissues.

library(RColorBrewer);library(circlize)
library("ComplexHeatmap", lib.loc="/bar/jmaeng/R/x86_64-pc-linux-gnu-library/3.6_custominstall/")
library(dplyr)

library(tidyr)
library(ggplot2)

setwd("/scratch/jmaeng/GSC_grad/analayis/GTEx_filtering")
idir="/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/gtexrebuttalanalysis/"

fMin=0; fMax=1; nTotalStep=50
vecCol.percent=colorRampPalette( c("#FFFFFF", "#000099" ) )(nTotalStep)
vecStep.percent=seq(fMin, fMax, length.out=nTotalStep)
calc_ht_size = function(ht, unit = "mm") {
  #https://jokergoo.github.io/2020/05/11/set-cell-width/height-in-the-heatmap/
  pdf(NULL)
  ht = draw(ht)
  w = ComplexHeatmap:::width(ht)
  w = convertX(w, unit, valueOnly = TRUE)
  h = ComplexHeatmap:::height(ht)
  h = convertY(h, unit, valueOnly = TRUE)
  dev.off()
  
  c(w, h)
}

#1. Load TEprof2 
df.antigenic=read.csv("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/revisionPlots/ActivatedandAntigenic.csv", header = T,stringsAsFactors = F)
vecTX.antigenic=df.antigenic$transcriptname

#2. Draw heatmap for TEprof2 data
df.mat.teprof2=read.table("matrix.teprof2.txt", stringsAsFactors = F, sep="\t", header = T, check.names = F)
mat.teprof2=as.matrix( df.mat.teprof2[df.mat.teprof2$transcriptname %in% vecTX.antigenic & 
                                        df.mat.teprof2$sequence.cand!="NAs", c( "Brain", "Testis", 
                                                                              "Breast", "Cervix Uteri", "Fallopian Tube", "Ovary", "Uterus", "Vagina", "Prostate",
                                                                              "Adipose Tissue",  "Adrenal Gland", "Bladder", "Blood", "Blood Vessel", 
                                                                              "Colon", "Esophagus","Heart", "Kidney", "Liver", "Lung", "Muscle", "Nerve", "Pancreas", "Pituitary", "Salivary Gland", "Skin", "Small Intestine", "Spleen", "Stomach", "Thyroid")] )
rownames(mat.teprof2)=df.mat.teprof2[df.mat.teprof2$transcriptname %in% vecTX.antigenic &
                                       df.mat.teprof2$sequence.cand!="NAs",]$transcriptname

rowAnnot<-HeatmapAnnotation(
  `Tissue\ncount`=anno_barplot( df.mat.teprof2[ df.mat.teprof2$transcriptname %in% vecTX.antigenic &
                                                  df.mat.teprof2$sequence.cand!="NAs",]$num_active_tissue, 
                                bar_width = 0.5, axis_param = list(direction = "reverse"), ylim=c(0, 30)
  ),
  which="row");
rowAnnot.txname<-HeatmapAnnotation(
  txname = anno_mark(at = c(1:9), 
                     labels = rownames(mat.teprof2) ),
  which="row");



nCellWidth=8 #mm
nCellHeight=8 #mm #nCellHeight=4 #mm

df.mat.teprof2[df.mat.teprof2$sequence.cand!="NAs",1:2]

hm<-ComplexHeatmap::Heatmap(mat.teprof2, name="percent",
                            width = ncol(mat.teprof2)*unit(nCellWidth, "mm"), height = nrow(mat.teprof2)*unit(nCellHeight, "mm"),
                            cluster_columns=F, cluster_rows=F,
                            show_row_names=F, row_names_side="left",
                            left_annotation = rowAnnot,right_annotation = rowAnnot.txname,
                            rect_gp = gpar(col = "white", lwd = 2),
                            
                            col = colorRamp2( breaks=vecStep.percent, colors=vecCol.percent),
                            
                            column_split = factor( c(rep( "imm.\nprev.", 2), rep("sex-specific", 7), rep("others", 21) ), 
                                                   levels=c("imm.\nprev.", "sex-specific", "others")),
                            column_title_gp = gpar(fill = c("white", "white", "white")),
                            
                            row_split=factor( c(rep("SETKNPPIP", 3), "RYHRLYFLF", "LISNSWGQAI", "IYHRQQNRF", "GLFCGDVHTV"), 
                                              levels=c("SETKNPPIP", "RYHRLYFLF", "LISNSWGQAI", "IYHRQQNRF", "GLFCGDVHTV")),
                            row_title_rot = 0)
hm.dimension=calc_ht_size(hm)
pdf("jmaeng_heatmap_gtex_exp.teprofantigen.v3.pdf",
    width = grid::convertUnit( unit(hm.dimension[1], "mm"), "inches", valueOnly=T ),
    height = grid::convertUnit( unit(hm.dimension[2], "mm"), "inches", valueOnly=T ))
ComplexHeatmap::draw( hm )
dev.off()



##NA_antigen
mat.teprof2.NA_antigen=as.matrix( df.mat.teprof2[df.mat.teprof2$transcriptname %in% vecTX.antigenic & 
                                                   df.mat.teprof2$sequence.cand=="NAs", c( "Brain", "Testis", 
                                                                                         "Breast", "Cervix Uteri", "Fallopian Tube", "Ovary", "Uterus", "Vagina", "Prostate",
                                                                                         "Adipose Tissue",  "Adrenal Gland", "Bladder", "Blood", "Blood Vessel", 
                                                                                         "Colon", "Esophagus","Heart", "Kidney", "Liver", "Lung", "Muscle", "Nerve", "Pancreas", "Pituitary", "Salivary Gland", "Skin", "Small Intestine", "Spleen", "Stomach", "Thyroid")] )
rownames(mat.teprof2.NA_antigen)=df.mat.teprof2[df.mat.teprof2$transcriptname %in% vecTX.antigenic & 
                                                  df.mat.teprof2$sequence.cand=="NAs",]$transcriptname

rowAnnot.NA_antigen<-HeatmapAnnotation(
  `Tissue\ncount`=anno_barplot( df.mat.teprof2[df.mat.teprof2$transcriptname %in% vecTX.antigenic & 
                                                 df.mat.teprof2$sequence.cand=="NAs",]$num_active_tissue, 
                                bar_width = 0.5, axis_param = list(direction = "reverse"), ylim=c(0, 30)
  ),
  which="row");
rowAnnot.NA_antigen.txname<-HeatmapAnnotation(
  txname = anno_mark(at = c(1:10), 
                     labels = rownames(mat.teprof2.NA_antigen[c(1:10),]) ),
  which="row");


nCellHeight.NA_antigen=3 #mm #nCellHeight=4 #mm
hm.NA_antigen<-ComplexHeatmap::Heatmap(mat.teprof2.NA_antigen, name="percent",
                                       width = ncol(mat.teprof2.NA_antigen)*unit(nCellWidth, "mm"), height = nrow(mat.teprof2.NA_antigen)*unit(nCellHeight.NA_antigen, "mm"),
                                       cluster_columns=F, cluster_rows=F,
                                       show_row_names=F, row_names_side="left",
                                       left_annotation = rowAnnot.NA_antigen,right_annotation = rowAnnot.NA_antigen.txname,
                                       rect_gp = gpar(col = "white", lwd = 2),
                                       
                                       col = colorRamp2( breaks=vecStep.percent, colors=vecCol.percent),
                                       
                                       column_split = factor( c(rep( "imm.\nprev.", 2), rep("sex-specific", 7), rep("others", 21) ), 
                                                              levels=c("imm.\nprev.", "sex-specific", "others")),
                                       column_title_gp = gpar(fill = c("white", "white", "white")),
                                       
                                       #row_split=factor( c(rep("SETKNPPIP", 5), "RYHRLYFLF", "LISNSWGQAI", "IYHRQQNRF", "GLFCGDVHTV"), 
                                       #                  levels=c("SETKNPPIP", "RYHRLYFLF", "LISNSWGQAI", "IYHRQQNRF", "GLFCGDVHTV")),
                                       row_title_rot = 0)
hm.dimension.NA_antigen=calc_ht_size(hm.NA_antigen)
pdf("jmaeng_heatmap_gtex_exp.teprofantigen.NA_antigens.v3.pdf",
    width = grid::convertUnit( unit(hm.dimension.NA_antigen[1], "mm"), "inches", valueOnly=T ),
    height = grid::convertUnit( unit(hm.dimension.NA_antigen[2], "mm"), "inches", valueOnly=T ))
ComplexHeatmap::draw( hm.NA_antigen )
dev.off()

##Stats for response figure
df.exp_quies=read.csv("/scratch/nakul/TE_Antigen_glioblastoma_project/nanoCAGE_analysisFinal/revisionPlots/ActivatedandAntigenic_QExpression.csv", stringsAsFactors = F, header=T)
dfg.exp_quies<-df.exp_quies[, c("transcriptname", "QNHA_DMSO" ,  "QNHA_DP",  "QhFB_DMSO","QhFB_DP")] %>% tidyr::gather( "type", "TPM", QNHA_DMSO:QhFB_DP)
dfg.exp_quies$cell<-apply(dfg.exp_quies, 1, function(a_x){stringr::str_split(a_x[2], "_")[[1]][1];})
dfg.exp_quies$treatment<-apply(dfg.exp_quies, 1, function(a_x){stringr::str_split(a_x[2], "_")[[1]][2];})
dfg.exp_quies$islabel=ifelse(dfg.exp_quies$TPM>1, "O", "X")
dfg.exp_quies$cell=factor(dfg.exp_quies$cell, levels=c("QNHA", "QhFB"))
pdf("jmaeng_dotplot_exp_inquiescent.pdf", width = 4.5, height=2.5)
ggplot(data=dfg.exp_quies, aes(x=treatment,  y=log2(1+TPM), color=treatment))+
  geom_violin(color="black")+
  geom_line(aes(group = transcriptname), color="black", alpha=0.1) + 
  geom_point(size=1)+
  scale_color_manual(values=c("DMSO"="#C191BB", "DP"="#7E9FCC"))+
  geom_hline( yintercept = log2(1+1), linetype="dashed", color="red")+
  theme_classic()+
  facet_grid(.~cell)
dev.off()
length( unique( dfg.exp_quies[dfg.exp_quies$TPM>1, ]$transcriptname ) )

#LRCAGE heatmap

df.mat.LRCAGE=read.table("matrix.LRCAGE.txt", stringsAsFactors = F, sep="\t", header = T, check.names = F)
mat.LRCAGE=as.matrix( df.mat.LRCAGE[, c( "Brain", "Testis", 
                                         "Breast", "Cervix Uteri", "Fallopian Tube", "Ovary", "Uterus", "Vagina", "Prostate",
                                         "Adipose Tissue",  "Adrenal Gland", "Bladder", "Blood", "Blood Vessel", 
                                         "Colon", "Esophagus","Heart", "Kidney", "Liver", "Lung", "Muscle", "Nerve", "Pancreas", "Pituitary", "Salivary Gland", "Skin", "Small Intestine", "Spleen", "Stomach", "Thyroid")] )
rownames(mat.LRCAGE)=df.mat.LRCAGE$transcriptname


rowAnnot.LRCAGE<-HeatmapAnnotation(
  `Tissue\ncount`=anno_barplot( df.mat.LRCAGE$num_active_tissue, 
                                bar_width = 0.5, axis_param = list(direction = "reverse"), ylim=c(0, 30)),
  which="row");

nCellHeight.LRCAGE=4 #mm #nCellHeight=4 #mm


hm.LRCAGE<-ComplexHeatmap::Heatmap(mat.LRCAGE, name="percent",
                                   width = ncol(mat.LRCAGE)*unit(nCellWidth, "mm"), height = nrow(mat.LRCAGE)*unit(nCellHeight.LRCAGE, "mm"),
                                   cluster_columns=F, cluster_rows=F,
                                   show_row_names=T, row_names_side="right",
                                   left_annotation = rowAnnot.LRCAGE,
                                   rect_gp = gpar(col = "white", lwd = 2),
                                   
                                   col = colorRamp2( breaks=vecStep.percent, colors=vecCol.percent),
                                   
                                   column_split = factor( c(rep( "imm.\nprev.", 2), rep("sex-specific", 7), rep("others", 21) ), 
                                                          levels=c("imm.\nprev.", "sex-specific", "others")),
                                   column_title_gp = gpar(fill = c("white", "white", "white")),
                                   
                                   row_split=factor( c(rep("IYHRQQNRF", 2), rep("GLFCGDVHTV", 2), "VSVDLNIII", 
                                                       rep("RYHRLYFLF", 9), "LIVNRKTVE", "ALYPSYLIW", "GLFFMKQSV", "LTGLTAISYI",
                                                       "RQPTKWEKI", rep("APTPITGPSL", 2), "KGIEKLVD", "KLSLFYHEL", "LFTASFPSVL",
                                                       "SVPAVTLAA"
                                   ), 
                                   levels=c("IYHRQQNRF", "GLFCGDVHTV", "VSVDLNIII", "RYHRLYFLF", 
                                            "LIVNRKTVE", "ALYPSYLIW", "GLFFMKQSV", "LTGLTAISYI", "RQPTKWEKI",
                                            "APTPITGPSL", "KGIEKLVD", "KLSLFYHEL", "LFTASFPSVL",
                                            "SVPAVTLAA"))
                                   ,
                                   row_title_rot = 0)
hm.LRCAGE.dimension=calc_ht_size(hm.LRCAGE)
pdf("jmaeng_heatmap_gtex_exp.LRCAGEantigen.v2.pdf",
    width = grid::convertUnit( unit(hm.LRCAGE.dimension[1], "mm"), "inches", valueOnly=T ),
    height = grid::convertUnit( unit(hm.LRCAGE.dimension[2], "mm"), "inches", valueOnly=T ))
ComplexHeatmap::draw( hm.LRCAGE )
dev.off()



#Manual sorting of long read matrixes for heatmap
df.mat.LRCAGE=read.table("matrix.LRCAGE.txt", stringsAsFactors = F, sep="\t", header = T, check.names = F)
df.mat.LRCAGE.reordered=df.mat.LRCAGE[c(24, 17, 3, 4, 18, 
                                        22, 6:14, 20:21, 
                                        2, 1, 5, 15:16,
                                        19, 23, 25),]
mat.LRCAGE.reordered=as.matrix( df.mat.LRCAGE.reordered[, c( "Brain", "Testis", 
                                         "Breast", "Cervix Uteri", "Fallopian Tube", "Ovary", "Uterus", "Vagina", "Prostate",
                                         "Adipose Tissue",  "Adrenal Gland", "Bladder", "Blood", "Blood Vessel", 
                                         "Colon", "Esophagus","Heart", "Kidney", "Liver", "Lung", "Muscle", "Nerve", "Pancreas", "Pituitary", "Salivary Gland", "Skin", "Small Intestine", "Spleen", "Stomach", "Thyroid")] )
rownames(mat.LRCAGE.reordered)=df.mat.LRCAGE.reordered$transcriptname


rowAnnot.LRCAGE.reordered<-HeatmapAnnotation(
  `Tissue\ncount`=anno_barplot( df.mat.LRCAGE.reordered$num_active_tissue, 
                                bar_width = 0.5, axis_param = list(direction = "reverse"), ylim=c(0, 30)),
  which="row");

nCellHeight.LRCAGE=4 #mm #nCellHeight=4 #mm


hm.LRCAGE.reordered<-ComplexHeatmap::Heatmap(mat.LRCAGE.reordered, name="percent",
                                   width = ncol(mat.LRCAGE)*unit(nCellWidth, "mm"), height = nrow(mat.LRCAGE)*unit(nCellHeight.LRCAGE, "mm"),
                                   cluster_columns=F, cluster_rows=F,
                                   show_row_names=T, row_names_side="right",
                                   left_annotation = rowAnnot.LRCAGE.reordered,
                                   rect_gp = gpar(col = "white", lwd = 2),
                                   
                                   col = colorRamp2( breaks=vecStep.percent, colors=vecCol.percent),
                                   
                                   column_split = factor( c(rep( "imm.\nprev.", 2), rep("sex-specific", 7), rep("others", 21) ), 
                                                          levels=c("imm.\nprev.", "sex-specific", "others")),
                                   column_title_gp = gpar(fill = c("white", "white", "white")),
                                   row_split=factor( c("LFTASFPSVL", "GLFFMKQSV", rep("GLFCGDVHTV", 2), "LTGLTAISYI", 
                                                       "KGIEKLVD", rep("RYHRLYFLF", 9), rep("APTPITGPSL", 2), "IYHRQQNRF_Q", "IYHRQQNRF", 
                                                       "VSVDLNIII", 
                                                       "LIVNRKTVE", "ALYPSYLIW", 
                                                       "RQPTKWEKI",   "KLSLFYHEL", 
                                                       "SVPAVTLAA"
                                   ), 
                                   levels=c("LFTASFPSVL", "GLFFMKQSV", "GLFCGDVHTV", "LTGLTAISYI", "KGIEKLVD",
                                            "RYHRLYFLF", "APTPITGPSL", "IYHRQQNRF_Q", "IYHRQQNRF", "VSVDLNIII", 
                                            "LIVNRKTVE", "ALYPSYLIW",   "RQPTKWEKI",
                                            "KLSLFYHEL", 
                                            "SVPAVTLAA")),
                                   row_title_rot = 0)
hm.LRCAGE.reordered.dimension=calc_ht_size(hm.LRCAGE.reordered)
pdf("jmaeng_heatmap_gtex_exp.LRCAGEantigen.reordered.v2.pdf",
    width = grid::convertUnit( unit(hm.LRCAGE.reordered.dimension[1], "mm"), "inches", valueOnly=T ),
    height = grid::convertUnit( unit(hm.LRCAGE.reordered.dimension[2], "mm"), "inches", valueOnly=T ))
ComplexHeatmap::draw( hm.LRCAGE.reordered )
dev.off()
```